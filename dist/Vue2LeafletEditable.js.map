{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///Vue2LeafletEditable.js","webpack:///webpack/bootstrap ab1e40ceaf21c8c66859","webpack:///./Vue2LeafletEditable.js","webpack:///external \"leaflet\""],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_1__","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","Symbol","iterator","window","undefined","apply","L","Editable","Evented","extend","statics","FORWARD","BACKWARD","options","zIndex","polygonClass","Polygon","polylineClass","Polyline","markerClass","Marker","rectangleClass","Rectangle","circleClass","Circle","drawingCSSClass","drawingCursor","editLayer","featuresLayer","polylineEditorClass","polygonEditorClass","markerEditorClass","rectangleEditorClass","circleEditorClass","lineGuideOptions","skipMiddleMarkers","initialize","map","setOptions","_lastZIndex","createEditLayer","createFeaturesLayer","forwardLineGuide","createLineGuide","backwardLineGuide","fireAndForward","type","e","editTools","fire","dashArray","weight","interactive","polyline","createVertexIcon","Browser","mobile","touch","TouchVertexIcon","VertexIcon","LayerGroup","addTo","moveForwardLineGuide","latlng","_latlngs","length","_bounds","redraw","moveBackwardLineGuide","anchorForwardLineGuide","anchorBackwardLineGuide","attachForwardLineGuide","addLayer","attachBackwardLineGuide","detachForwardLineGuide","setLatLngs","removeLayer","detachBackwardLineGuide","blockEvents","_oldTargets","_targets","unblockEvents","registerForDrawing","editor","_drawingEditor","unregisterForDrawing","reset","on","onDrawingMouseMove","onMousedown","onMouseup","DomUtil","addClass","_container","defaultMapCursor","style","cursor","removeClass","off","_drawing","cancelDrawing","originalEvent","which","_mouseDown","onDrawingMouseDown","mouseDown","onDrawingMouseUp","origin","point","clientX","clientY","distance","distanceTo","Math","abs","devicePixelRatio","onDrawingClick","drawing","stopDrawing","commitDrawing","connectCreatedToMap","layer","startPolyline","line","createPolyline","enableEdit","newShape","startPolygon","polygon","createPolygon","startMarker","getCenter","clone","marker","createMarker","startDrawing","startRectangle","corner","latLng","bounds","LatLngBounds","rectangle","createRectangle","startCircle","circle","createCircle","startHole","newHole","createLayer","klass","latlngs","Util","editOptions","makeCancellable","cancel","_cancelled","Map","mergeOptions","editToolsClass","editable","addInitHook","whenReady","DivIcon","iconSize","Point","VertexMarker","draggable","className","icon","tools","__vertex","setZIndexOffset","onAdd","onDrag","onDragStart","onDragEnd","onClick","onContextMenu","onMouseDown","onMouseOver","onMouseOut","addMiddleMarkers","onRemove","middleMarker","delete","vertex","onVertexMarkerDrag","iconPos","getPosition","_icon","_map","layerPointToLatLng","update","_latlng","refresh","updateLatLng","next","getNext","onVertexMarkerDragStart","onVertexMarkerDragEnd","onVertexMarkerClick","DomEvent","stop","onVertexMarkerContextMenu","onVertexMarkerMouseDown","onVertexMarkerMouseOver","onVertexMarkerMouseOut","splice","getIndex","onVertexDeleted","deleteShape","resetMiddleMarker","indexOf","getLastIndex","getPrevious","index","previousIndex","CLOSED","previous","nextIndex","addMiddleMarker","hasMiddleMarkers","split","splitShape","continue","continueBackward","continueForward","vertexMarkerClass","MiddleMarker","opacity","left","right","computeLatLng","_opacity","setVisibility","leftPoint","latLngToContainerPoint","rightPoint","size","x","hide","show","setOpacity","setLatLng","y","containerPointToLatLng","onMiddleMarkerMouseDown","addVertexMarker","onNewVertex","parent","parentNode","removeChild","appendChild","_initIcon","_initInteraction","Draggable","_dragging","dragging","_draggable","_onDown","middleMarkerClass","BaseEditor","Handler","feature","addHooks","isConnected","onFeatureAdd","once","onEnable","_getEvents","removeHooks","disable","clearLayers","onDisable","enable","onEditing","onStartDrawing","onEndDrawing","onCancelDrawing","onCommitDrawing","endDrawing","connect","processDrawingClick","hasLayer","onMove","dragstart","drag","dragend","remove","MarkerEditor","PathEditor","MIN_VERTEX","initVertexMarkers","enabled","getLatLngs","isFlat","addVertexMarkers","refreshVertexMarkers","getDefaultLatLngs","commit","ctrlKey","onVertexMarkerCtrlClick","altKey","onVertexMarkerAltClick","shiftKey","onVertexMarkerShiftClick","metaKey","onVertexMarkerMetaKeyClick","_drawnLatLngs","onVertexRawMarkerClick","vertexCanBeDeleted","extendBounds","setDrawnLatLngs","startDrawingForward","addLatLng","push","unshift","newPointForward","newPointBackward","console","error","removeLatLng","pop","shape","addNewEmptyShape","_deleteShape","ensureNotFlat","self","spliceDelete","Number","MAX_VALUE","deleteShapeAt","shapeAt","appendShape","insertShape","prependShape","ensureMulti","formatShape","_enabled","PolylineEditor","startDrawingBackward","LatLng","shapeIndex","first","slice","second","lat","lng","alt","PolygonEditor","addNewEmptyHole","holes","parentShape","RectangleEditor","oppositeIndex","opposite","updateBounds","updateLatLngs","_simulated","_onUp","newLatlngs","_boundsToLatLngs","CircleEditor","_resizeLatLng","computeResizeLatLng","delta","_radius","_mRadius","cos","PI","project","unproject","updateResizeLatLng","resize","radius","setRadius","EditableMixin","createEditor","Error","editorClass","getEditorClass","editEnabled","disableEdit","toggleEdit","_onEditableAdd","PolylineMixin","isInLatLngs","k","len","part","w","_clickTolerance","_projectLatlngs","_pxBounds","latLngToLayerPoint","contains","LineUtil","pointToSegmentDistance","PolygonMixin","l1","l2","j","len2","inside","idx","MarkerMixin","RectangleMixin","CircleMixin","keepEditable","_flat","include"],"mappings":"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","file":"Vue2LeafletEditable.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"leaflet\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"leaflet\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Vue2LeafletEditable\"] = factory(require(\"leaflet\"));\n\telse\n\t\troot[\"Vue2LeafletEditable\"] = factory(root[\"leaflet\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"leaflet\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"leaflet\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Vue2LeafletEditable\"] = factory(require(\"leaflet\"));\n\telse\n\t\troot[\"Vue2LeafletEditable\"] = factory(root[\"leaflet\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 2);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\nvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n(function (factory, window) {\n    /*globals define, module, require*/\n\n    // define an AMD module that relies on 'leaflet'\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n        // define a Common JS module that relies on 'leaflet'\n    } else if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') {\n        module.exports = factory(require('leaflet'));\n    }\n\n    // attach your plugin to the global 'L' variable\n    if (typeof window !== 'undefined' && window.L) {\n        factory(window.L);\n    }\n})(function (L) {\n    // 🍂miniclass CancelableEvent (Event objects)\n    // 🍂method cancel()\n    // Cancel any subsequent action.\n\n    // 🍂miniclass VertexEvent (Event objects)\n    // 🍂property vertex: VertexMarker\n    // The vertex that fires the event.\n\n    // 🍂miniclass ShapeEvent (Event objects)\n    // 🍂property shape: Array\n    // The shape (LatLngs array) subject of the action.\n\n    // 🍂miniclass CancelableVertexEvent (Event objects)\n    // 🍂inherits VertexEvent\n    // 🍂inherits CancelableEvent\n\n    // 🍂miniclass CancelableShapeEvent (Event objects)\n    // 🍂inherits ShapeEvent\n    // 🍂inherits CancelableEvent\n\n    // 🍂miniclass LayerEvent (Event objects)\n    // 🍂property layer: object\n    // The Layer (Marker, Polyline…) subject of the action.\n\n    // 🍂namespace Editable; 🍂class Editable; 🍂aka L.Editable\n    // Main edition handler. By default, it is attached to the map\n    // as `map.editTools` property.\n    // Leaflet.Editable is made to be fully extendable. You have three ways to customize\n    // the behaviour: using options, listening to events, or extending.\n    L.Editable = L.Evented.extend({\n\n        statics: {\n            FORWARD: 1,\n            BACKWARD: -1\n        },\n\n        options: {\n\n            // You can pass them when creating a map using the `editOptions` key.\n            // 🍂option zIndex: int = 1000\n            // The default zIndex of the editing tools.\n            zIndex: 1000,\n\n            // 🍂option polygonClass: class = L.Polygon\n            // Class to be used when creating a new Polygon.\n            polygonClass: L.Polygon,\n\n            // 🍂option polylineClass: class = L.Polyline\n            // Class to be used when creating a new Polyline.\n            polylineClass: L.Polyline,\n\n            // 🍂option markerClass: class = L.Marker\n            // Class to be used when creating a new Marker.\n            markerClass: L.Marker,\n\n            // 🍂option rectangleClass: class = L.Rectangle\n            // Class to be used when creating a new Rectangle.\n            rectangleClass: L.Rectangle,\n\n            // 🍂option circleClass: class = L.Circle\n            // Class to be used when creating a new Circle.\n            circleClass: L.Circle,\n\n            // 🍂option drawingCSSClass: string = 'leaflet-editable-drawing'\n            // CSS class to be added to the map container while drawing.\n            drawingCSSClass: 'leaflet-editable-drawing',\n\n            // 🍂option drawingCursor: const = 'crosshair'\n            // Cursor mode set to the map while drawing.\n            drawingCursor: 'crosshair',\n\n            // 🍂option editLayer: Layer = new L.LayerGroup()\n            // Layer used to store edit tools (vertex, line guide…).\n            editLayer: undefined,\n\n            // 🍂option featuresLayer: Layer = new L.LayerGroup()\n            // Default layer used to store drawn features (Marker, Polyline…).\n            featuresLayer: undefined,\n\n            // 🍂option polylineEditorClass: class = PolylineEditor\n            // Class to be used as Polyline editor.\n            polylineEditorClass: undefined,\n\n            // 🍂option polygonEditorClass: class = PolygonEditor\n            // Class to be used as Polygon editor.\n            polygonEditorClass: undefined,\n\n            // 🍂option markerEditorClass: class = MarkerEditor\n            // Class to be used as Marker editor.\n            markerEditorClass: undefined,\n\n            // 🍂option rectangleEditorClass: class = RectangleEditor\n            // Class to be used as Rectangle editor.\n            rectangleEditorClass: undefined,\n\n            // 🍂option circleEditorClass: class = CircleEditor\n            // Class to be used as Circle editor.\n            circleEditorClass: undefined,\n\n            // 🍂option lineGuideOptions: hash = {}\n            // Options to be passed to the line guides.\n            lineGuideOptions: {},\n\n            // 🍂option skipMiddleMarkers: boolean = false\n            // Set this to true if you don't want middle markers.\n            skipMiddleMarkers: false\n\n        },\n\n        initialize: function initialize(map, options) {\n            L.setOptions(this, options);\n            this._lastZIndex = this.options.zIndex;\n            this.map = map;\n            this.editLayer = this.createEditLayer();\n            this.featuresLayer = this.createFeaturesLayer();\n            this.forwardLineGuide = this.createLineGuide();\n            this.backwardLineGuide = this.createLineGuide();\n        },\n\n        fireAndForward: function fireAndForward(type, e) {\n            e = e || {};\n            e.editTools = this;\n            this.fire(type, e);\n            this.map.fire(type, e);\n        },\n\n        createLineGuide: function createLineGuide() {\n            var options = L.extend({ dashArray: '5,10', weight: 1, interactive: false }, this.options.lineGuideOptions);\n            return L.polyline([], options);\n        },\n\n        createVertexIcon: function createVertexIcon(options) {\n            return L.Browser.mobile && L.Browser.touch ? new L.Editable.TouchVertexIcon(options) : new L.Editable.VertexIcon(options);\n        },\n\n        createEditLayer: function createEditLayer() {\n            return this.options.editLayer || new L.LayerGroup().addTo(this.map);\n        },\n\n        createFeaturesLayer: function createFeaturesLayer() {\n            return this.options.featuresLayer || new L.LayerGroup().addTo(this.map);\n        },\n\n        moveForwardLineGuide: function moveForwardLineGuide(latlng) {\n            if (this.forwardLineGuide._latlngs.length) {\n                this.forwardLineGuide._latlngs[1] = latlng;\n                this.forwardLineGuide._bounds.extend(latlng);\n                this.forwardLineGuide.redraw();\n            }\n        },\n\n        moveBackwardLineGuide: function moveBackwardLineGuide(latlng) {\n            if (this.backwardLineGuide._latlngs.length) {\n                this.backwardLineGuide._latlngs[1] = latlng;\n                this.backwardLineGuide._bounds.extend(latlng);\n                this.backwardLineGuide.redraw();\n            }\n        },\n\n        anchorForwardLineGuide: function anchorForwardLineGuide(latlng) {\n            this.forwardLineGuide._latlngs[0] = latlng;\n            this.forwardLineGuide._bounds.extend(latlng);\n            this.forwardLineGuide.redraw();\n        },\n\n        anchorBackwardLineGuide: function anchorBackwardLineGuide(latlng) {\n            this.backwardLineGuide._latlngs[0] = latlng;\n            this.backwardLineGuide._bounds.extend(latlng);\n            this.backwardLineGuide.redraw();\n        },\n\n        attachForwardLineGuide: function attachForwardLineGuide() {\n            this.editLayer.addLayer(this.forwardLineGuide);\n        },\n\n        attachBackwardLineGuide: function attachBackwardLineGuide() {\n            this.editLayer.addLayer(this.backwardLineGuide);\n        },\n\n        detachForwardLineGuide: function detachForwardLineGuide() {\n            this.forwardLineGuide.setLatLngs([]);\n            this.editLayer.removeLayer(this.forwardLineGuide);\n        },\n\n        detachBackwardLineGuide: function detachBackwardLineGuide() {\n            this.backwardLineGuide.setLatLngs([]);\n            this.editLayer.removeLayer(this.backwardLineGuide);\n        },\n\n        blockEvents: function blockEvents() {\n            // Hack: force map not to listen to other layers events while drawing.\n            if (!this._oldTargets) {\n                this._oldTargets = this.map._targets;\n                this.map._targets = {};\n            }\n        },\n\n        unblockEvents: function unblockEvents() {\n            if (this._oldTargets) {\n                // Reset, but keep targets created while drawing.\n                this.map._targets = L.extend(this.map._targets, this._oldTargets);\n                delete this._oldTargets;\n            }\n        },\n\n        registerForDrawing: function registerForDrawing(editor) {\n            if (this._drawingEditor) this.unregisterForDrawing(this._drawingEditor);\n            this.blockEvents();\n            editor.reset(); // Make sure editor tools still receive events.\n            this._drawingEditor = editor;\n            this.map.on('mousemove touchmove', editor.onDrawingMouseMove, editor);\n            this.map.on('mousedown', this.onMousedown, this);\n            this.map.on('mouseup', this.onMouseup, this);\n            L.DomUtil.addClass(this.map._container, this.options.drawingCSSClass);\n            this.defaultMapCursor = this.map._container.style.cursor;\n            this.map._container.style.cursor = this.options.drawingCursor;\n        },\n\n        unregisterForDrawing: function unregisterForDrawing(editor) {\n            this.unblockEvents();\n            L.DomUtil.removeClass(this.map._container, this.options.drawingCSSClass);\n            this.map._container.style.cursor = this.defaultMapCursor;\n            editor = editor || this._drawingEditor;\n            if (!editor) return;\n            this.map.off('mousemove touchmove', editor.onDrawingMouseMove, editor);\n            this.map.off('mousedown', this.onMousedown, this);\n            this.map.off('mouseup', this.onMouseup, this);\n            if (editor !== this._drawingEditor) return;\n            delete this._drawingEditor;\n            if (editor._drawing) editor.cancelDrawing();\n        },\n\n        onMousedown: function onMousedown(e) {\n            if (e.originalEvent.which != 1) return;\n            this._mouseDown = e;\n            this._drawingEditor.onDrawingMouseDown(e);\n        },\n\n        onMouseup: function onMouseup(e) {\n            if (this._mouseDown) {\n                var editor = this._drawingEditor,\n                    mouseDown = this._mouseDown;\n                this._mouseDown = null;\n                editor.onDrawingMouseUp(e);\n                if (this._drawingEditor !== editor) return; // onDrawingMouseUp may call unregisterFromDrawing.\n                var origin = L.point(mouseDown.originalEvent.clientX, mouseDown.originalEvent.clientY);\n                var distance = L.point(e.originalEvent.clientX, e.originalEvent.clientY).distanceTo(origin);\n                if (Math.abs(distance) < 9 * (window.devicePixelRatio || 1)) this._drawingEditor.onDrawingClick(e);\n            }\n        },\n\n        // 🍂section Public methods\n        // You will generally access them by the `map.editTools`\n        // instance:\n        //\n        // `map.editTools.startPolyline();`\n\n        // 🍂method drawing(): boolean\n        // Return true if any drawing action is ongoing.\n        drawing: function drawing() {\n            return this._drawingEditor && this._drawingEditor.drawing();\n        },\n\n        // 🍂method stopDrawing()\n        // When you need to stop any ongoing drawing, without needing to know which editor is active.\n        stopDrawing: function stopDrawing() {\n            this.unregisterForDrawing();\n        },\n\n        // 🍂method commitDrawing()\n        // When you need to commit any ongoing drawing, without needing to know which editor is active.\n        commitDrawing: function commitDrawing(e) {\n            if (!this._drawingEditor) return;\n            this._drawingEditor.commitDrawing(e);\n        },\n\n        connectCreatedToMap: function connectCreatedToMap(layer) {\n            return this.featuresLayer.addLayer(layer);\n        },\n\n        // 🍂method startPolyline(latlng: L.LatLng, options: hash): L.Polyline\n        // Start drawing a Polyline. If `latlng` is given, a first point will be added. In any case, continuing on user click.\n        // If `options` is given, it will be passed to the Polyline class constructor.\n        startPolyline: function startPolyline(latlng, options) {\n            var line = this.createPolyline([], options);\n            line.enableEdit(this.map).newShape(latlng);\n            return line;\n        },\n\n        // 🍂method startPolygon(latlng: L.LatLng, options: hash): L.Polygon\n        // Start drawing a Polygon. If `latlng` is given, a first point will be added. In any case, continuing on user click.\n        // If `options` is given, it will be passed to the Polygon class constructor.\n        startPolygon: function startPolygon(latlng, options) {\n            var polygon = this.createPolygon([], options);\n            polygon.enableEdit(this.map).newShape(latlng);\n            return polygon;\n        },\n\n        // 🍂method startMarker(latlng: L.LatLng, options: hash): L.Marker\n        // Start adding a Marker. If `latlng` is given, the Marker will be shown first at this point.\n        // In any case, it will follow the user mouse, and will have a final `latlng` on next click (or touch).\n        // If `options` is given, it will be passed to the Marker class constructor.\n        startMarker: function startMarker(latlng, options) {\n            latlng = latlng || this.map.getCenter().clone();\n            var marker = this.createMarker(latlng, options);\n            marker.enableEdit(this.map).startDrawing();\n            return marker;\n        },\n\n        // 🍂method startRectangle(latlng: L.LatLng, options: hash): L.Rectangle\n        // Start drawing a Rectangle. If `latlng` is given, the Rectangle anchor will be added. In any case, continuing on user drag.\n        // If `options` is given, it will be passed to the Rectangle class constructor.\n        startRectangle: function startRectangle(latlng, options) {\n            var corner = latlng || L.latLng([0, 0]);\n            var bounds = new L.LatLngBounds(corner, corner);\n            var rectangle = this.createRectangle(bounds, options);\n            rectangle.enableEdit(this.map).startDrawing();\n            return rectangle;\n        },\n\n        // 🍂method startCircle(latlng: L.LatLng, options: hash): L.Circle\n        // Start drawing a Circle. If `latlng` is given, the Circle anchor will be added. In any case, continuing on user drag.\n        // If `options` is given, it will be passed to the Circle class constructor.\n        startCircle: function startCircle(latlng, options) {\n            latlng = latlng || this.map.getCenter().clone();\n            var circle = this.createCircle(latlng, options);\n            circle.enableEdit(this.map).startDrawing();\n            return circle;\n        },\n\n        startHole: function startHole(editor, latlng) {\n            editor.newHole(latlng);\n        },\n\n        createLayer: function createLayer(klass, latlngs, options) {\n            options = L.Util.extend({ editOptions: { editTools: this } }, options);\n            var layer = new klass(latlngs, options);\n            // 🍂namespace Editable\n            // 🍂event editable:created: LayerEvent\n            // Fired when a new feature (Marker, Polyline…) is created.\n            this.fireAndForward('editable:created', { layer: layer });\n            return layer;\n        },\n\n        createPolyline: function createPolyline(latlngs, options) {\n            return this.createLayer(options && options.polylineClass || this.options.polylineClass, latlngs, options);\n        },\n\n        createPolygon: function createPolygon(latlngs, options) {\n            return this.createLayer(options && options.polygonClass || this.options.polygonClass, latlngs, options);\n        },\n\n        createMarker: function createMarker(latlng, options) {\n            return this.createLayer(options && options.markerClass || this.options.markerClass, latlng, options);\n        },\n\n        createRectangle: function createRectangle(bounds, options) {\n            return this.createLayer(options && options.rectangleClass || this.options.rectangleClass, bounds, options);\n        },\n\n        createCircle: function createCircle(latlng, options) {\n            return this.createLayer(options && options.circleClass || this.options.circleClass, latlng, options);\n        }\n\n    });\n\n    L.extend(L.Editable, {\n\n        makeCancellable: function makeCancellable(e) {\n            e.cancel = function () {\n                e._cancelled = true;\n            };\n        }\n\n    });\n\n    // 🍂namespace Map; 🍂class Map\n    // Leaflet.Editable add options and events to the `L.Map` object.\n    // See `Editable` events for the list of events fired on the Map.\n    // 🍂example\n    //\n    // ```js\n    // var map = L.map('map', {\n    //  editable: true,\n    //  editOptions: {\n    //    …\n    // }\n    // });\n    // ```\n    // 🍂section Editable Map Options\n    L.Map.mergeOptions({\n\n        // 🍂namespace Map\n        // 🍂section Map Options\n        // 🍂option editToolsClass: class = L.Editable\n        // Class to be used as vertex, for path editing.\n        editToolsClass: L.Editable,\n\n        // 🍂option editable: boolean = false\n        // Whether to create a L.Editable instance at map init.\n        editable: false,\n\n        // 🍂option editOptions: hash = {}\n        // Options to pass to L.Editable when instantiating.\n        editOptions: {}\n\n    });\n\n    L.Map.addInitHook(function () {\n\n        this.whenReady(function () {\n            if (this.options.editable) {\n                this.editTools = new this.options.editToolsClass(this, this.options.editOptions);\n            }\n        });\n    });\n\n    L.Editable.VertexIcon = L.DivIcon.extend({\n\n        options: {\n            iconSize: new L.Point(8, 8)\n        }\n\n    });\n\n    L.Editable.TouchVertexIcon = L.Editable.VertexIcon.extend({\n\n        options: {\n            iconSize: new L.Point(20, 20)\n        }\n\n    });\n\n    // 🍂namespace Editable; 🍂class VertexMarker; Handler for dragging path vertices.\n    L.Editable.VertexMarker = L.Marker.extend({\n\n        options: {\n            draggable: true,\n            className: 'leaflet-div-icon leaflet-vertex-icon'\n        },\n\n        // 🍂section Public methods\n        // The marker used to handle path vertex. You will usually interact with a `VertexMarker`\n        // instance when listening for events like `editable:vertex:ctrlclick`.\n\n        initialize: function initialize(latlng, latlngs, editor, options) {\n            // We don't use this._latlng, because on drag Leaflet replace it while\n            // we want to keep reference.\n            this.latlng = latlng;\n            this.latlngs = latlngs;\n            this.editor = editor;\n            L.Marker.prototype.initialize.call(this, latlng, options);\n            this.options.icon = this.editor.tools.createVertexIcon({ className: this.options.className });\n            this.latlng.__vertex = this;\n            this.editor.editLayer.addLayer(this);\n            this.setZIndexOffset(editor.tools._lastZIndex + 1);\n        },\n\n        onAdd: function onAdd(map) {\n            L.Marker.prototype.onAdd.call(this, map);\n            this.on('drag', this.onDrag);\n            this.on('dragstart', this.onDragStart);\n            this.on('dragend', this.onDragEnd);\n            this.on('mouseup', this.onMouseup);\n            this.on('click', this.onClick);\n            this.on('contextmenu', this.onContextMenu);\n            this.on('mousedown touchstart', this.onMouseDown);\n            this.on('mouseover', this.onMouseOver);\n            this.on('mouseout', this.onMouseOut);\n            this.addMiddleMarkers();\n        },\n\n        onRemove: function onRemove(map) {\n            if (this.middleMarker) this.middleMarker.delete();\n            delete this.latlng.__vertex;\n            this.off('drag', this.onDrag);\n            this.off('dragstart', this.onDragStart);\n            this.off('dragend', this.onDragEnd);\n            this.off('mouseup', this.onMouseup);\n            this.off('click', this.onClick);\n            this.off('contextmenu', this.onContextMenu);\n            this.off('mousedown touchstart', this.onMouseDown);\n            this.off('mouseover', this.onMouseOver);\n            this.off('mouseout', this.onMouseOut);\n            L.Marker.prototype.onRemove.call(this, map);\n        },\n\n        onDrag: function onDrag(e) {\n            e.vertex = this;\n            this.editor.onVertexMarkerDrag(e);\n            var iconPos = L.DomUtil.getPosition(this._icon),\n                latlng = this._map.layerPointToLatLng(iconPos);\n            this.latlng.update(latlng);\n            this._latlng = this.latlng; // Push back to Leaflet our reference.\n            this.editor.refresh();\n            if (this.middleMarker) this.middleMarker.updateLatLng();\n            var next = this.getNext();\n            if (next && next.middleMarker) next.middleMarker.updateLatLng();\n        },\n\n        onDragStart: function onDragStart(e) {\n            e.vertex = this;\n            this.editor.onVertexMarkerDragStart(e);\n        },\n\n        onDragEnd: function onDragEnd(e) {\n            e.vertex = this;\n            this.editor.onVertexMarkerDragEnd(e);\n        },\n\n        onClick: function onClick(e) {\n            e.vertex = this;\n            this.editor.onVertexMarkerClick(e);\n        },\n\n        onMouseup: function onMouseup(e) {\n            L.DomEvent.stop(e);\n            e.vertex = this;\n            this.editor.map.fire('mouseup', e);\n        },\n\n        onContextMenu: function onContextMenu(e) {\n            e.vertex = this;\n            this.editor.onVertexMarkerContextMenu(e);\n        },\n\n        onMouseDown: function onMouseDown(e) {\n            e.vertex = this;\n            this.editor.onVertexMarkerMouseDown(e);\n        },\n\n        onMouseOver: function onMouseOver(e) {\n            e.vertex = this;\n            this.editor.onVertexMarkerMouseOver(e);\n        },\n\n        onMouseOut: function onMouseOut(e) {\n            e.vertex = this;\n            this.editor.onVertexMarkerMouseOut(e);\n        },\n\n        // 🍂method delete()\n        // Delete a vertex and the related LatLng.\n        delete: function _delete() {\n            var next = this.getNext(); // Compute before changing latlng\n            this.latlngs.splice(this.getIndex(), 1);\n            this.editor.editLayer.removeLayer(this);\n            this.editor.onVertexDeleted({ latlng: this.latlng, vertex: this });\n            if (!this.latlngs.length) this.editor.deleteShape(this.latlngs);\n            if (next) next.resetMiddleMarker();\n            this.editor.refresh();\n        },\n\n        // 🍂method getIndex(): int\n        // Get the index of the current vertex among others of the same LatLngs group.\n        getIndex: function getIndex() {\n            return this.latlngs.indexOf(this.latlng);\n        },\n\n        // 🍂method getLastIndex(): int\n        // Get last vertex index of the LatLngs group of the current vertex.\n        getLastIndex: function getLastIndex() {\n            return this.latlngs.length - 1;\n        },\n\n        // 🍂method getPrevious(): VertexMarker\n        // Get the previous VertexMarker in the same LatLngs group.\n        getPrevious: function getPrevious() {\n            if (this.latlngs.length < 2) return;\n            var index = this.getIndex(),\n                previousIndex = index - 1;\n            if (index === 0 && this.editor.CLOSED) previousIndex = this.getLastIndex();\n            var previous = this.latlngs[previousIndex];\n            if (previous) return previous.__vertex;\n        },\n\n        // 🍂method getNext(): VertexMarker\n        // Get the next VertexMarker in the same LatLngs group.\n        getNext: function getNext() {\n            if (this.latlngs.length < 2) return;\n            var index = this.getIndex(),\n                nextIndex = index + 1;\n            if (index === this.getLastIndex() && this.editor.CLOSED) nextIndex = 0;\n            var next = this.latlngs[nextIndex];\n            if (next) return next.__vertex;\n        },\n\n        addMiddleMarker: function addMiddleMarker(previous) {\n            if (!this.editor.hasMiddleMarkers()) return;\n            previous = previous || this.getPrevious();\n            if (previous && !this.middleMarker) this.middleMarker = this.editor.addMiddleMarker(previous, this, this.latlngs, this.editor);\n        },\n\n        addMiddleMarkers: function addMiddleMarkers() {\n            if (!this.editor.hasMiddleMarkers()) return;\n            var previous = this.getPrevious();\n            if (previous) this.addMiddleMarker(previous);\n            var next = this.getNext();\n            if (next) next.resetMiddleMarker();\n        },\n\n        resetMiddleMarker: function resetMiddleMarker() {\n            if (this.middleMarker) this.middleMarker.delete();\n            this.addMiddleMarker();\n        },\n\n        // 🍂method split()\n        // Split the vertex LatLngs group at its index, if possible.\n        split: function split() {\n            if (!this.editor.splitShape) return; // Only for PolylineEditor\n            this.editor.splitShape(this.latlngs, this.getIndex());\n        },\n\n        // 🍂method continue()\n        // Continue the vertex LatLngs from this vertex. Only active for first and last vertices of a Polyline.\n        continue: function _continue() {\n            if (!this.editor.continueBackward) return; // Only for PolylineEditor\n            var index = this.getIndex();\n            if (index === 0) this.editor.continueBackward(this.latlngs);else if (index === this.getLastIndex()) this.editor.continueForward(this.latlngs);\n        }\n\n    });\n\n    L.Editable.mergeOptions({\n\n        // 🍂namespace Editable\n        // 🍂option vertexMarkerClass: class = VertexMarker\n        // Class to be used as vertex, for path editing.\n        vertexMarkerClass: L.Editable.VertexMarker\n\n    });\n\n    L.Editable.MiddleMarker = L.Marker.extend({\n\n        options: {\n            opacity: 0.5,\n            className: 'leaflet-div-icon leaflet-middle-icon',\n            draggable: true\n        },\n\n        initialize: function initialize(left, right, latlngs, editor, options) {\n            this.left = left;\n            this.right = right;\n            this.editor = editor;\n            this.latlngs = latlngs;\n            L.Marker.prototype.initialize.call(this, this.computeLatLng(), options);\n            this._opacity = this.options.opacity;\n            this.options.icon = this.editor.tools.createVertexIcon({ className: this.options.className });\n            this.editor.editLayer.addLayer(this);\n            this.setVisibility();\n        },\n\n        setVisibility: function setVisibility() {\n            var leftPoint = this._map.latLngToContainerPoint(this.left.latlng),\n                rightPoint = this._map.latLngToContainerPoint(this.right.latlng),\n                size = L.point(this.options.icon.options.iconSize);\n            if (leftPoint.distanceTo(rightPoint) < size.x * 3) this.hide();else this.show();\n        },\n\n        show: function show() {\n            this.setOpacity(this._opacity);\n        },\n\n        hide: function hide() {\n            this.setOpacity(0);\n        },\n\n        updateLatLng: function updateLatLng() {\n            this.setLatLng(this.computeLatLng());\n            this.setVisibility();\n        },\n\n        computeLatLng: function computeLatLng() {\n            var leftPoint = this.editor.map.latLngToContainerPoint(this.left.latlng),\n                rightPoint = this.editor.map.latLngToContainerPoint(this.right.latlng),\n                y = (leftPoint.y + rightPoint.y) / 2,\n                x = (leftPoint.x + rightPoint.x) / 2;\n            return this.editor.map.containerPointToLatLng([x, y]);\n        },\n\n        onAdd: function onAdd(map) {\n            L.Marker.prototype.onAdd.call(this, map);\n            L.DomEvent.on(this._icon, 'mousedown touchstart', this.onMouseDown, this);\n            map.on('zoomend', this.setVisibility, this);\n        },\n\n        onRemove: function onRemove(map) {\n            delete this.right.middleMarker;\n            L.DomEvent.off(this._icon, 'mousedown touchstart', this.onMouseDown, this);\n            map.off('zoomend', this.setVisibility, this);\n            L.Marker.prototype.onRemove.call(this, map);\n        },\n\n        onMouseDown: function onMouseDown(e) {\n            var iconPos = L.DomUtil.getPosition(this._icon),\n                latlng = this.editor.map.layerPointToLatLng(iconPos);\n            e = {\n                originalEvent: e,\n                latlng: latlng\n            };\n            if (this.options.opacity === 0) return;\n            L.Editable.makeCancellable(e);\n            this.editor.onMiddleMarkerMouseDown(e);\n            if (e._cancelled) return;\n            this.latlngs.splice(this.index(), 0, e.latlng);\n            this.editor.refresh();\n            var icon = this._icon;\n            var marker = this.editor.addVertexMarker(e.latlng, this.latlngs);\n            this.editor.onNewVertex(marker);\n            /* Hack to workaround browser not firing touchend when element is no more on DOM */\n            var parent = marker._icon.parentNode;\n            parent.removeChild(marker._icon);\n            marker._icon = icon;\n            parent.appendChild(marker._icon);\n            marker._initIcon();\n            marker._initInteraction();\n            marker.setOpacity(1);\n            /* End hack */\n            // Transfer ongoing dragging to real marker\n            L.Draggable._dragging = false;\n            marker.dragging._draggable._onDown(e.originalEvent);\n            this.delete();\n        },\n\n        delete: function _delete() {\n            this.editor.editLayer.removeLayer(this);\n        },\n\n        index: function index() {\n            return this.latlngs.indexOf(this.right.latlng);\n        }\n\n    });\n\n    L.Editable.mergeOptions({\n\n        // 🍂namespace Editable\n        // 🍂option middleMarkerClass: class = VertexMarker\n        // Class to be used as middle vertex, pulled by the user to create a new point in the middle of a path.\n        middleMarkerClass: L.Editable.MiddleMarker\n\n    });\n\n    // 🍂namespace Editable; 🍂class BaseEditor; 🍂aka L.Editable.BaseEditor\n    // When editing a feature (Marker, Polyline…), an editor is attached to it. This\n    // editor basically knows how to handle the edition.\n    L.Editable.BaseEditor = L.Handler.extend({\n\n        initialize: function initialize(map, feature, options) {\n            L.setOptions(this, options);\n            this.map = map;\n            this.feature = feature;\n            this.feature.editor = this;\n            this.editLayer = new L.LayerGroup();\n            this.tools = this.options.editTools || map.editTools;\n        },\n\n        // 🍂method enable(): this\n        // Set up the drawing tools for the feature to be editable.\n        addHooks: function addHooks() {\n            if (this.isConnected()) this.onFeatureAdd();else this.feature.once('add', this.onFeatureAdd, this);\n            this.onEnable();\n            this.feature.on(this._getEvents(), this);\n        },\n\n        // 🍂method disable(): this\n        // Remove the drawing tools for the feature.\n        removeHooks: function removeHooks() {\n            this.feature.off(this._getEvents(), this);\n            if (this.feature.dragging) this.feature.dragging.disable();\n            this.editLayer.clearLayers();\n            this.tools.editLayer.removeLayer(this.editLayer);\n            this.onDisable();\n            if (this._drawing) this.cancelDrawing();\n        },\n\n        // 🍂method drawing(): boolean\n        // Return true if any drawing action is ongoing with this editor.\n        drawing: function drawing() {\n            return !!this._drawing;\n        },\n\n        reset: function reset() {},\n\n        onFeatureAdd: function onFeatureAdd() {\n            this.tools.editLayer.addLayer(this.editLayer);\n            if (this.feature.dragging) this.feature.dragging.enable();\n        },\n\n        hasMiddleMarkers: function hasMiddleMarkers() {\n            return !this.options.skipMiddleMarkers && !this.tools.options.skipMiddleMarkers;\n        },\n\n        fireAndForward: function fireAndForward(type, e) {\n            e = e || {};\n            e.layer = this.feature;\n            this.feature.fire(type, e);\n            this.tools.fireAndForward(type, e);\n        },\n\n        onEnable: function onEnable() {\n            // 🍂namespace Editable\n            // 🍂event editable:enable: Event\n            // Fired when an existing feature is ready to be edited.\n            this.fireAndForward('editable:enable');\n        },\n\n        onDisable: function onDisable() {\n            // 🍂namespace Editable\n            // 🍂event editable:disable: Event\n            // Fired when an existing feature is not ready anymore to be edited.\n            this.fireAndForward('editable:disable');\n        },\n\n        onEditing: function onEditing() {\n            // 🍂namespace Editable\n            // 🍂event editable:editing: Event\n            // Fired as soon as any change is made to the feature geometry.\n            this.fireAndForward('editable:editing');\n        },\n\n        onStartDrawing: function onStartDrawing() {\n            // 🍂namespace Editable\n            // 🍂section Drawing events\n            // 🍂event editable:drawing:start: Event\n            // Fired when a feature is to be drawn.\n            this.fireAndForward('editable:drawing:start');\n        },\n\n        onEndDrawing: function onEndDrawing() {\n            // 🍂namespace Editable\n            // 🍂section Drawing events\n            // 🍂event editable:drawing:end: Event\n            // Fired when a feature is not drawn anymore.\n            this.fireAndForward('editable:drawing:end');\n        },\n\n        onCancelDrawing: function onCancelDrawing() {\n            // 🍂namespace Editable\n            // 🍂section Drawing events\n            // 🍂event editable:drawing:cancel: Event\n            // Fired when user cancel drawing while a feature is being drawn.\n            this.fireAndForward('editable:drawing:cancel');\n        },\n\n        onCommitDrawing: function onCommitDrawing(e) {\n            // 🍂namespace Editable\n            // 🍂section Drawing events\n            // 🍂event editable:drawing:commit: Event\n            // Fired when user finish drawing a feature.\n            this.fireAndForward('editable:drawing:commit', e);\n        },\n\n        onDrawingMouseDown: function onDrawingMouseDown(e) {\n            // 🍂namespace Editable\n            // 🍂section Drawing events\n            // 🍂event editable:drawing:mousedown: Event\n            // Fired when user `mousedown` while drawing.\n            this.fireAndForward('editable:drawing:mousedown', e);\n        },\n\n        onDrawingMouseUp: function onDrawingMouseUp(e) {\n            // 🍂namespace Editable\n            // 🍂section Drawing events\n            // 🍂event editable:drawing:mouseup: Event\n            // Fired when user `mouseup` while drawing.\n            this.fireAndForward('editable:drawing:mouseup', e);\n        },\n\n        startDrawing: function startDrawing() {\n            if (!this._drawing) this._drawing = L.Editable.FORWARD;\n            this.tools.registerForDrawing(this);\n            this.onStartDrawing();\n        },\n\n        commitDrawing: function commitDrawing(e) {\n            this.onCommitDrawing(e);\n            this.endDrawing();\n        },\n\n        cancelDrawing: function cancelDrawing() {\n            // If called during a vertex drag, the vertex will be removed before\n            // the mouseup fires on it. This is a workaround. Maybe better fix is\n            // To have L.Draggable reset it's status on disable (Leaflet side).\n            L.Draggable._dragging = false;\n            this.onCancelDrawing();\n            this.endDrawing();\n        },\n\n        endDrawing: function endDrawing() {\n            this._drawing = false;\n            this.tools.unregisterForDrawing(this);\n            this.onEndDrawing();\n        },\n\n        onDrawingClick: function onDrawingClick(e) {\n            if (!this.drawing()) return;\n            L.Editable.makeCancellable(e);\n            // 🍂namespace Editable\n            // 🍂section Drawing events\n            // 🍂event editable:drawing:click: CancelableEvent\n            // Fired when user `click` while drawing, before any internal action is being processed.\n            this.fireAndForward('editable:drawing:click', e);\n            if (e._cancelled) return;\n            if (!this.isConnected()) this.connect(e);\n            this.processDrawingClick(e);\n        },\n\n        isConnected: function isConnected() {\n            return this.map.hasLayer(this.feature);\n        },\n\n        connect: function connect() {\n            this.tools.connectCreatedToMap(this.feature);\n            this.tools.editLayer.addLayer(this.editLayer);\n        },\n\n        onMove: function onMove(e) {\n            // 🍂namespace Editable\n            // 🍂section Drawing events\n            // 🍂event editable:drawing:move: Event\n            // Fired when `move` mouse while drawing, while dragging a marker, and while dragging a vertex.\n            this.fireAndForward('editable:drawing:move', e);\n        },\n\n        onDrawingMouseMove: function onDrawingMouseMove(e) {\n            this.onMove(e);\n        },\n\n        _getEvents: function _getEvents() {\n            return {\n                dragstart: this.onDragStart,\n                drag: this.onDrag,\n                dragend: this.onDragEnd,\n                remove: this.disable\n            };\n        },\n\n        onDragStart: function onDragStart(e) {\n            this.onEditing();\n            // 🍂namespace Editable\n            // 🍂event editable:dragstart: Event\n            // Fired before a path feature is dragged.\n            this.fireAndForward('editable:dragstart', e);\n        },\n\n        onDrag: function onDrag(e) {\n            this.onMove(e);\n            // 🍂namespace Editable\n            // 🍂event editable:drag: Event\n            // Fired when a path feature is being dragged.\n            this.fireAndForward('editable:drag', e);\n        },\n\n        onDragEnd: function onDragEnd(e) {\n            // 🍂namespace Editable\n            // 🍂event editable:dragend: Event\n            // Fired after a path feature has been dragged.\n            this.fireAndForward('editable:dragend', e);\n        }\n\n    });\n\n    // 🍂namespace Editable; 🍂class MarkerEditor; 🍂aka L.Editable.MarkerEditor\n    // 🍂inherits BaseEditor\n    // Editor for Marker.\n    L.Editable.MarkerEditor = L.Editable.BaseEditor.extend({\n\n        onDrawingMouseMove: function onDrawingMouseMove(e) {\n            L.Editable.BaseEditor.prototype.onDrawingMouseMove.call(this, e);\n            if (this._drawing) this.feature.setLatLng(e.latlng);\n        },\n\n        processDrawingClick: function processDrawingClick(e) {\n            // 🍂namespace Editable\n            // 🍂section Drawing events\n            // 🍂event editable:drawing:clicked: Event\n            // Fired when user `click` while drawing, after all internal actions.\n            this.fireAndForward('editable:drawing:clicked', e);\n            this.commitDrawing(e);\n        },\n\n        connect: function connect(e) {\n            // On touch, the latlng has not been updated because there is\n            // no mousemove.\n            if (e) this.feature._latlng = e.latlng;\n            L.Editable.BaseEditor.prototype.connect.call(this, e);\n        }\n\n    });\n\n    // 🍂namespace Editable; 🍂class PathEditor; 🍂aka L.Editable.PathEditor\n    // 🍂inherits BaseEditor\n    // Base class for all path editors.\n    L.Editable.PathEditor = L.Editable.BaseEditor.extend({\n\n        CLOSED: false,\n        MIN_VERTEX: 2,\n\n        addHooks: function addHooks() {\n            L.Editable.BaseEditor.prototype.addHooks.call(this);\n            if (this.feature) this.initVertexMarkers();\n            return this;\n        },\n\n        initVertexMarkers: function initVertexMarkers(latlngs) {\n            if (!this.enabled()) return;\n            latlngs = latlngs || this.getLatLngs();\n            if (isFlat(latlngs)) this.addVertexMarkers(latlngs);else for (var i = 0; i < latlngs.length; i++) {\n                this.initVertexMarkers(latlngs[i]);\n            }\n        },\n\n        getLatLngs: function getLatLngs() {\n            return this.feature.getLatLngs();\n        },\n\n        // 🍂method reset()\n        // Rebuild edit elements (Vertex, MiddleMarker, etc.).\n        reset: function reset() {\n            this.editLayer.clearLayers();\n            this.initVertexMarkers();\n        },\n\n        addVertexMarker: function addVertexMarker(latlng, latlngs) {\n            return new this.tools.options.vertexMarkerClass(latlng, latlngs, this);\n        },\n\n        onNewVertex: function onNewVertex(vertex) {\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:new: VertexEvent\n            // Fired when a new vertex is created.\n            this.fireAndForward('editable:vertex:new', { latlng: vertex.latlng, vertex: vertex });\n        },\n\n        addVertexMarkers: function addVertexMarkers(latlngs) {\n            for (var i = 0; i < latlngs.length; i++) {\n                this.addVertexMarker(latlngs[i], latlngs);\n            }\n        },\n\n        refreshVertexMarkers: function refreshVertexMarkers(latlngs) {\n            latlngs = latlngs || this.getDefaultLatLngs();\n            for (var i = 0; i < latlngs.length; i++) {\n                latlngs[i].__vertex.update();\n            }\n        },\n\n        addMiddleMarker: function addMiddleMarker(left, right, latlngs) {\n            return new this.tools.options.middleMarkerClass(left, right, latlngs, this);\n        },\n\n        onVertexMarkerClick: function onVertexMarkerClick(e) {\n            L.Editable.makeCancellable(e);\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:click: CancelableVertexEvent\n            // Fired when a `click` is issued on a vertex, before any internal action is being processed.\n            this.fireAndForward('editable:vertex:click', e);\n            if (e._cancelled) return;\n            if (this.tools.drawing() && this.tools._drawingEditor !== this) return;\n            var index = e.vertex.getIndex(),\n                commit;\n            if (e.originalEvent.ctrlKey) {\n                this.onVertexMarkerCtrlClick(e);\n            } else if (e.originalEvent.altKey) {\n                this.onVertexMarkerAltClick(e);\n            } else if (e.originalEvent.shiftKey) {\n                this.onVertexMarkerShiftClick(e);\n            } else if (e.originalEvent.metaKey) {\n                this.onVertexMarkerMetaKeyClick(e);\n            } else if (index === e.vertex.getLastIndex() && this._drawing === L.Editable.FORWARD) {\n                if (index >= this.MIN_VERTEX - 1) commit = true;\n            } else if (index === 0 && this._drawing === L.Editable.BACKWARD && this._drawnLatLngs.length >= this.MIN_VERTEX) {\n                commit = true;\n            } else if (index === 0 && this._drawing === L.Editable.FORWARD && this._drawnLatLngs.length >= this.MIN_VERTEX && this.CLOSED) {\n                commit = true; // Allow to close on first point also for polygons\n            } else {\n                this.onVertexRawMarkerClick(e);\n            }\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:clicked: VertexEvent\n            // Fired when a `click` is issued on a vertex, after all internal actions.\n            this.fireAndForward('editable:vertex:clicked', e);\n            if (commit) this.commitDrawing(e);\n        },\n\n        onVertexRawMarkerClick: function onVertexRawMarkerClick(e) {\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:rawclick: CancelableVertexEvent\n            // Fired when a `click` is issued on a vertex without any special key and without being in drawing mode.\n            this.fireAndForward('editable:vertex:rawclick', e);\n            if (e._cancelled) return;\n            if (!this.vertexCanBeDeleted(e.vertex)) return;\n            e.vertex.delete();\n        },\n\n        vertexCanBeDeleted: function vertexCanBeDeleted(vertex) {\n            return vertex.latlngs.length > this.MIN_VERTEX;\n        },\n\n        onVertexDeleted: function onVertexDeleted(e) {\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:deleted: VertexEvent\n            // Fired after a vertex has been deleted by user.\n            this.fireAndForward('editable:vertex:deleted', e);\n        },\n\n        onVertexMarkerCtrlClick: function onVertexMarkerCtrlClick(e) {\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:ctrlclick: VertexEvent\n            // Fired when a `click` with `ctrlKey` is issued on a vertex.\n            this.fireAndForward('editable:vertex:ctrlclick', e);\n        },\n\n        onVertexMarkerShiftClick: function onVertexMarkerShiftClick(e) {\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:shiftclick: VertexEvent\n            // Fired when a `click` with `shiftKey` is issued on a vertex.\n            this.fireAndForward('editable:vertex:shiftclick', e);\n        },\n\n        onVertexMarkerMetaKeyClick: function onVertexMarkerMetaKeyClick(e) {\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:metakeyclick: VertexEvent\n            // Fired when a `click` with `metaKey` is issued on a vertex.\n            this.fireAndForward('editable:vertex:metakeyclick', e);\n        },\n\n        onVertexMarkerAltClick: function onVertexMarkerAltClick(e) {\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:altclick: VertexEvent\n            // Fired when a `click` with `altKey` is issued on a vertex.\n            this.fireAndForward('editable:vertex:altclick', e);\n        },\n\n        onVertexMarkerContextMenu: function onVertexMarkerContextMenu(e) {\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:contextmenu: VertexEvent\n            // Fired when a `contextmenu` is issued on a vertex.\n            this.fireAndForward('editable:vertex:contextmenu', e);\n        },\n\n        onVertexMarkerMouseDown: function onVertexMarkerMouseDown(e) {\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:mousedown: VertexEvent\n            // Fired when user `mousedown` a vertex.\n            this.fireAndForward('editable:vertex:mousedown', e);\n        },\n\n        onVertexMarkerMouseOver: function onVertexMarkerMouseOver(e) {\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:mouseover: VertexEvent\n            // Fired when a user's mouse enters the vertex\n            this.fireAndForward('editable:vertex:mouseover', e);\n        },\n\n        onVertexMarkerMouseOut: function onVertexMarkerMouseOut(e) {\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:mouseout: VertexEvent\n            // Fired when a user's mouse leaves the vertex\n            this.fireAndForward('editable:vertex:mouseout', e);\n        },\n\n        onMiddleMarkerMouseDown: function onMiddleMarkerMouseDown(e) {\n            // 🍂namespace Editable\n            // 🍂section MiddleMarker events\n            // 🍂event editable:middlemarker:mousedown: VertexEvent\n            // Fired when user `mousedown` a middle marker.\n            this.fireAndForward('editable:middlemarker:mousedown', e);\n        },\n\n        onVertexMarkerDrag: function onVertexMarkerDrag(e) {\n            this.onMove(e);\n            if (this.feature._bounds) this.extendBounds(e);\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:drag: VertexEvent\n            // Fired when a vertex is dragged by user.\n            this.fireAndForward('editable:vertex:drag', e);\n        },\n\n        onVertexMarkerDragStart: function onVertexMarkerDragStart(e) {\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:dragstart: VertexEvent\n            // Fired before a vertex is dragged by user.\n            this.fireAndForward('editable:vertex:dragstart', e);\n        },\n\n        onVertexMarkerDragEnd: function onVertexMarkerDragEnd(e) {\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:dragend: VertexEvent\n            // Fired after a vertex is dragged by user.\n            this.fireAndForward('editable:vertex:dragend', e);\n        },\n\n        setDrawnLatLngs: function setDrawnLatLngs(latlngs) {\n            this._drawnLatLngs = latlngs || this.getDefaultLatLngs();\n        },\n\n        startDrawing: function startDrawing() {\n            if (!this._drawnLatLngs) this.setDrawnLatLngs();\n            L.Editable.BaseEditor.prototype.startDrawing.call(this);\n        },\n\n        startDrawingForward: function startDrawingForward() {\n            this.startDrawing();\n        },\n\n        endDrawing: function endDrawing() {\n            this.tools.detachForwardLineGuide();\n            this.tools.detachBackwardLineGuide();\n            if (this._drawnLatLngs && this._drawnLatLngs.length < this.MIN_VERTEX) this.deleteShape(this._drawnLatLngs);\n            L.Editable.BaseEditor.prototype.endDrawing.call(this);\n            delete this._drawnLatLngs;\n        },\n\n        addLatLng: function addLatLng(latlng) {\n            if (this._drawing === L.Editable.FORWARD) this._drawnLatLngs.push(latlng);else this._drawnLatLngs.unshift(latlng);\n            this.feature._bounds.extend(latlng);\n            var vertex = this.addVertexMarker(latlng, this._drawnLatLngs);\n            this.onNewVertex(vertex);\n            this.refresh();\n        },\n\n        newPointForward: function newPointForward(latlng) {\n            this.addLatLng(latlng);\n            this.tools.attachForwardLineGuide();\n            this.tools.anchorForwardLineGuide(latlng);\n        },\n\n        newPointBackward: function newPointBackward(latlng) {\n            this.addLatLng(latlng);\n            this.tools.anchorBackwardLineGuide(latlng);\n        },\n\n        // 🍂namespace PathEditor\n        // 🍂method push()\n        // Programmatically add a point while drawing.\n        push: function push(latlng) {\n            if (!latlng) return console.error('L.Editable.PathEditor.push expect a valid latlng as parameter');\n            if (this._drawing === L.Editable.FORWARD) this.newPointForward(latlng);else this.newPointBackward(latlng);\n        },\n\n        removeLatLng: function removeLatLng(latlng) {\n            latlng.__vertex.delete();\n            this.refresh();\n        },\n\n        // 🍂method pop(): L.LatLng or null\n        // Programmatically remove last point (if any) while drawing.\n        pop: function pop() {\n            if (this._drawnLatLngs.length <= 1) return;\n            var latlng;\n            if (this._drawing === L.Editable.FORWARD) latlng = this._drawnLatLngs[this._drawnLatLngs.length - 1];else latlng = this._drawnLatLngs[0];\n            this.removeLatLng(latlng);\n            if (this._drawing === L.Editable.FORWARD) this.tools.anchorForwardLineGuide(this._drawnLatLngs[this._drawnLatLngs.length - 1]);else this.tools.anchorForwardLineGuide(this._drawnLatLngs[0]);\n            return latlng;\n        },\n\n        processDrawingClick: function processDrawingClick(e) {\n            if (e.vertex && e.vertex.editor === this) return;\n            if (this._drawing === L.Editable.FORWARD) this.newPointForward(e.latlng);else this.newPointBackward(e.latlng);\n            this.fireAndForward('editable:drawing:clicked', e);\n        },\n\n        onDrawingMouseMove: function onDrawingMouseMove(e) {\n            L.Editable.BaseEditor.prototype.onDrawingMouseMove.call(this, e);\n            if (this._drawing) {\n                this.tools.moveForwardLineGuide(e.latlng);\n                this.tools.moveBackwardLineGuide(e.latlng);\n            }\n        },\n\n        refresh: function refresh() {\n            this.feature.redraw();\n            this.onEditing();\n        },\n\n        // 🍂namespace PathEditor\n        // 🍂method newShape(latlng?: L.LatLng)\n        // Add a new shape (Polyline, Polygon) in a multi, and setup up drawing tools to draw it;\n        // if optional `latlng` is given, start a path at this point.\n        newShape: function newShape(latlng) {\n            var shape = this.addNewEmptyShape();\n            if (!shape) return;\n            this.setDrawnLatLngs(shape[0] || shape); // Polygon or polyline\n            this.startDrawingForward();\n            // 🍂namespace Editable\n            // 🍂section Shape events\n            // 🍂event editable:shape:new: ShapeEvent\n            // Fired when a new shape is created in a multi (Polygon or Polyline).\n            this.fireAndForward('editable:shape:new', { shape: shape });\n            if (latlng) this.newPointForward(latlng);\n        },\n\n        deleteShape: function deleteShape(shape, latlngs) {\n            var e = { shape: shape };\n            L.Editable.makeCancellable(e);\n            // 🍂namespace Editable\n            // 🍂section Shape events\n            // 🍂event editable:shape:delete: CancelableShapeEvent\n            // Fired before a new shape is deleted in a multi (Polygon or Polyline).\n            this.fireAndForward('editable:shape:delete', e);\n            if (e._cancelled) return;\n            shape = this._deleteShape(shape, latlngs);\n            if (this.ensureNotFlat) this.ensureNotFlat(); // Polygon.\n            this.feature.setLatLngs(this.getLatLngs()); // Force bounds reset.\n            this.refresh();\n            this.reset();\n            // 🍂namespace Editable\n            // 🍂section Shape events\n            // 🍂event editable:shape:deleted: ShapeEvent\n            // Fired after a new shape is deleted in a multi (Polygon or Polyline).\n            this.fireAndForward('editable:shape:deleted', { shape: shape });\n            return shape;\n        },\n\n        _deleteShape: function _deleteShape(shape, latlngs) {\n            latlngs = latlngs || this.getLatLngs();\n            if (!latlngs.length) return;\n            var self = this,\n                inplaceDelete = function inplaceDelete(latlngs, shape) {\n                // Called when deleting a flat latlngs\n                shape = latlngs.splice(0, Number.MAX_VALUE);\n                return shape;\n            },\n                spliceDelete = function spliceDelete(latlngs, shape) {\n                // Called when removing a latlngs inside an array\n                latlngs.splice(latlngs.indexOf(shape), 1);\n                if (!latlngs.length) self._deleteShape(latlngs);\n                return shape;\n            };\n            if (latlngs === shape) return inplaceDelete(latlngs, shape);\n            for (var i = 0; i < latlngs.length; i++) {\n                if (latlngs[i] === shape) return spliceDelete(latlngs, shape);else if (latlngs[i].indexOf(shape) !== -1) return spliceDelete(latlngs[i], shape);\n            }\n        },\n\n        // 🍂namespace PathEditor\n        // 🍂method deleteShapeAt(latlng: L.LatLng): Array\n        // Remove a path shape at the given `latlng`.\n        deleteShapeAt: function deleteShapeAt(latlng) {\n            var shape = this.feature.shapeAt(latlng);\n            if (shape) return this.deleteShape(shape);\n        },\n\n        // 🍂method appendShape(shape: Array)\n        // Append a new shape to the Polygon or Polyline.\n        appendShape: function appendShape(shape) {\n            this.insertShape(shape);\n        },\n\n        // 🍂method prependShape(shape: Array)\n        // Prepend a new shape to the Polygon or Polyline.\n        prependShape: function prependShape(shape) {\n            this.insertShape(shape, 0);\n        },\n\n        // 🍂method insertShape(shape: Array, index: int)\n        // Insert a new shape to the Polygon or Polyline at given index (default is to append).\n        insertShape: function insertShape(shape, index) {\n            this.ensureMulti();\n            shape = this.formatShape(shape);\n            if (typeof index === 'undefined') index = this.feature._latlngs.length;\n            this.feature._latlngs.splice(index, 0, shape);\n            this.feature.redraw();\n            if (this._enabled) this.reset();\n        },\n\n        extendBounds: function extendBounds(e) {\n            this.feature._bounds.extend(e.vertex.latlng);\n        },\n\n        onDragStart: function onDragStart(e) {\n            this.editLayer.clearLayers();\n            L.Editable.BaseEditor.prototype.onDragStart.call(this, e);\n        },\n\n        onDragEnd: function onDragEnd(e) {\n            this.initVertexMarkers();\n            L.Editable.BaseEditor.prototype.onDragEnd.call(this, e);\n        }\n\n    });\n\n    // 🍂namespace Editable; 🍂class PolylineEditor; 🍂aka L.Editable.PolylineEditor\n    // 🍂inherits PathEditor\n    L.Editable.PolylineEditor = L.Editable.PathEditor.extend({\n\n        startDrawingBackward: function startDrawingBackward() {\n            this._drawing = L.Editable.BACKWARD;\n            this.startDrawing();\n        },\n\n        // 🍂method continueBackward(latlngs?: Array)\n        // Set up drawing tools to continue the line backward.\n        continueBackward: function continueBackward(latlngs) {\n            if (this.drawing()) return;\n            latlngs = latlngs || this.getDefaultLatLngs();\n            this.setDrawnLatLngs(latlngs);\n            if (latlngs.length > 0) {\n                this.tools.attachBackwardLineGuide();\n                this.tools.anchorBackwardLineGuide(latlngs[0]);\n            }\n            this.startDrawingBackward();\n        },\n\n        // 🍂method continueForward(latlngs?: Array)\n        // Set up drawing tools to continue the line forward.\n        continueForward: function continueForward(latlngs) {\n            if (this.drawing()) return;\n            latlngs = latlngs || this.getDefaultLatLngs();\n            this.setDrawnLatLngs(latlngs);\n            if (latlngs.length > 0) {\n                this.tools.attachForwardLineGuide();\n                this.tools.anchorForwardLineGuide(latlngs[latlngs.length - 1]);\n            }\n            this.startDrawingForward();\n        },\n\n        getDefaultLatLngs: function getDefaultLatLngs(latlngs) {\n            latlngs = latlngs || this.feature._latlngs;\n            if (!latlngs.length || latlngs[0] instanceof L.LatLng) return latlngs;else return this.getDefaultLatLngs(latlngs[0]);\n        },\n\n        ensureMulti: function ensureMulti() {\n            if (this.feature._latlngs.length && isFlat(this.feature._latlngs)) {\n                this.feature._latlngs = [this.feature._latlngs];\n            }\n        },\n\n        addNewEmptyShape: function addNewEmptyShape() {\n            if (this.feature._latlngs.length) {\n                var shape = [];\n                this.appendShape(shape);\n                return shape;\n            } else {\n                return this.feature._latlngs;\n            }\n        },\n\n        formatShape: function formatShape(shape) {\n            if (isFlat(shape)) return shape;else if (shape[0]) return this.formatShape(shape[0]);\n        },\n\n        // 🍂method splitShape(latlngs?: Array, index: int)\n        // Split the given `latlngs` shape at index `index` and integrate new shape in instance `latlngs`.\n        splitShape: function splitShape(shape, index) {\n            if (!index || index >= shape.length - 1) return;\n            this.ensureMulti();\n            var shapeIndex = this.feature._latlngs.indexOf(shape);\n            if (shapeIndex === -1) return;\n            var first = shape.slice(0, index + 1),\n                second = shape.slice(index);\n            // We deal with reference, we don't want twice the same latlng around.\n            second[0] = L.latLng(second[0].lat, second[0].lng, second[0].alt);\n            this.feature._latlngs.splice(shapeIndex, 1, first, second);\n            this.refresh();\n            this.reset();\n        }\n\n    });\n\n    // 🍂namespace Editable; 🍂class PolygonEditor; 🍂aka L.Editable.PolygonEditor\n    // 🍂inherits PathEditor\n    L.Editable.PolygonEditor = L.Editable.PathEditor.extend({\n\n        CLOSED: true,\n        MIN_VERTEX: 3,\n\n        newPointForward: function newPointForward(latlng) {\n            L.Editable.PathEditor.prototype.newPointForward.call(this, latlng);\n            if (!this.tools.backwardLineGuide._latlngs.length) this.tools.anchorBackwardLineGuide(latlng);\n            if (this._drawnLatLngs.length === 2) this.tools.attachBackwardLineGuide();\n        },\n\n        addNewEmptyHole: function addNewEmptyHole(latlng) {\n            this.ensureNotFlat();\n            var latlngs = this.feature.shapeAt(latlng);\n            if (!latlngs) return;\n            var holes = [];\n            latlngs.push(holes);\n            return holes;\n        },\n\n        // 🍂method newHole(latlng?: L.LatLng, index: int)\n        // Set up drawing tools for creating a new hole on the Polygon. If the `latlng` param is given, a first point is created.\n        newHole: function newHole(latlng) {\n            var holes = this.addNewEmptyHole(latlng);\n            if (!holes) return;\n            this.setDrawnLatLngs(holes);\n            this.startDrawingForward();\n            if (latlng) this.newPointForward(latlng);\n        },\n\n        addNewEmptyShape: function addNewEmptyShape() {\n            if (this.feature._latlngs.length && this.feature._latlngs[0].length) {\n                var shape = [];\n                this.appendShape(shape);\n                return shape;\n            } else {\n                return this.feature._latlngs;\n            }\n        },\n\n        ensureMulti: function ensureMulti() {\n            if (this.feature._latlngs.length && isFlat(this.feature._latlngs[0])) {\n                this.feature._latlngs = [this.feature._latlngs];\n            }\n        },\n\n        ensureNotFlat: function ensureNotFlat() {\n            if (!this.feature._latlngs.length || isFlat(this.feature._latlngs)) this.feature._latlngs = [this.feature._latlngs];\n        },\n\n        vertexCanBeDeleted: function vertexCanBeDeleted(vertex) {\n            var parent = this.feature.parentShape(vertex.latlngs),\n                idx = L.Util.indexOf(parent, vertex.latlngs);\n            if (idx > 0) return true; // Holes can be totally deleted without removing the layer itself.\n            return L.Editable.PathEditor.prototype.vertexCanBeDeleted.call(this, vertex);\n        },\n\n        getDefaultLatLngs: function getDefaultLatLngs() {\n            if (!this.feature._latlngs.length) this.feature._latlngs.push([]);\n            return this.feature._latlngs[0];\n        },\n\n        formatShape: function formatShape(shape) {\n            // [[1, 2], [3, 4]] => must be nested\n            // [] => must be nested\n            // [[]] => is already nested\n            if (isFlat(shape) && (!shape[0] || shape[0].length !== 0)) return [shape];else return shape;\n        }\n\n    });\n\n    // 🍂namespace Editable; 🍂class RectangleEditor; 🍂aka L.Editable.RectangleEditor\n    // 🍂inherits PathEditor\n    L.Editable.RectangleEditor = L.Editable.PathEditor.extend({\n\n        CLOSED: true,\n        MIN_VERTEX: 4,\n\n        options: {\n            skipMiddleMarkers: true\n        },\n\n        extendBounds: function extendBounds(e) {\n            var index = e.vertex.getIndex(),\n                next = e.vertex.getNext(),\n                previous = e.vertex.getPrevious(),\n                oppositeIndex = (index + 2) % 4,\n                opposite = e.vertex.latlngs[oppositeIndex],\n                bounds = new L.LatLngBounds(e.latlng, opposite);\n            // Update latlngs by hand to preserve order.\n            previous.latlng.update([e.latlng.lat, opposite.lng]);\n            next.latlng.update([opposite.lat, e.latlng.lng]);\n            this.updateBounds(bounds);\n            this.refreshVertexMarkers();\n        },\n\n        onDrawingMouseDown: function onDrawingMouseDown(e) {\n            L.Editable.PathEditor.prototype.onDrawingMouseDown.call(this, e);\n            this.connect();\n            var latlngs = this.getDefaultLatLngs();\n            // L.Polygon._convertLatLngs removes last latlng if it equals first point,\n            // which is the case here as all latlngs are [0, 0]\n            if (latlngs.length === 3) latlngs.push(e.latlng);\n            var bounds = new L.LatLngBounds(e.latlng, e.latlng);\n            this.updateBounds(bounds);\n            this.updateLatLngs(bounds);\n            this.refresh();\n            this.reset();\n            // Stop dragging map.\n            // L.Draggable has two workflows:\n            // - mousedown => mousemove => mouseup\n            // - touchstart => touchmove => touchend\n            // Problem: L.Map.Tap does not allow us to listen to touchstart, so we only\n            // can deal with mousedown, but then when in a touch device, we are dealing with\n            // simulated events (actually simulated by L.Map.Tap), which are no more taken\n            // into account by L.Draggable.\n            // Ref.: https://github.com/Leaflet/Leaflet.Editable/issues/103\n            e.originalEvent._simulated = false;\n            this.map.dragging._draggable._onUp(e.originalEvent);\n            // Now transfer ongoing drag action to the bottom right corner.\n            // Should we refine which corner will handle the drag according to\n            // drag direction?\n            latlngs[3].__vertex.dragging._draggable._onDown(e.originalEvent);\n        },\n\n        onDrawingMouseUp: function onDrawingMouseUp(e) {\n            this.commitDrawing(e);\n            e.originalEvent._simulated = false;\n            L.Editable.PathEditor.prototype.onDrawingMouseUp.call(this, e);\n        },\n\n        onDrawingMouseMove: function onDrawingMouseMove(e) {\n            e.originalEvent._simulated = false;\n            L.Editable.PathEditor.prototype.onDrawingMouseMove.call(this, e);\n        },\n\n        getDefaultLatLngs: function getDefaultLatLngs(latlngs) {\n            return latlngs || this.feature._latlngs[0];\n        },\n\n        updateBounds: function updateBounds(bounds) {\n            this.feature._bounds = bounds;\n        },\n\n        updateLatLngs: function updateLatLngs(bounds) {\n            var latlngs = this.getDefaultLatLngs(),\n                newLatlngs = this.feature._boundsToLatLngs(bounds);\n            // Keep references.\n            for (var i = 0; i < latlngs.length; i++) {\n                latlngs[i].update(newLatlngs[i]);\n            }\n        }\n\n    });\n\n    // 🍂namespace Editable; 🍂class CircleEditor; 🍂aka L.Editable.CircleEditor\n    // 🍂inherits PathEditor\n    L.Editable.CircleEditor = L.Editable.PathEditor.extend({\n\n        MIN_VERTEX: 2,\n\n        options: {\n            skipMiddleMarkers: true\n        },\n\n        initialize: function initialize(map, feature, options) {\n            L.Editable.PathEditor.prototype.initialize.call(this, map, feature, options);\n            this._resizeLatLng = this.computeResizeLatLng();\n        },\n\n        computeResizeLatLng: function computeResizeLatLng() {\n            // While circle is not added to the map, _radius is not set.\n            var delta = (this.feature._radius || this.feature._mRadius) * Math.cos(Math.PI / 4),\n                point = this.map.project(this.feature._latlng);\n            return this.map.unproject([point.x + delta, point.y - delta]);\n        },\n\n        updateResizeLatLng: function updateResizeLatLng() {\n            this._resizeLatLng.update(this.computeResizeLatLng());\n            this._resizeLatLng.__vertex.update();\n        },\n\n        getLatLngs: function getLatLngs() {\n            return [this.feature._latlng, this._resizeLatLng];\n        },\n\n        getDefaultLatLngs: function getDefaultLatLngs() {\n            return this.getLatLngs();\n        },\n\n        onVertexMarkerDrag: function onVertexMarkerDrag(e) {\n            if (e.vertex.getIndex() === 1) this.resize(e);else this.updateResizeLatLng(e);\n            L.Editable.PathEditor.prototype.onVertexMarkerDrag.call(this, e);\n        },\n\n        resize: function resize(e) {\n            var radius = this.feature._latlng.distanceTo(e.latlng);\n            this.feature.setRadius(radius);\n        },\n\n        onDrawingMouseDown: function onDrawingMouseDown(e) {\n            L.Editable.PathEditor.prototype.onDrawingMouseDown.call(this, e);\n            this._resizeLatLng.update(e.latlng);\n            this.feature._latlng.update(e.latlng);\n            this.connect();\n            // Stop dragging map.\n            e.originalEvent._simulated = false;\n            this.map.dragging._draggable._onUp(e.originalEvent);\n            // Now transfer ongoing drag action to the radius handler.\n            this._resizeLatLng.__vertex.dragging._draggable._onDown(e.originalEvent);\n        },\n\n        onDrawingMouseUp: function onDrawingMouseUp(e) {\n            this.commitDrawing(e);\n            e.originalEvent._simulated = false;\n            L.Editable.PathEditor.prototype.onDrawingMouseUp.call(this, e);\n        },\n\n        onDrawingMouseMove: function onDrawingMouseMove(e) {\n            e.originalEvent._simulated = false;\n            L.Editable.PathEditor.prototype.onDrawingMouseMove.call(this, e);\n        },\n\n        onDrag: function onDrag(e) {\n            L.Editable.PathEditor.prototype.onDrag.call(this, e);\n            this.feature.dragging.updateLatLng(this._resizeLatLng);\n        }\n\n    });\n\n    // 🍂namespace Editable; 🍂class EditableMixin\n    // `EditableMixin` is included to `L.Polyline`, `L.Polygon`, `L.Rectangle`, `L.Circle`\n    // and `L.Marker`. It adds some methods to them.\n    // *When editing is enabled, the editor is accessible on the instance with the\n    // `editor` property.*\n    var EditableMixin = {\n\n        createEditor: function createEditor(map) {\n            map = map || this._map;\n            var tools = (this.options.editOptions || {}).editTools || map.editTools;\n            if (!tools) throw Error('Unable to detect Editable instance.');\n            var Klass = this.options.editorClass || this.getEditorClass(tools);\n            return new Klass(map, this, this.options.editOptions);\n        },\n\n        // 🍂method enableEdit(map?: L.Map): this.editor\n        // Enable editing, by creating an editor if not existing, and then calling `enable` on it.\n        enableEdit: function enableEdit(map) {\n            if (!this.editor) this.createEditor(map);\n            this.editor.enable();\n            return this.editor;\n        },\n\n        // 🍂method editEnabled(): boolean\n        // Return true if current instance has an editor attached, and this editor is enabled.\n        editEnabled: function editEnabled() {\n            return this.editor && this.editor.enabled();\n        },\n\n        // 🍂method disableEdit()\n        // Disable editing, also remove the editor property reference.\n        disableEdit: function disableEdit() {\n            if (this.editor) {\n                this.editor.disable();\n                delete this.editor;\n            }\n        },\n\n        // 🍂method toggleEdit()\n        // Enable or disable editing, according to current status.\n        toggleEdit: function toggleEdit() {\n            if (this.editEnabled()) this.disableEdit();else this.enableEdit();\n        },\n\n        _onEditableAdd: function _onEditableAdd() {\n            if (this.editor) this.enableEdit();\n        }\n\n    };\n\n    var PolylineMixin = {\n\n        getEditorClass: function getEditorClass(tools) {\n            return tools && tools.options.polylineEditorClass ? tools.options.polylineEditorClass : L.Editable.PolylineEditor;\n        },\n\n        shapeAt: function shapeAt(latlng, latlngs) {\n            // We can have those cases:\n            // - latlngs are just a flat array of latlngs, use this\n            // - latlngs is an array of arrays of latlngs, loop over\n            var shape = null;\n            latlngs = latlngs || this._latlngs;\n            if (!latlngs.length) return shape;else if (isFlat(latlngs) && this.isInLatLngs(latlng, latlngs)) shape = latlngs;else for (var i = 0; i < latlngs.length; i++) {\n                if (this.isInLatLngs(latlng, latlngs[i])) return latlngs[i];\n            }return shape;\n        },\n\n        isInLatLngs: function isInLatLngs(l, latlngs) {\n            if (!latlngs) return false;\n            var i,\n                k,\n                len,\n                part = [],\n                p,\n                w = this._clickTolerance();\n            this._projectLatlngs(latlngs, part, this._pxBounds);\n            part = part[0];\n            p = this._map.latLngToLayerPoint(l);\n\n            if (!this._pxBounds.contains(p)) {\n                return false;\n            }\n            for (i = 1, len = part.length, k = 0; i < len; k = i++) {\n\n                if (L.LineUtil.pointToSegmentDistance(p, part[k], part[i]) <= w) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n    };\n\n    var PolygonMixin = {\n\n        getEditorClass: function getEditorClass(tools) {\n            return tools && tools.options.polygonEditorClass ? tools.options.polygonEditorClass : L.Editable.PolygonEditor;\n        },\n\n        shapeAt: function shapeAt(latlng, latlngs) {\n            // We can have those cases:\n            // - latlngs are just a flat array of latlngs, use this\n            // - latlngs is an array of arrays of latlngs, this is a simple polygon (maybe with holes), use the first\n            // - latlngs is an array of arrays of arrays, this is a multi, loop over\n            var shape = null;\n            latlngs = latlngs || this._latlngs;\n            if (!latlngs.length) return shape;else if (isFlat(latlngs) && this.isInLatLngs(latlng, latlngs)) shape = latlngs;else if (isFlat(latlngs[0]) && this.isInLatLngs(latlng, latlngs[0])) shape = latlngs;else for (var i = 0; i < latlngs.length; i++) {\n                if (this.isInLatLngs(latlng, latlngs[i][0])) return latlngs[i];\n            }return shape;\n        },\n\n        isInLatLngs: function isInLatLngs(l, latlngs) {\n            var inside = false,\n                l1,\n                l2,\n                j,\n                k,\n                len2;\n\n            for (j = 0, len2 = latlngs.length, k = len2 - 1; j < len2; k = j++) {\n                l1 = latlngs[j];\n                l2 = latlngs[k];\n\n                if (l1.lat > l.lat !== l2.lat > l.lat && l.lng < (l2.lng - l1.lng) * (l.lat - l1.lat) / (l2.lat - l1.lat) + l1.lng) {\n                    inside = !inside;\n                }\n            }\n\n            return inside;\n        },\n\n        parentShape: function parentShape(shape, latlngs) {\n            latlngs = latlngs || this._latlngs;\n            if (!latlngs) return;\n            var idx = L.Util.indexOf(latlngs, shape);\n            if (idx !== -1) return latlngs;\n            for (var i = 0; i < latlngs.length; i++) {\n                idx = L.Util.indexOf(latlngs[i], shape);\n                if (idx !== -1) return latlngs[i];\n            }\n        }\n\n    };\n\n    var MarkerMixin = {\n\n        getEditorClass: function getEditorClass(tools) {\n            return tools && tools.options.markerEditorClass ? tools.options.markerEditorClass : L.Editable.MarkerEditor;\n        }\n\n    };\n\n    var RectangleMixin = {\n\n        getEditorClass: function getEditorClass(tools) {\n            return tools && tools.options.rectangleEditorClass ? tools.options.rectangleEditorClass : L.Editable.RectangleEditor;\n        }\n\n    };\n\n    var CircleMixin = {\n\n        getEditorClass: function getEditorClass(tools) {\n            return tools && tools.options.circleEditorClass ? tools.options.circleEditorClass : L.Editable.CircleEditor;\n        }\n\n    };\n\n    var keepEditable = function keepEditable() {\n        // Make sure you can remove/readd an editable layer.\n        this.on('add', this._onEditableAdd);\n    };\n\n    var isFlat = L.LineUtil.isFlat || L.LineUtil._flat || L.Polyline._flat; // <=> 1.1 compat.\n\n\n    if (L.Polyline) {\n        L.Polyline.include(EditableMixin);\n        L.Polyline.include(PolylineMixin);\n        L.Polyline.addInitHook(keepEditable);\n    }\n    if (L.Polygon) {\n        L.Polygon.include(EditableMixin);\n        L.Polygon.include(PolygonMixin);\n    }\n    if (L.Marker) {\n        L.Marker.include(EditableMixin);\n        L.Marker.include(MarkerMixin);\n        L.Marker.addInitHook(keepEditable);\n    }\n    if (L.Rectangle) {\n        L.Rectangle.include(EditableMixin);\n        L.Rectangle.include(RectangleMixin);\n    }\n    if (L.Circle) {\n        L.Circle.include(EditableMixin);\n        L.Circle.include(CircleMixin);\n    }\n\n    L.LatLng.prototype.update = function (latlng) {\n        latlng = L.latLng(latlng);\n        this.lat = latlng.lat;\n        this.lng = latlng.lng;\n    };\n}, window);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlZ1ZTJMZWFmbGV0RWRpdGFibGUuanMiXSwibmFtZXMiOlsiZmFjdG9yeSIsIndpbmRvdyIsImRlZmluZSIsImFtZCIsImV4cG9ydHMiLCJtb2R1bGUiLCJyZXF1aXJlIiwiTCIsIkVkaXRhYmxlIiwiRXZlbnRlZCIsImV4dGVuZCIsInN0YXRpY3MiLCJGT1JXQVJEIiwiQkFDS1dBUkQiLCJvcHRpb25zIiwiekluZGV4IiwicG9seWdvbkNsYXNzIiwiUG9seWdvbiIsInBvbHlsaW5lQ2xhc3MiLCJQb2x5bGluZSIsIm1hcmtlckNsYXNzIiwiTWFya2VyIiwicmVjdGFuZ2xlQ2xhc3MiLCJSZWN0YW5nbGUiLCJjaXJjbGVDbGFzcyIsIkNpcmNsZSIsImRyYXdpbmdDU1NDbGFzcyIsImRyYXdpbmdDdXJzb3IiLCJlZGl0TGF5ZXIiLCJ1bmRlZmluZWQiLCJmZWF0dXJlc0xheWVyIiwicG9seWxpbmVFZGl0b3JDbGFzcyIsInBvbHlnb25FZGl0b3JDbGFzcyIsIm1hcmtlckVkaXRvckNsYXNzIiwicmVjdGFuZ2xlRWRpdG9yQ2xhc3MiLCJjaXJjbGVFZGl0b3JDbGFzcyIsImxpbmVHdWlkZU9wdGlvbnMiLCJza2lwTWlkZGxlTWFya2VycyIsImluaXRpYWxpemUiLCJtYXAiLCJzZXRPcHRpb25zIiwiX2xhc3RaSW5kZXgiLCJjcmVhdGVFZGl0TGF5ZXIiLCJjcmVhdGVGZWF0dXJlc0xheWVyIiwiZm9yd2FyZExpbmVHdWlkZSIsImNyZWF0ZUxpbmVHdWlkZSIsImJhY2t3YXJkTGluZUd1aWRlIiwiZmlyZUFuZEZvcndhcmQiLCJ0eXBlIiwiZSIsImVkaXRUb29scyIsImZpcmUiLCJkYXNoQXJyYXkiLCJ3ZWlnaHQiLCJpbnRlcmFjdGl2ZSIsInBvbHlsaW5lIiwiY3JlYXRlVmVydGV4SWNvbiIsIkJyb3dzZXIiLCJtb2JpbGUiLCJ0b3VjaCIsIlRvdWNoVmVydGV4SWNvbiIsIlZlcnRleEljb24iLCJMYXllckdyb3VwIiwiYWRkVG8iLCJtb3ZlRm9yd2FyZExpbmVHdWlkZSIsImxhdGxuZyIsIl9sYXRsbmdzIiwibGVuZ3RoIiwiX2JvdW5kcyIsInJlZHJhdyIsIm1vdmVCYWNrd2FyZExpbmVHdWlkZSIsImFuY2hvckZvcndhcmRMaW5lR3VpZGUiLCJhbmNob3JCYWNrd2FyZExpbmVHdWlkZSIsImF0dGFjaEZvcndhcmRMaW5lR3VpZGUiLCJhZGRMYXllciIsImF0dGFjaEJhY2t3YXJkTGluZUd1aWRlIiwiZGV0YWNoRm9yd2FyZExpbmVHdWlkZSIsInNldExhdExuZ3MiLCJyZW1vdmVMYXllciIsImRldGFjaEJhY2t3YXJkTGluZUd1aWRlIiwiYmxvY2tFdmVudHMiLCJfb2xkVGFyZ2V0cyIsIl90YXJnZXRzIiwidW5ibG9ja0V2ZW50cyIsInJlZ2lzdGVyRm9yRHJhd2luZyIsImVkaXRvciIsIl9kcmF3aW5nRWRpdG9yIiwidW5yZWdpc3RlckZvckRyYXdpbmciLCJyZXNldCIsIm9uIiwib25EcmF3aW5nTW91c2VNb3ZlIiwib25Nb3VzZWRvd24iLCJvbk1vdXNldXAiLCJEb21VdGlsIiwiYWRkQ2xhc3MiLCJfY29udGFpbmVyIiwiZGVmYXVsdE1hcEN1cnNvciIsInN0eWxlIiwiY3Vyc29yIiwicmVtb3ZlQ2xhc3MiLCJvZmYiLCJfZHJhd2luZyIsImNhbmNlbERyYXdpbmciLCJvcmlnaW5hbEV2ZW50Iiwid2hpY2giLCJfbW91c2VEb3duIiwib25EcmF3aW5nTW91c2VEb3duIiwibW91c2VEb3duIiwib25EcmF3aW5nTW91c2VVcCIsIm9yaWdpbiIsInBvaW50IiwiY2xpZW50WCIsImNsaWVudFkiLCJkaXN0YW5jZSIsImRpc3RhbmNlVG8iLCJNYXRoIiwiYWJzIiwiZGV2aWNlUGl4ZWxSYXRpbyIsIm9uRHJhd2luZ0NsaWNrIiwiZHJhd2luZyIsInN0b3BEcmF3aW5nIiwiY29tbWl0RHJhd2luZyIsImNvbm5lY3RDcmVhdGVkVG9NYXAiLCJsYXllciIsInN0YXJ0UG9seWxpbmUiLCJsaW5lIiwiY3JlYXRlUG9seWxpbmUiLCJlbmFibGVFZGl0IiwibmV3U2hhcGUiLCJzdGFydFBvbHlnb24iLCJwb2x5Z29uIiwiY3JlYXRlUG9seWdvbiIsInN0YXJ0TWFya2VyIiwiZ2V0Q2VudGVyIiwiY2xvbmUiLCJtYXJrZXIiLCJjcmVhdGVNYXJrZXIiLCJzdGFydERyYXdpbmciLCJzdGFydFJlY3RhbmdsZSIsImNvcm5lciIsImxhdExuZyIsImJvdW5kcyIsIkxhdExuZ0JvdW5kcyIsInJlY3RhbmdsZSIsImNyZWF0ZVJlY3RhbmdsZSIsInN0YXJ0Q2lyY2xlIiwiY2lyY2xlIiwiY3JlYXRlQ2lyY2xlIiwic3RhcnRIb2xlIiwibmV3SG9sZSIsImNyZWF0ZUxheWVyIiwia2xhc3MiLCJsYXRsbmdzIiwiVXRpbCIsImVkaXRPcHRpb25zIiwibWFrZUNhbmNlbGxhYmxlIiwiY2FuY2VsIiwiX2NhbmNlbGxlZCIsIk1hcCIsIm1lcmdlT3B0aW9ucyIsImVkaXRUb29sc0NsYXNzIiwiZWRpdGFibGUiLCJhZGRJbml0SG9vayIsIndoZW5SZWFkeSIsIkRpdkljb24iLCJpY29uU2l6ZSIsIlBvaW50IiwiVmVydGV4TWFya2VyIiwiZHJhZ2dhYmxlIiwiY2xhc3NOYW1lIiwicHJvdG90eXBlIiwiY2FsbCIsImljb24iLCJ0b29scyIsIl9fdmVydGV4Iiwic2V0WkluZGV4T2Zmc2V0Iiwib25BZGQiLCJvbkRyYWciLCJvbkRyYWdTdGFydCIsIm9uRHJhZ0VuZCIsIm9uQ2xpY2siLCJvbkNvbnRleHRNZW51Iiwib25Nb3VzZURvd24iLCJvbk1vdXNlT3ZlciIsIm9uTW91c2VPdXQiLCJhZGRNaWRkbGVNYXJrZXJzIiwib25SZW1vdmUiLCJtaWRkbGVNYXJrZXIiLCJkZWxldGUiLCJ2ZXJ0ZXgiLCJvblZlcnRleE1hcmtlckRyYWciLCJpY29uUG9zIiwiZ2V0UG9zaXRpb24iLCJfaWNvbiIsIl9tYXAiLCJsYXllclBvaW50VG9MYXRMbmciLCJ1cGRhdGUiLCJfbGF0bG5nIiwicmVmcmVzaCIsInVwZGF0ZUxhdExuZyIsIm5leHQiLCJnZXROZXh0Iiwib25WZXJ0ZXhNYXJrZXJEcmFnU3RhcnQiLCJvblZlcnRleE1hcmtlckRyYWdFbmQiLCJvblZlcnRleE1hcmtlckNsaWNrIiwiRG9tRXZlbnQiLCJzdG9wIiwib25WZXJ0ZXhNYXJrZXJDb250ZXh0TWVudSIsIm9uVmVydGV4TWFya2VyTW91c2VEb3duIiwib25WZXJ0ZXhNYXJrZXJNb3VzZU92ZXIiLCJvblZlcnRleE1hcmtlck1vdXNlT3V0Iiwic3BsaWNlIiwiZ2V0SW5kZXgiLCJvblZlcnRleERlbGV0ZWQiLCJkZWxldGVTaGFwZSIsInJlc2V0TWlkZGxlTWFya2VyIiwiaW5kZXhPZiIsImdldExhc3RJbmRleCIsImdldFByZXZpb3VzIiwiaW5kZXgiLCJwcmV2aW91c0luZGV4IiwiQ0xPU0VEIiwicHJldmlvdXMiLCJuZXh0SW5kZXgiLCJhZGRNaWRkbGVNYXJrZXIiLCJoYXNNaWRkbGVNYXJrZXJzIiwic3BsaXQiLCJzcGxpdFNoYXBlIiwiY29udGludWUiLCJjb250aW51ZUJhY2t3YXJkIiwiY29udGludWVGb3J3YXJkIiwidmVydGV4TWFya2VyQ2xhc3MiLCJNaWRkbGVNYXJrZXIiLCJvcGFjaXR5IiwibGVmdCIsInJpZ2h0IiwiY29tcHV0ZUxhdExuZyIsIl9vcGFjaXR5Iiwic2V0VmlzaWJpbGl0eSIsImxlZnRQb2ludCIsImxhdExuZ1RvQ29udGFpbmVyUG9pbnQiLCJyaWdodFBvaW50Iiwic2l6ZSIsIngiLCJoaWRlIiwic2hvdyIsInNldE9wYWNpdHkiLCJzZXRMYXRMbmciLCJ5IiwiY29udGFpbmVyUG9pbnRUb0xhdExuZyIsIm9uTWlkZGxlTWFya2VyTW91c2VEb3duIiwiYWRkVmVydGV4TWFya2VyIiwib25OZXdWZXJ0ZXgiLCJwYXJlbnQiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJhcHBlbmRDaGlsZCIsIl9pbml0SWNvbiIsIl9pbml0SW50ZXJhY3Rpb24iLCJEcmFnZ2FibGUiLCJfZHJhZ2dpbmciLCJkcmFnZ2luZyIsIl9kcmFnZ2FibGUiLCJfb25Eb3duIiwibWlkZGxlTWFya2VyQ2xhc3MiLCJCYXNlRWRpdG9yIiwiSGFuZGxlciIsImZlYXR1cmUiLCJhZGRIb29rcyIsImlzQ29ubmVjdGVkIiwib25GZWF0dXJlQWRkIiwib25jZSIsIm9uRW5hYmxlIiwiX2dldEV2ZW50cyIsInJlbW92ZUhvb2tzIiwiZGlzYWJsZSIsImNsZWFyTGF5ZXJzIiwib25EaXNhYmxlIiwiZW5hYmxlIiwib25FZGl0aW5nIiwib25TdGFydERyYXdpbmciLCJvbkVuZERyYXdpbmciLCJvbkNhbmNlbERyYXdpbmciLCJvbkNvbW1pdERyYXdpbmciLCJlbmREcmF3aW5nIiwiY29ubmVjdCIsInByb2Nlc3NEcmF3aW5nQ2xpY2siLCJoYXNMYXllciIsIm9uTW92ZSIsImRyYWdzdGFydCIsImRyYWciLCJkcmFnZW5kIiwicmVtb3ZlIiwiTWFya2VyRWRpdG9yIiwiUGF0aEVkaXRvciIsIk1JTl9WRVJURVgiLCJpbml0VmVydGV4TWFya2VycyIsImVuYWJsZWQiLCJnZXRMYXRMbmdzIiwiaXNGbGF0IiwiYWRkVmVydGV4TWFya2VycyIsImkiLCJyZWZyZXNoVmVydGV4TWFya2VycyIsImdldERlZmF1bHRMYXRMbmdzIiwiY29tbWl0IiwiY3RybEtleSIsIm9uVmVydGV4TWFya2VyQ3RybENsaWNrIiwiYWx0S2V5Iiwib25WZXJ0ZXhNYXJrZXJBbHRDbGljayIsInNoaWZ0S2V5Iiwib25WZXJ0ZXhNYXJrZXJTaGlmdENsaWNrIiwibWV0YUtleSIsIm9uVmVydGV4TWFya2VyTWV0YUtleUNsaWNrIiwiX2RyYXduTGF0TG5ncyIsIm9uVmVydGV4UmF3TWFya2VyQ2xpY2siLCJ2ZXJ0ZXhDYW5CZURlbGV0ZWQiLCJleHRlbmRCb3VuZHMiLCJzZXREcmF3bkxhdExuZ3MiLCJzdGFydERyYXdpbmdGb3J3YXJkIiwiYWRkTGF0TG5nIiwicHVzaCIsInVuc2hpZnQiLCJuZXdQb2ludEZvcndhcmQiLCJuZXdQb2ludEJhY2t3YXJkIiwiY29uc29sZSIsImVycm9yIiwicmVtb3ZlTGF0TG5nIiwicG9wIiwic2hhcGUiLCJhZGROZXdFbXB0eVNoYXBlIiwiX2RlbGV0ZVNoYXBlIiwiZW5zdXJlTm90RmxhdCIsInNlbGYiLCJpbnBsYWNlRGVsZXRlIiwiTnVtYmVyIiwiTUFYX1ZBTFVFIiwic3BsaWNlRGVsZXRlIiwiZGVsZXRlU2hhcGVBdCIsInNoYXBlQXQiLCJhcHBlbmRTaGFwZSIsImluc2VydFNoYXBlIiwicHJlcGVuZFNoYXBlIiwiZW5zdXJlTXVsdGkiLCJmb3JtYXRTaGFwZSIsIl9lbmFibGVkIiwiUG9seWxpbmVFZGl0b3IiLCJzdGFydERyYXdpbmdCYWNrd2FyZCIsIkxhdExuZyIsInNoYXBlSW5kZXgiLCJmaXJzdCIsInNsaWNlIiwic2Vjb25kIiwibGF0IiwibG5nIiwiYWx0IiwiUG9seWdvbkVkaXRvciIsImFkZE5ld0VtcHR5SG9sZSIsImhvbGVzIiwicGFyZW50U2hhcGUiLCJpZHgiLCJSZWN0YW5nbGVFZGl0b3IiLCJvcHBvc2l0ZUluZGV4Iiwib3Bwb3NpdGUiLCJ1cGRhdGVCb3VuZHMiLCJ1cGRhdGVMYXRMbmdzIiwiX3NpbXVsYXRlZCIsIl9vblVwIiwibmV3TGF0bG5ncyIsIl9ib3VuZHNUb0xhdExuZ3MiLCJDaXJjbGVFZGl0b3IiLCJfcmVzaXplTGF0TG5nIiwiY29tcHV0ZVJlc2l6ZUxhdExuZyIsImRlbHRhIiwiX3JhZGl1cyIsIl9tUmFkaXVzIiwiY29zIiwiUEkiLCJwcm9qZWN0IiwidW5wcm9qZWN0IiwidXBkYXRlUmVzaXplTGF0TG5nIiwicmVzaXplIiwicmFkaXVzIiwic2V0UmFkaXVzIiwiRWRpdGFibGVNaXhpbiIsImNyZWF0ZUVkaXRvciIsIkVycm9yIiwiS2xhc3MiLCJlZGl0b3JDbGFzcyIsImdldEVkaXRvckNsYXNzIiwiZWRpdEVuYWJsZWQiLCJkaXNhYmxlRWRpdCIsInRvZ2dsZUVkaXQiLCJfb25FZGl0YWJsZUFkZCIsIlBvbHlsaW5lTWl4aW4iLCJpc0luTGF0TG5ncyIsImwiLCJrIiwibGVuIiwicGFydCIsInAiLCJ3IiwiX2NsaWNrVG9sZXJhbmNlIiwiX3Byb2plY3RMYXRsbmdzIiwiX3B4Qm91bmRzIiwibGF0TG5nVG9MYXllclBvaW50IiwiY29udGFpbnMiLCJMaW5lVXRpbCIsInBvaW50VG9TZWdtZW50RGlzdGFuY2UiLCJQb2x5Z29uTWl4aW4iLCJpbnNpZGUiLCJsMSIsImwyIiwiaiIsImxlbjIiLCJNYXJrZXJNaXhpbiIsIlJlY3RhbmdsZU1peGluIiwiQ2lyY2xlTWl4aW4iLCJrZWVwRWRpdGFibGUiLCJfZmxhdCIsImluY2x1ZGUiXSwibWFwcGluZ3MiOiJBQUFBOzs7O0FBQ0MsV0FBVUEsT0FBVixFQUFtQkMsTUFBbkIsRUFBMkI7QUFDeEI7O0FBRUE7QUFDQSxRQUFJLE9BQU9DLE1BQVAsS0FBa0IsVUFBbEIsSUFBZ0NBLE9BQU9DLEdBQTNDLEVBQWdEO0FBQzVDRCxlQUFPLENBQUMsU0FBRCxDQUFQLEVBQW9CRixPQUFwQjs7QUFHSjtBQUNDLEtBTEQsTUFLTyxJQUFJLFFBQU9JLE9BQVAseUNBQU9BLE9BQVAsT0FBbUIsUUFBdkIsRUFBaUM7QUFDcENDLGVBQU9ELE9BQVAsR0FBaUJKLFFBQVFNLFFBQVEsU0FBUixDQUFSLENBQWpCO0FBQ0g7O0FBRUQ7QUFDQSxRQUFHLE9BQU9MLE1BQVAsS0FBa0IsV0FBbEIsSUFBaUNBLE9BQU9NLENBQTNDLEVBQTZDO0FBQ3pDUCxnQkFBUUMsT0FBT00sQ0FBZjtBQUNIO0FBRUosQ0FsQkEsRUFrQkMsVUFBVUEsQ0FBVixFQUFhO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBQSxNQUFFQyxRQUFGLEdBQWFELEVBQUVFLE9BQUYsQ0FBVUMsTUFBVixDQUFpQjs7QUFFMUJDLGlCQUFTO0FBQ0xDLHFCQUFTLENBREo7QUFFTEMsc0JBQVUsQ0FBQztBQUZOLFNBRmlCOztBQU8xQkMsaUJBQVM7O0FBRUw7QUFDQTtBQUNBO0FBQ0FDLG9CQUFRLElBTEg7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QUFULENBQWlCTCxXQUFqQjtBQUNBdlosVUFBRWMsTUFBRixDQUFTNkksV0FBVCxDQUFxQitQLFlBQXJCO0FBQ0g7QUFDRCxRQUFJMVosRUFBRWdCLFNBQU4sRUFBaUI7QUFDYmhCLFVBQUVnQixTQUFGLENBQVk0WSxPQUFaLENBQW9CcEMsYUFBcEI7QUFDQXhYLFVBQUVnQixTQUFGLENBQVk0WSxPQUFaLENBQW9CSixjQUFwQjtBQUNIO0FBQ0QsUUFBSXhaLEVBQUVrQixNQUFOLEVBQWM7QUFDVmxCLFVBQUVrQixNQUFGLENBQVMwWSxPQUFULENBQWlCcEMsYUFBakI7QUFDQXhYLFVBQUVrQixNQUFGLENBQVMwWSxPQUFULENBQWlCSCxXQUFqQjtBQUNIOztBQUVEelosTUFBRW9WLE1BQUYsQ0FBU2pMLFNBQVQsQ0FBbUIwQixNQUFuQixHQUE0QixVQUFVbkksTUFBVixFQUFrQjtBQUMxQ0EsaUJBQVMxRCxFQUFFcUksTUFBRixDQUFTM0UsTUFBVCxDQUFUO0FBQ0EsYUFBSytSLEdBQUwsR0FBVy9SLE9BQU8rUixHQUFsQjtBQUNBLGFBQUtDLEdBQUwsR0FBV2hTLE9BQU9nUyxHQUFsQjtBQUNILEtBSkQ7QUFNSCxDQXg1REEsRUF3NURFaFcsTUF4NURGLENBQUQiLCJmaWxlIjoiVnVlMkxlYWZsZXRFZGl0YWJsZS5qcyIsInNvdXJjZVJvb3QiOiIvVXNlcnMvcHVtZWxvdGVhL1Z1ZVByb2plY3RzL3Z1ZTItbGVhZmxldC1lZGl0YWJsZSIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbihmdW5jdGlvbiAoZmFjdG9yeSwgd2luZG93KSB7XG4gICAgLypnbG9iYWxzIGRlZmluZSwgbW9kdWxlLCByZXF1aXJlKi9cblxuICAgIC8vIGRlZmluZSBhbiBBTUQgbW9kdWxlIHRoYXQgcmVsaWVzIG9uICdsZWFmbGV0J1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKFsnbGVhZmxldCddLCBmYWN0b3J5KTtcblxuXG4gICAgLy8gZGVmaW5lIGEgQ29tbW9uIEpTIG1vZHVsZSB0aGF0IHJlbGllcyBvbiAnbGVhZmxldCdcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkocmVxdWlyZSgnbGVhZmxldCcpKTtcbiAgICB9XG5cbiAgICAvLyBhdHRhY2ggeW91ciBwbHVnaW4gdG8gdGhlIGdsb2JhbCAnTCcgdmFyaWFibGVcbiAgICBpZih0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTCl7XG4gICAgICAgIGZhY3Rvcnkod2luZG93LkwpO1xuICAgIH1cblxufShmdW5jdGlvbiAoTCkge1xuICAgIC8vIPCfjYJtaW5pY2xhc3MgQ2FuY2VsYWJsZUV2ZW50IChFdmVudCBvYmplY3RzKVxuICAgIC8vIPCfjYJtZXRob2QgY2FuY2VsKClcbiAgICAvLyBDYW5jZWwgYW55IHN1YnNlcXVlbnQgYWN0aW9uLlxuXG4gICAgLy8g8J+Ngm1pbmljbGFzcyBWZXJ0ZXhFdmVudCAoRXZlbnQgb2JqZWN0cylcbiAgICAvLyDwn42CcHJvcGVydHkgdmVydGV4OiBWZXJ0ZXhNYXJrZXJcbiAgICAvLyBUaGUgdmVydGV4IHRoYXQgZmlyZXMgdGhlIGV2ZW50LlxuXG4gICAgLy8g8J+Ngm1pbmljbGFzcyBTaGFwZUV2ZW50IChFdmVudCBvYmplY3RzKVxuICAgIC8vIPCfjYJwcm9wZXJ0eSBzaGFwZTogQXJyYXlcbiAgICAvLyBUaGUgc2hhcGUgKExhdExuZ3MgYXJyYXkpIHN1YmplY3Qgb2YgdGhlIGFjdGlvbi5cblxuICAgIC8vIPCfjYJtaW5pY2xhc3MgQ2FuY2VsYWJsZVZlcnRleEV2ZW50IChFdmVudCBvYmplY3RzKVxuICAgIC8vIPCfjYJpbmhlcml0cyBWZXJ0ZXhFdmVudFxuICAgIC8vIPCfjYJpbmhlcml0cyBDYW5jZWxhYmxlRXZlbnRcblxuICAgIC8vIPCfjYJtaW5pY2xhc3MgQ2FuY2VsYWJsZVNoYXBlRXZlbnQgKEV2ZW50IG9iamVjdHMpXG4gICAgLy8g8J+NgmluaGVyaXRzIFNoYXBlRXZlbnRcbiAgICAvLyDwn42CaW5oZXJpdHMgQ2FuY2VsYWJsZUV2ZW50XG5cbiAgICAvLyDwn42CbWluaWNsYXNzIExheWVyRXZlbnQgKEV2ZW50IG9iamVjdHMpXG4gICAgLy8g8J+NgnByb3BlcnR5IGxheWVyOiBvYmplY3RcbiAgICAvLyBUaGUgTGF5ZXIgKE1hcmtlciwgUG9seWxpbmXigKYpIHN1YmplY3Qgb2YgdGhlIGFjdGlvbi5cblxuICAgIC8vIPCfjYJuYW1lc3BhY2UgRWRpdGFibGU7IPCfjYJjbGFzcyBFZGl0YWJsZTsg8J+NgmFrYSBMLkVkaXRhYmxlXG4gICAgLy8gTWFpbiBlZGl0aW9uIGhhbmRsZXIuIEJ5IGRlZmF1bHQsIGl0IGlzIGF0dGFjaGVkIHRvIHRoZSBtYXBcbiAgICAvLyBhcyBgbWFwLmVkaXRUb29sc2AgcHJvcGVydHkuXG4gICAgLy8gTGVhZmxldC5FZGl0YWJsZSBpcyBtYWRlIHRvIGJlIGZ1bGx5IGV4dGVuZGFibGUuIFlvdSBoYXZlIHRocmVlIHdheXMgdG8gY3VzdG9taXplXG4gICAgLy8gdGhlIGJlaGF2aW91cjogdXNpbmcgb3B0aW9ucywgbGlzdGVuaW5nIHRvIGV2ZW50cywgb3IgZXh0ZW5kaW5nLlxuICAgIEwuRWRpdGFibGUgPSBMLkV2ZW50ZWQuZXh0ZW5kKHtcblxuICAgICAgICBzdGF0aWNzOiB7XG4gICAgICAgICAgICBGT1JXQVJEOiAxLFxuICAgICAgICAgICAgQkFDS1dBUkQ6IC0xXG4gICAgICAgIH0sXG5cbiAgICAgICAgb3B0aW9uczoge1xuXG4gICAgICAgICAgICAvLyBZb3UgY2FuIHBhc3MgdGhlbSB3aGVuIGNyZWF0aW5nIGEgbWFwIHVzaW5nIHRoZSBgZWRpdE9wdGlvbnNgIGtleS5cbiAgICAgICAgICAgIC8vIPCfjYJvcHRpb24gekluZGV4OiBpbnQgPSAxMDAwXG4gICAgICAgICAgICAvLyBUaGUgZGVmYXVsdCB6SW5kZXggb2YgdGhlIGVkaXRpbmcgdG9vbHMuXG4gICAgICAgICAgICB6SW5kZXg6IDEwMDAsXG5cbiAgICAgICAgICAgIC8vIPCfjYJvcHRpb24gcG9seWdvbkNsYXNzOiBjbGFzcyA9IEwuUG9seWdvblxuICAgICAgICAgICAgLy8gQ2xhc3MgdG8gYmUgdXNlZCB3aGVuIGNyZWF0aW5nIGEgbmV3IFBvbHlnb24uXG4gICAgICAgICAgICBwb2x5Z29uQ2xhc3M6IEwuUG9seWdvbixcblxuICAgICAgICAgICAgLy8g8J+Ngm9wdGlvbiBwb2x5bGluZUNsYXNzOiBjbGFzcyA9IEwuUG9seWxpbmVcbiAgICAgICAgICAgIC8vIENsYXNzIHRvIGJlIHVzZWQgd2hlbiBjcmVhdGluZyBhIG5ldyBQb2x5bGluZS5cbiAgICAgICAgICAgIHBvbHlsaW5lQ2xhc3M6IEwuUG9seWxpbmUsXG5cbiAgICAgICAgICAgIC8vIPCfjYJvcHRpb24gbWFya2VyQ2xhc3M6IGNsYXNzID0gTC5NYXJrZXJcbiAgICAgICAgICAgIC8vIENsYXNzIHRvIGJlIHVzZWQgd2hlbiBjcmVhdGluZyBhIG5ldyBNYXJrZXIuXG4gICAgICAgICAgICBtYXJrZXJDbGFzczogTC5NYXJrZXIsXG5cbiAgICAgICAgICAgIC8vIPCfjYJvcHRpb24gcmVjdGFuZ2xlQ2xhc3M6IGNsYXNzID0gTC5SZWN0YW5nbGVcbiAgICAgICAgICAgIC8vIENsYXNzIHRvIGJlIHVzZWQgd2hlbiBjcmVhdGluZyBhIG5ldyBSZWN0YW5nbGUuXG4gICAgICAgICAgICByZWN0YW5nbGVDbGFzczogTC5SZWN0YW5nbGUsXG5cbiAgICAgICAgICAgIC8vIPCfjYJvcHRpb24gY2lyY2xlQ2xhc3M6IGNsYXNzID0gTC5DaXJjbGVcbiAgICAgICAgICAgIC8vIENsYXNzIHRvIGJlIHVzZWQgd2hlbiBjcmVhdGluZyBhIG5ldyBDaXJjbGUuXG4gICAgICAgICAgICBjaXJjbGVDbGFzczogTC5DaXJjbGUsXG5cbiAgICAgICAgICAgIC8vIPCfjYJvcHRpb24gZHJhd2luZ0NTU0NsYXNzOiBzdHJpbmcgPSAnbGVhZmxldC1lZGl0YWJsZS1kcmF3aW5nJ1xuICAgICAgICAgICAgLy8gQ1NTIGNsYXNzIHRvIGJlIGFkZGVkIHRvIHRoZSBtYXAgY29udGFpbmVyIHdoaWxlIGRyYXdpbmcuXG4gICAgICAgICAgICBkcmF3aW5nQ1NTQ2xhc3M6ICdsZWFmbGV0LWVkaXRhYmxlLWRyYXdpbmcnLFxuXG4gICAgICAgICAgICAvLyDwn42Cb3B0aW9uIGRyYXdpbmdDdXJzb3I6IGNvbnN0ID0gJ2Nyb3NzaGFpcidcbiAgICAgICAgICAgIC8vIEN1cnNvciBtb2RlIHNldCB0byB0aGUgbWFwIHdoaWxlIGRyYXdpbmcuXG4gICAgICAgICAgICBkcmF3aW5nQ3Vyc29yOiAnY3Jvc3NoYWlyJyxcblxuICAgICAgICAgICAgLy8g8J+Ngm9wdGlvbiBlZGl0TGF5ZXI6IExheWVyID0gbmV3IEwuTGF5ZXJHcm91cCgpXG4gICAgICAgICAgICAvLyBMYXllciB1c2VkIHRvIHN0b3JlIGVkaXQgdG9vbHMgKHZlcnRleCwgbGluZSBndWlkZeKApikuXG4gICAgICAgICAgICBlZGl0TGF5ZXI6IHVuZGVmaW5lZCxcblxuICAgICAgICAgICAgLy8g8J+Ngm9wdGlvbiBmZWF0dXJlc0xheWVyOiBMYXllciA9IG5ldyBMLkxheWVyR3JvdXAoKVxuICAgICAgICAgICAgLy8gRGVmYXVsdCBsYXllciB1c2VkIHRvIHN0b3JlIGRyYXduIGZlYXR1cmVzIChNYXJrZXIsIFBvbHlsaW5l4oCmKS5cbiAgICAgICAgICAgIGZlYXR1cmVzTGF5ZXI6IHVuZGVmaW5lZCxcblxuICAgICAgICAgICAgLy8g8J+Ngm9wdGlvbiBwb2x5bGluZUVkaXRvckNsYXNzOiBjbGFzcyA9IFBvbHlsaW5lRWRpdG9yXG4gICAgICAgICAgICAvLyBDbGFzcyB0byBiZSB1c2VkIGFzIFBvbHlsaW5lIGVkaXRvci5cbiAgICAgICAgICAgIHBvbHlsaW5lRWRpdG9yQ2xhc3M6IHVuZGVmaW5lZCxcblxuICAgICAgICAgICAgLy8g8J+Ngm9wdGlvbiBwb2x5Z29uRWRpdG9yQ2xhc3M6IGNsYXNzID0gUG9seWdvbkVkaXRvclxuICAgICAgICAgICAgLy8gQ2xhc3MgdG8gYmUgdXNlZCBhcyBQb2x5Z29uIGVkaXRvci5cbiAgICAgICAgICAgIHBvbHlnb25FZGl0b3JDbGFzczogdW5kZWZpbmVkLFxuXG4gICAgICAgICAgICAvLyDwn42Cb3B0aW9uIG1hcmtlckVkaXRvckNsYXNzOiBjbGFzcyA9IE1hcmtlckVkaXRvclxuICAgICAgICAgICAgLy8gQ2xhc3MgdG8gYmUgdXNlZCBhcyBNYXJrZXIgZWRpdG9yLlxuICAgICAgICAgICAgbWFya2VyRWRpdG9yQ2xhc3M6IHVuZGVmaW5lZCxcblxuICAgICAgICAgICAgLy8g8J+Ngm9wdGlvbiByZWN0YW5nbGVFZGl0b3JDbGFzczogY2xhc3MgPSBSZWN0YW5nbGVFZGl0b3JcbiAgICAgICAgICAgIC8vIENsYXNzIHRvIGJlIHVzZWQgYXMgUmVjdGFuZ2xlIGVkaXRvci5cbiAgICAgICAgICAgIHJlY3RhbmdsZUVkaXRvckNsYXNzOiB1bmRlZmluZWQsXG5cbiAgICAgICAgICAgIC8vIPCfjYJvcHRpb24gY2lyY2xlRWRpdG9yQ2xhc3M6IGNsYXNzID0gQ2lyY2xlRWRpdG9yXG4gICAgICAgICAgICAvLyBDbGFzcyB0byBiZSB1c2VkIGFzIENpcmNsZSBlZGl0b3IuXG4gICAgICAgICAgICBjaXJjbGVFZGl0b3JDbGFzczogdW5kZWZpbmVkLFxuXG4gICAgICAgICAgICAvLyDwn42Cb3B0aW9uIGxpbmVHdWlkZU9wdGlvbnM6IGhhc2ggPSB7fVxuICAgICAgICAgICAgLy8gT3B0aW9ucyB0byBiZSBwYXNzZWQgdG8gdGhlIGxpbmUgZ3VpZGVzLlxuICAgICAgICAgICAgbGluZUd1aWRlT3B0aW9uczoge30sXG5cbiAgICAgICAgICAgIC8vIPCfjYJvcHRpb24gc2tpcE1pZGRsZU1hcmtlcnM6IGJvb2xlYW4gPSBmYWxzZVxuICAgICAgICAgICAgLy8gU2V0IHRoaXMgdG8gdHJ1ZSBpZiB5b3UgZG9uJ3Qgd2FudCBtaWRkbGUgbWFya2Vycy5cbiAgICAgICAgICAgIHNraXBNaWRkbGVNYXJrZXJzOiBmYWxzZVxuXG4gICAgICAgIH0sXG5cbiAgICAgICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcCwgb3B0aW9ucykge1xuICAgICAgICAgICAgTC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5fbGFzdFpJbmRleCA9IHRoaXMub3B0aW9ucy56SW5kZXg7XG4gICAgICAgICAgICB0aGlzLm1hcCA9IG1hcDtcbiAgICAgICAgICAgIHRoaXMuZWRpdExheWVyID0gdGhpcy5jcmVhdGVFZGl0TGF5ZXIoKTtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZXNMYXllciA9IHRoaXMuY3JlYXRlRmVhdHVyZXNMYXllcigpO1xuICAgICAgICAgICAgdGhpcy5mb3J3YXJkTGluZUd1aWRlID0gdGhpcy5jcmVhdGVMaW5lR3VpZGUoKTtcbiAgICAgICAgICAgIHRoaXMuYmFja3dhcmRMaW5lR3VpZGUgPSB0aGlzLmNyZWF0ZUxpbmVHdWlkZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpcmVBbmRGb3J3YXJkOiBmdW5jdGlvbiAodHlwZSwgZSkge1xuICAgICAgICAgICAgZSA9IGUgfHwge307XG4gICAgICAgICAgICBlLmVkaXRUb29scyA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmZpcmUodHlwZSwgZSk7XG4gICAgICAgICAgICB0aGlzLm1hcC5maXJlKHR5cGUsIGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZUxpbmVHdWlkZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBMLmV4dGVuZCh7ZGFzaEFycmF5OiAnNSwxMCcsIHdlaWdodDogMSwgaW50ZXJhY3RpdmU6IGZhbHNlfSwgdGhpcy5vcHRpb25zLmxpbmVHdWlkZU9wdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuIEwucG9seWxpbmUoW10sIG9wdGlvbnMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZVZlcnRleEljb246IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gTC5Ccm93c2VyLm1vYmlsZSAmJiBMLkJyb3dzZXIudG91Y2ggPyBuZXcgTC5FZGl0YWJsZS5Ub3VjaFZlcnRleEljb24ob3B0aW9ucykgOiBuZXcgTC5FZGl0YWJsZS5WZXJ0ZXhJY29uKG9wdGlvbnMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZUVkaXRMYXllcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5lZGl0TGF5ZXIgfHwgbmV3IEwuTGF5ZXJHcm91cCgpLmFkZFRvKHRoaXMubWFwKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVGZWF0dXJlc0xheWVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmZlYXR1cmVzTGF5ZXIgfHwgbmV3IEwuTGF5ZXJHcm91cCgpLmFkZFRvKHRoaXMubWFwKTtcbiAgICAgICAgfSxcblxuICAgICAgICBtb3ZlRm9yd2FyZExpbmVHdWlkZTogZnVuY3Rpb24gKGxhdGxuZykge1xuICAgICAgICAgICAgaWYgKHRoaXMuZm9yd2FyZExpbmVHdWlkZS5fbGF0bG5ncy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZvcndhcmRMaW5lR3VpZGUuX2xhdGxuZ3NbMV0gPSBsYXRsbmc7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3J3YXJkTGluZUd1aWRlLl9ib3VuZHMuZXh0ZW5kKGxhdGxuZyk7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3J3YXJkTGluZUd1aWRlLnJlZHJhdygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG1vdmVCYWNrd2FyZExpbmVHdWlkZTogZnVuY3Rpb24gKGxhdGxuZykge1xuICAgICAgICAgICAgaWYgKHRoaXMuYmFja3dhcmRMaW5lR3VpZGUuX2xhdGxuZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5iYWNrd2FyZExpbmVHdWlkZS5fbGF0bG5nc1sxXSA9IGxhdGxuZztcbiAgICAgICAgICAgICAgICB0aGlzLmJhY2t3YXJkTGluZUd1aWRlLl9ib3VuZHMuZXh0ZW5kKGxhdGxuZyk7XG4gICAgICAgICAgICAgICAgdGhpcy5iYWNrd2FyZExpbmVHdWlkZS5yZWRyYXcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBhbmNob3JGb3J3YXJkTGluZUd1aWRlOiBmdW5jdGlvbiAobGF0bG5nKSB7XG4gICAgICAgICAgICB0aGlzLmZvcndhcmRMaW5lR3VpZGUuX2xhdGxuZ3NbMF0gPSBsYXRsbmc7XG4gICAgICAgICAgICB0aGlzLmZvcndhcmRMaW5lR3VpZGUuX2JvdW5kcy5leHRlbmQobGF0bG5nKTtcbiAgICAgICAgICAgIHRoaXMuZm9yd2FyZExpbmVHdWlkZS5yZWRyYXcoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBhbmNob3JCYWNrd2FyZExpbmVHdWlkZTogZnVuY3Rpb24gKGxhdGxuZykge1xuICAgICAgICAgICAgdGhpcy5iYWNrd2FyZExpbmVHdWlkZS5fbGF0bG5nc1swXSA9IGxhdGxuZztcbiAgICAgICAgICAgIHRoaXMuYmFja3dhcmRMaW5lR3VpZGUuX2JvdW5kcy5leHRlbmQobGF0bG5nKTtcbiAgICAgICAgICAgIHRoaXMuYmFja3dhcmRMaW5lR3VpZGUucmVkcmF3KCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYXR0YWNoRm9yd2FyZExpbmVHdWlkZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5lZGl0TGF5ZXIuYWRkTGF5ZXIodGhpcy5mb3J3YXJkTGluZUd1aWRlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBhdHRhY2hCYWNrd2FyZExpbmVHdWlkZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5lZGl0TGF5ZXIuYWRkTGF5ZXIodGhpcy5iYWNrd2FyZExpbmVHdWlkZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGV0YWNoRm9yd2FyZExpbmVHdWlkZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5mb3J3YXJkTGluZUd1aWRlLnNldExhdExuZ3MoW10pO1xuICAgICAgICAgICAgdGhpcy5lZGl0TGF5ZXIucmVtb3ZlTGF5ZXIodGhpcy5mb3J3YXJkTGluZUd1aWRlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBkZXRhY2hCYWNrd2FyZExpbmVHdWlkZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5iYWNrd2FyZExpbmVHdWlkZS5zZXRMYXRMbmdzKFtdKTtcbiAgICAgICAgICAgIHRoaXMuZWRpdExheWVyLnJlbW92ZUxheWVyKHRoaXMuYmFja3dhcmRMaW5lR3VpZGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGJsb2NrRXZlbnRzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBIYWNrOiBmb3JjZSBtYXAgbm90IHRvIGxpc3RlbiB0byBvdGhlciBsYXllcnMgZXZlbnRzIHdoaWxlIGRyYXdpbmcuXG4gICAgICAgICAgICBpZiAoIXRoaXMuX29sZFRhcmdldHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vbGRUYXJnZXRzID0gdGhpcy5tYXAuX3RhcmdldHM7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXAuX3RhcmdldHMgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB1bmJsb2NrRXZlbnRzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fb2xkVGFyZ2V0cykge1xuICAgICAgICAgICAgICAgIC8vIFJlc2V0LCBidXQga2VlcCB0YXJnZXRzIGNyZWF0ZWQgd2hpbGUgZHJhd2luZy5cbiAgICAgICAgICAgICAgICB0aGlzLm1hcC5fdGFyZ2V0cyA9IEwuZXh0ZW5kKHRoaXMubWFwLl90YXJnZXRzLCB0aGlzLl9vbGRUYXJnZXRzKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fb2xkVGFyZ2V0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICByZWdpc3RlckZvckRyYXdpbmc6IGZ1bmN0aW9uIChlZGl0b3IpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9kcmF3aW5nRWRpdG9yKSB0aGlzLnVucmVnaXN0ZXJGb3JEcmF3aW5nKHRoaXMuX2RyYXdpbmdFZGl0b3IpO1xuICAgICAgICAgICAgdGhpcy5ibG9ja0V2ZW50cygpO1xuICAgICAgICAgICAgZWRpdG9yLnJlc2V0KCk7ICAvLyBNYWtlIHN1cmUgZWRpdG9yIHRvb2xzIHN0aWxsIHJlY2VpdmUgZXZlbnRzLlxuICAgICAgICAgICAgdGhpcy5fZHJhd2luZ0VkaXRvciA9IGVkaXRvcjtcbiAgICAgICAgICAgIHRoaXMubWFwLm9uKCdtb3VzZW1vdmUgdG91Y2htb3ZlJywgZWRpdG9yLm9uRHJhd2luZ01vdXNlTW92ZSwgZWRpdG9yKTtcbiAgICAgICAgICAgIHRoaXMubWFwLm9uKCdtb3VzZWRvd24nLCB0aGlzLm9uTW91c2Vkb3duLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMubWFwLm9uKCdtb3VzZXVwJywgdGhpcy5vbk1vdXNldXAsIHRoaXMpO1xuICAgICAgICAgICAgTC5Eb21VdGlsLmFkZENsYXNzKHRoaXMubWFwLl9jb250YWluZXIsIHRoaXMub3B0aW9ucy5kcmF3aW5nQ1NTQ2xhc3MpO1xuICAgICAgICAgICAgdGhpcy5kZWZhdWx0TWFwQ3Vyc29yID0gdGhpcy5tYXAuX2NvbnRhaW5lci5zdHlsZS5jdXJzb3I7XG4gICAgICAgICAgICB0aGlzLm1hcC5fY29udGFpbmVyLnN0eWxlLmN1cnNvciA9IHRoaXMub3B0aW9ucy5kcmF3aW5nQ3Vyc29yO1xuICAgICAgICB9LFxuXG4gICAgICAgIHVucmVnaXN0ZXJGb3JEcmF3aW5nOiBmdW5jdGlvbiAoZWRpdG9yKSB7XG4gICAgICAgICAgICB0aGlzLnVuYmxvY2tFdmVudHMoKTtcbiAgICAgICAgICAgIEwuRG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLm1hcC5fY29udGFpbmVyLCB0aGlzLm9wdGlvbnMuZHJhd2luZ0NTU0NsYXNzKTtcbiAgICAgICAgICAgIHRoaXMubWFwLl9jb250YWluZXIuc3R5bGUuY3Vyc29yID0gdGhpcy5kZWZhdWx0TWFwQ3Vyc29yO1xuICAgICAgICAgICAgZWRpdG9yID0gZWRpdG9yIHx8IHRoaXMuX2RyYXdpbmdFZGl0b3I7XG4gICAgICAgICAgICBpZiAoIWVkaXRvcikgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5tYXAub2ZmKCdtb3VzZW1vdmUgdG91Y2htb3ZlJywgZWRpdG9yLm9uRHJhd2luZ01vdXNlTW92ZSwgZWRpdG9yKTtcbiAgICAgICAgICAgIHRoaXMubWFwLm9mZignbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlZG93biwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLm1hcC5vZmYoJ21vdXNldXAnLCB0aGlzLm9uTW91c2V1cCwgdGhpcyk7XG4gICAgICAgICAgICBpZiAoZWRpdG9yICE9PSB0aGlzLl9kcmF3aW5nRWRpdG9yKSByZXR1cm47XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fZHJhd2luZ0VkaXRvcjtcbiAgICAgICAgICAgIGlmIChlZGl0b3IuX2RyYXdpbmcpIGVkaXRvci5jYW5jZWxEcmF3aW5nKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25Nb3VzZWRvd246IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAoZS5vcmlnaW5hbEV2ZW50LndoaWNoICE9IDEpIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMuX21vdXNlRG93biA9IGU7XG4gICAgICAgICAgICB0aGlzLl9kcmF3aW5nRWRpdG9yLm9uRHJhd2luZ01vdXNlRG93bihlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvbk1vdXNldXA6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbW91c2VEb3duKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVkaXRvciA9IHRoaXMuX2RyYXdpbmdFZGl0b3IsXG4gICAgICAgICAgICAgICAgICAgIG1vdXNlRG93biA9IHRoaXMuX21vdXNlRG93bjtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb3VzZURvd24gPSBudWxsO1xuICAgICAgICAgICAgICAgIGVkaXRvci5vbkRyYXdpbmdNb3VzZVVwKGUpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9kcmF3aW5nRWRpdG9yICE9PSBlZGl0b3IpIHJldHVybjsgIC8vIG9uRHJhd2luZ01vdXNlVXAgbWF5IGNhbGwgdW5yZWdpc3RlckZyb21EcmF3aW5nLlxuICAgICAgICAgICAgICAgIHZhciBvcmlnaW4gPSBMLnBvaW50KG1vdXNlRG93bi5vcmlnaW5hbEV2ZW50LmNsaWVudFgsIG1vdXNlRG93bi5vcmlnaW5hbEV2ZW50LmNsaWVudFkpO1xuICAgICAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IEwucG9pbnQoZS5vcmlnaW5hbEV2ZW50LmNsaWVudFgsIGUub3JpZ2luYWxFdmVudC5jbGllbnRZKS5kaXN0YW5jZVRvKG9yaWdpbik7XG4gICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKGRpc3RhbmNlKSA8IDkgKiAod2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSkpIHRoaXMuX2RyYXdpbmdFZGl0b3Iub25EcmF3aW5nQ2xpY2soZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8g8J+NgnNlY3Rpb24gUHVibGljIG1ldGhvZHNcbiAgICAgICAgLy8gWW91IHdpbGwgZ2VuZXJhbGx5IGFjY2VzcyB0aGVtIGJ5IHRoZSBgbWFwLmVkaXRUb29sc2BcbiAgICAgICAgLy8gaW5zdGFuY2U6XG4gICAgICAgIC8vXG4gICAgICAgIC8vIGBtYXAuZWRpdFRvb2xzLnN0YXJ0UG9seWxpbmUoKTtgXG5cbiAgICAgICAgLy8g8J+Ngm1ldGhvZCBkcmF3aW5nKCk6IGJvb2xlYW5cbiAgICAgICAgLy8gUmV0dXJuIHRydWUgaWYgYW55IGRyYXdpbmcgYWN0aW9uIGlzIG9uZ29pbmcuXG4gICAgICAgIGRyYXdpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kcmF3aW5nRWRpdG9yICYmIHRoaXMuX2RyYXdpbmdFZGl0b3IuZHJhd2luZygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIPCfjYJtZXRob2Qgc3RvcERyYXdpbmcoKVxuICAgICAgICAvLyBXaGVuIHlvdSBuZWVkIHRvIHN0b3AgYW55IG9uZ29pbmcgZHJhd2luZywgd2l0aG91dCBuZWVkaW5nIHRvIGtub3cgd2hpY2ggZWRpdG9yIGlzIGFjdGl2ZS5cbiAgICAgICAgc3RvcERyYXdpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMudW5yZWdpc3RlckZvckRyYXdpbmcoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyDwn42CbWV0aG9kIGNvbW1pdERyYXdpbmcoKVxuICAgICAgICAvLyBXaGVuIHlvdSBuZWVkIHRvIGNvbW1pdCBhbnkgb25nb2luZyBkcmF3aW5nLCB3aXRob3V0IG5lZWRpbmcgdG8ga25vdyB3aGljaCBlZGl0b3IgaXMgYWN0aXZlLlxuICAgICAgICBjb21taXREcmF3aW5nOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9kcmF3aW5nRWRpdG9yKSByZXR1cm47XG4gICAgICAgICAgICB0aGlzLl9kcmF3aW5nRWRpdG9yLmNvbW1pdERyYXdpbmcoZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY29ubmVjdENyZWF0ZWRUb01hcDogZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mZWF0dXJlc0xheWVyLmFkZExheWVyKGxheWVyKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyDwn42CbWV0aG9kIHN0YXJ0UG9seWxpbmUobGF0bG5nOiBMLkxhdExuZywgb3B0aW9uczogaGFzaCk6IEwuUG9seWxpbmVcbiAgICAgICAgLy8gU3RhcnQgZHJhd2luZyBhIFBvbHlsaW5lLiBJZiBgbGF0bG5nYCBpcyBnaXZlbiwgYSBmaXJzdCBwb2ludCB3aWxsIGJlIGFkZGVkLiBJbiBhbnkgY2FzZSwgY29udGludWluZyBvbiB1c2VyIGNsaWNrLlxuICAgICAgICAvLyBJZiBgb3B0aW9uc2AgaXMgZ2l2ZW4sIGl0IHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBQb2x5bGluZSBjbGFzcyBjb25zdHJ1Y3Rvci5cbiAgICAgICAgc3RhcnRQb2x5bGluZTogZnVuY3Rpb24gKGxhdGxuZywgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIGxpbmUgPSB0aGlzLmNyZWF0ZVBvbHlsaW5lKFtdLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGxpbmUuZW5hYmxlRWRpdCh0aGlzLm1hcCkubmV3U2hhcGUobGF0bG5nKTtcbiAgICAgICAgICAgIHJldHVybiBsaW5lO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIPCfjYJtZXRob2Qgc3RhcnRQb2x5Z29uKGxhdGxuZzogTC5MYXRMbmcsIG9wdGlvbnM6IGhhc2gpOiBMLlBvbHlnb25cbiAgICAgICAgLy8gU3RhcnQgZHJhd2luZyBhIFBvbHlnb24uIElmIGBsYXRsbmdgIGlzIGdpdmVuLCBhIGZpcnN0IHBvaW50IHdpbGwgYmUgYWRkZWQuIEluIGFueSBjYXNlLCBjb250aW51aW5nIG9uIHVzZXIgY2xpY2suXG4gICAgICAgIC8vIElmIGBvcHRpb25zYCBpcyBnaXZlbiwgaXQgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIFBvbHlnb24gY2xhc3MgY29uc3RydWN0b3IuXG4gICAgICAgIHN0YXJ0UG9seWdvbjogZnVuY3Rpb24gKGxhdGxuZywgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIHBvbHlnb24gPSB0aGlzLmNyZWF0ZVBvbHlnb24oW10sIG9wdGlvbnMpO1xuICAgICAgICAgICAgcG9seWdvbi5lbmFibGVFZGl0KHRoaXMubWFwKS5uZXdTaGFwZShsYXRsbmcpO1xuICAgICAgICAgICAgcmV0dXJuIHBvbHlnb247XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8g8J+Ngm1ldGhvZCBzdGFydE1hcmtlcihsYXRsbmc6IEwuTGF0TG5nLCBvcHRpb25zOiBoYXNoKTogTC5NYXJrZXJcbiAgICAgICAgLy8gU3RhcnQgYWRkaW5nIGEgTWFya2VyLiBJZiBgbGF0bG5nYCBpcyBnaXZlbiwgdGhlIE1hcmtlciB3aWxsIGJlIHNob3duIGZpcnN0IGF0IHRoaXMgcG9pbnQuXG4gICAgICAgIC8vIEluIGFueSBjYXNlLCBpdCB3aWxsIGZvbGxvdyB0aGUgdXNlciBtb3VzZSwgYW5kIHdpbGwgaGF2ZSBhIGZpbmFsIGBsYXRsbmdgIG9uIG5leHQgY2xpY2sgKG9yIHRvdWNoKS5cbiAgICAgICAgLy8gSWYgYG9wdGlvbnNgIGlzIGdpdmVuLCBpdCB3aWxsIGJlIHBhc3NlZCB0byB0aGUgTWFya2VyIGNsYXNzIGNvbnN0cnVjdG9yLlxuICAgICAgICBzdGFydE1hcmtlcjogZnVuY3Rpb24gKGxhdGxuZywgb3B0aW9ucykge1xuICAgICAgICAgICAgbGF0bG5nID0gbGF0bG5nIHx8IHRoaXMubWFwLmdldENlbnRlcigpLmNsb25lKCk7XG4gICAgICAgICAgICB2YXIgbWFya2VyID0gdGhpcy5jcmVhdGVNYXJrZXIobGF0bG5nLCBvcHRpb25zKTtcbiAgICAgICAgICAgIG1hcmtlci5lbmFibGVFZGl0KHRoaXMubWFwKS5zdGFydERyYXdpbmcoKTtcbiAgICAgICAgICAgIHJldHVybiBtYXJrZXI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8g8J+Ngm1ldGhvZCBzdGFydFJlY3RhbmdsZShsYXRsbmc6IEwuTGF0TG5nLCBvcHRpb25zOiBoYXNoKTogTC5SZWN0YW5nbGVcbiAgICAgICAgLy8gU3RhcnQgZHJhd2luZyBhIFJlY3RhbmdsZS4gSWYgYGxhdGxuZ2AgaXMgZ2l2ZW4sIHRoZSBSZWN0YW5nbGUgYW5jaG9yIHdpbGwgYmUgYWRkZWQuIEluIGFueSBjYXNlLCBjb250aW51aW5nIG9uIHVzZXIgZHJhZy5cbiAgICAgICAgLy8gSWYgYG9wdGlvbnNgIGlzIGdpdmVuLCBpdCB3aWxsIGJlIHBhc3NlZCB0byB0aGUgUmVjdGFuZ2xlIGNsYXNzIGNvbnN0cnVjdG9yLlxuICAgICAgICBzdGFydFJlY3RhbmdsZTogZnVuY3Rpb24obGF0bG5nLCBvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgY29ybmVyID0gbGF0bG5nIHx8IEwubGF0TG5nKFswLCAwXSk7XG4gICAgICAgICAgICB2YXIgYm91bmRzID0gbmV3IEwuTGF0TG5nQm91bmRzKGNvcm5lciwgY29ybmVyKTtcbiAgICAgICAgICAgIHZhciByZWN0YW5nbGUgPSB0aGlzLmNyZWF0ZVJlY3RhbmdsZShib3VuZHMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgcmVjdGFuZ2xlLmVuYWJsZUVkaXQodGhpcy5tYXApLnN0YXJ0RHJhd2luZygpO1xuICAgICAgICAgICAgcmV0dXJuIHJlY3RhbmdsZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyDwn42CbWV0aG9kIHN0YXJ0Q2lyY2xlKGxhdGxuZzogTC5MYXRMbmcsIG9wdGlvbnM6IGhhc2gpOiBMLkNpcmNsZVxuICAgICAgICAvLyBTdGFydCBkcmF3aW5nIGEgQ2lyY2xlLiBJZiBgbGF0bG5nYCBpcyBnaXZlbiwgdGhlIENpcmNsZSBhbmNob3Igd2lsbCBiZSBhZGRlZC4gSW4gYW55IGNhc2UsIGNvbnRpbnVpbmcgb24gdXNlciBkcmFnLlxuICAgICAgICAvLyBJZiBgb3B0aW9uc2AgaXMgZ2l2ZW4sIGl0IHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBDaXJjbGUgY2xhc3MgY29uc3RydWN0b3IuXG4gICAgICAgIHN0YXJ0Q2lyY2xlOiBmdW5jdGlvbiAobGF0bG5nLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBsYXRsbmcgPSBsYXRsbmcgfHwgdGhpcy5tYXAuZ2V0Q2VudGVyKCkuY2xvbmUoKTtcbiAgICAgICAgICAgIHZhciBjaXJjbGUgPSB0aGlzLmNyZWF0ZUNpcmNsZShsYXRsbmcsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY2lyY2xlLmVuYWJsZUVkaXQodGhpcy5tYXApLnN0YXJ0RHJhd2luZygpO1xuICAgICAgICAgICAgcmV0dXJuIGNpcmNsZTtcbiAgICAgICAgfSxcblxuICAgICAgICBzdGFydEhvbGU6IGZ1bmN0aW9uIChlZGl0b3IsIGxhdGxuZykge1xuICAgICAgICAgICAgZWRpdG9yLm5ld0hvbGUobGF0bG5nKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVMYXllcjogZnVuY3Rpb24gKGtsYXNzLCBsYXRsbmdzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gTC5VdGlsLmV4dGVuZCh7ZWRpdE9wdGlvbnM6IHtlZGl0VG9vbHM6IHRoaXN9fSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSBuZXcga2xhc3MobGF0bG5ncywgb3B0aW9ucyk7XG4gICAgICAgICAgICAvLyDwn42CbmFtZXNwYWNlIEVkaXRhYmxlXG4gICAgICAgICAgICAvLyDwn42CZXZlbnQgZWRpdGFibGU6Y3JlYXRlZDogTGF5ZXJFdmVudFxuICAgICAgICAgICAgLy8gRmlyZWQgd2hlbiBhIG5ldyBmZWF0dXJlIChNYXJrZXIsIFBvbHlsaW5l4oCmKSBpcyBjcmVhdGVkLlxuICAgICAgICAgICAgdGhpcy5maXJlQW5kRm9yd2FyZCgnZWRpdGFibGU6Y3JlYXRlZCcsIHtsYXllcjogbGF5ZXJ9KTtcbiAgICAgICAgICAgIHJldHVybiBsYXllcjtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVQb2x5bGluZTogZnVuY3Rpb24gKGxhdGxuZ3MsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUxheWVyKG9wdGlvbnMgJiYgb3B0aW9ucy5wb2x5bGluZUNsYXNzIHx8IHRoaXMub3B0aW9ucy5wb2x5bGluZUNsYXNzLCBsYXRsbmdzLCBvcHRpb25zKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVQb2x5Z29uOiBmdW5jdGlvbiAobGF0bG5ncywgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlTGF5ZXIob3B0aW9ucyAmJiBvcHRpb25zLnBvbHlnb25DbGFzcyB8fCB0aGlzLm9wdGlvbnMucG9seWdvbkNsYXNzLCBsYXRsbmdzLCBvcHRpb25zKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVNYXJrZXI6IGZ1bmN0aW9uIChsYXRsbmcsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUxheWVyKG9wdGlvbnMgJiYgb3B0aW9ucy5tYXJrZXJDbGFzcyB8fCB0aGlzLm9wdGlvbnMubWFya2VyQ2xhc3MsIGxhdGxuZywgb3B0aW9ucyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlUmVjdGFuZ2xlOiBmdW5jdGlvbiAoYm91bmRzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVMYXllcihvcHRpb25zICYmIG9wdGlvbnMucmVjdGFuZ2xlQ2xhc3MgfHwgdGhpcy5vcHRpb25zLnJlY3RhbmdsZUNsYXNzLCBib3VuZHMsIG9wdGlvbnMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZUNpcmNsZTogZnVuY3Rpb24gKGxhdGxuZywgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlTGF5ZXIob3B0aW9ucyAmJiBvcHRpb25zLmNpcmNsZUNsYXNzIHx8IHRoaXMub3B0aW9ucy5jaXJjbGVDbGFzcywgbGF0bG5nLCBvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICBMLmV4dGVuZChMLkVkaXRhYmxlLCB7XG5cbiAgICAgICAgbWFrZUNhbmNlbGxhYmxlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS5jYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZS5fY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgLy8g8J+Ngm5hbWVzcGFjZSBNYXA7IPCfjYJjbGFzcyBNYXBcbiAgICAvLyBMZWFmbGV0LkVkaXRhYmxlIGFkZCBvcHRpb25zIGFuZCBldmVudHMgdG8gdGhlIGBMLk1hcGAgb2JqZWN0LlxuICAgIC8vIFNlZSBgRWRpdGFibGVgIGV2ZW50cyBmb3IgdGhlIGxpc3Qgb2YgZXZlbnRzIGZpcmVkIG9uIHRoZSBNYXAuXG4gICAgLy8g8J+NgmV4YW1wbGVcbiAgICAvL1xuICAgIC8vIGBgYGpzXG4gICAgLy8gdmFyIG1hcCA9IEwubWFwKCdtYXAnLCB7XG4gICAgLy8gIGVkaXRhYmxlOiB0cnVlLFxuICAgIC8vICBlZGl0T3B0aW9uczoge1xuICAgIC8vICAgIOKAplxuICAgIC8vIH1cbiAgICAvLyB9KTtcbiAgICAvLyBgYGBcbiAgICAvLyDwn42Cc2VjdGlvbiBFZGl0YWJsZSBNYXAgT3B0aW9uc1xuICAgIEwuTWFwLm1lcmdlT3B0aW9ucyh7XG5cbiAgICAgICAgLy8g8J+Ngm5hbWVzcGFjZSBNYXBcbiAgICAgICAgLy8g8J+NgnNlY3Rpb24gTWFwIE9wdGlvbnNcbiAgICAgICAgLy8g8J+Ngm9wdGlvbiBlZGl0VG9vbHNDbGFzczogY2xhc3MgPSBMLkVkaXRhYmxlXG4gICAgICAgIC8vIENsYXNzIHRvIGJlIHVzZWQgYXMgdmVydGV4LCBmb3IgcGF0aCBlZGl0aW5nLlxuICAgICAgICBlZGl0VG9vbHNDbGFzczogTC5FZGl0YWJsZSxcblxuICAgICAgICAvLyDwn42Cb3B0aW9uIGVkaXRhYmxlOiBib29sZWFuID0gZmFsc2VcbiAgICAgICAgLy8gV2hldGhlciB0byBjcmVhdGUgYSBMLkVkaXRhYmxlIGluc3RhbmNlIGF0IG1hcCBpbml0LlxuICAgICAgICBlZGl0YWJsZTogZmFsc2UsXG5cbiAgICAgICAgLy8g8J+Ngm9wdGlvbiBlZGl0T3B0aW9uczogaGFzaCA9IHt9XG4gICAgICAgIC8vIE9wdGlvbnMgdG8gcGFzcyB0byBMLkVkaXRhYmxlIHdoZW4gaW5zdGFudGlhdGluZy5cbiAgICAgICAgZWRpdE9wdGlvbnM6IHt9XG5cbiAgICB9KTtcblxuICAgIEwuTWFwLmFkZEluaXRIb29rKGZ1bmN0aW9uICgpIHtcblxuICAgICAgICB0aGlzLndoZW5SZWFkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmVkaXRhYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lZGl0VG9vbHMgPSBuZXcgdGhpcy5vcHRpb25zLmVkaXRUb29sc0NsYXNzKHRoaXMsIHRoaXMub3B0aW9ucy5lZGl0T3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgfSk7XG5cbiAgICBMLkVkaXRhYmxlLlZlcnRleEljb24gPSBMLkRpdkljb24uZXh0ZW5kKHtcblxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBpY29uU2l6ZTogbmV3IEwuUG9pbnQoOCwgOClcbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICBMLkVkaXRhYmxlLlRvdWNoVmVydGV4SWNvbiA9IEwuRWRpdGFibGUuVmVydGV4SWNvbi5leHRlbmQoe1xuXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIGljb25TaXplOiBuZXcgTC5Qb2ludCgyMCwgMjApXG4gICAgICAgIH1cblxuICAgIH0pO1xuXG5cbiAgICAvLyDwn42CbmFtZXNwYWNlIEVkaXRhYmxlOyDwn42CY2xhc3MgVmVydGV4TWFya2VyOyBIYW5kbGVyIGZvciBkcmFnZ2luZyBwYXRoIHZlcnRpY2VzLlxuICAgIEwuRWRpdGFibGUuVmVydGV4TWFya2VyID0gTC5NYXJrZXIuZXh0ZW5kKHtcblxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBkcmFnZ2FibGU6IHRydWUsXG4gICAgICAgICAgICBjbGFzc05hbWU6ICdsZWFmbGV0LWRpdi1pY29uIGxlYWZsZXQtdmVydGV4LWljb24nXG4gICAgICAgIH0sXG5cblxuICAgICAgICAvLyDwn42Cc2VjdGlvbiBQdWJsaWMgbWV0aG9kc1xuICAgICAgICAvLyBUaGUgbWFya2VyIHVzZWQgdG8gaGFuZGxlIHBhdGggdmVydGV4LiBZb3Ugd2lsbCB1c3VhbGx5IGludGVyYWN0IHdpdGggYSBgVmVydGV4TWFya2VyYFxuICAgICAgICAvLyBpbnN0YW5jZSB3aGVuIGxpc3RlbmluZyBmb3IgZXZlbnRzIGxpa2UgYGVkaXRhYmxlOnZlcnRleDpjdHJsY2xpY2tgLlxuXG4gICAgICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXRsbmcsIGxhdGxuZ3MsIGVkaXRvciwgb3B0aW9ucykge1xuICAgICAgICAgICAgLy8gV2UgZG9uJ3QgdXNlIHRoaXMuX2xhdGxuZywgYmVjYXVzZSBvbiBkcmFnIExlYWZsZXQgcmVwbGFjZSBpdCB3aGlsZVxuICAgICAgICAgICAgLy8gd2Ugd2FudCB0byBrZWVwIHJlZmVyZW5jZS5cbiAgICAgICAgICAgIHRoaXMubGF0bG5nID0gbGF0bG5nO1xuICAgICAgICAgICAgdGhpcy5sYXRsbmdzID0gbGF0bG5ncztcbiAgICAgICAgICAgIHRoaXMuZWRpdG9yID0gZWRpdG9yO1xuICAgICAgICAgICAgTC5NYXJrZXIucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCBsYXRsbmcsIG9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmljb24gPSB0aGlzLmVkaXRvci50b29scy5jcmVhdGVWZXJ0ZXhJY29uKHtjbGFzc05hbWU6IHRoaXMub3B0aW9ucy5jbGFzc05hbWV9KTtcbiAgICAgICAgICAgIHRoaXMubGF0bG5nLl9fdmVydGV4ID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuZWRpdG9yLmVkaXRMYXllci5hZGRMYXllcih0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuc2V0WkluZGV4T2Zmc2V0KGVkaXRvci50b29scy5fbGFzdFpJbmRleCArIDEpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XG4gICAgICAgICAgICBMLk1hcmtlci5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzLCBtYXApO1xuICAgICAgICAgICAgdGhpcy5vbignZHJhZycsIHRoaXMub25EcmFnKTtcbiAgICAgICAgICAgIHRoaXMub24oJ2RyYWdzdGFydCcsIHRoaXMub25EcmFnU3RhcnQpO1xuICAgICAgICAgICAgdGhpcy5vbignZHJhZ2VuZCcsIHRoaXMub25EcmFnRW5kKTtcbiAgICAgICAgICAgIHRoaXMub24oJ21vdXNldXAnLCB0aGlzLm9uTW91c2V1cCk7XG4gICAgICAgICAgICB0aGlzLm9uKCdjbGljaycsIHRoaXMub25DbGljayk7XG4gICAgICAgICAgICB0aGlzLm9uKCdjb250ZXh0bWVudScsIHRoaXMub25Db250ZXh0TWVudSk7XG4gICAgICAgICAgICB0aGlzLm9uKCdtb3VzZWRvd24gdG91Y2hzdGFydCcsIHRoaXMub25Nb3VzZURvd24pO1xuICAgICAgICAgICAgdGhpcy5vbignbW91c2VvdmVyJywgdGhpcy5vbk1vdXNlT3Zlcik7XG4gICAgICAgICAgICB0aGlzLm9uKCdtb3VzZW91dCcsIHRoaXMub25Nb3VzZU91dCk7XG4gICAgICAgICAgICB0aGlzLmFkZE1pZGRsZU1hcmtlcnMoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubWlkZGxlTWFya2VyKSB0aGlzLm1pZGRsZU1hcmtlci5kZWxldGUoKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmxhdGxuZy5fX3ZlcnRleDtcbiAgICAgICAgICAgIHRoaXMub2ZmKCdkcmFnJywgdGhpcy5vbkRyYWcpO1xuICAgICAgICAgICAgdGhpcy5vZmYoJ2RyYWdzdGFydCcsIHRoaXMub25EcmFnU3RhcnQpO1xuICAgICAgICAgICAgdGhpcy5vZmYoJ2RyYWdlbmQnLCB0aGlzLm9uRHJhZ0VuZCk7XG4gICAgICAgICAgICB0aGlzLm9mZignbW91c2V1cCcsIHRoaXMub25Nb3VzZXVwKTtcbiAgICAgICAgICAgIHRoaXMub2ZmKCdjbGljaycsIHRoaXMub25DbGljayk7XG4gICAgICAgICAgICB0aGlzLm9mZignY29udGV4dG1lbnUnLCB0aGlzLm9uQ29udGV4dE1lbnUpO1xuICAgICAgICAgICAgdGhpcy5vZmYoJ21vdXNlZG93biB0b3VjaHN0YXJ0JywgdGhpcy5vbk1vdXNlRG93bik7XG4gICAgICAgICAgICB0aGlzLm9mZignbW91c2VvdmVyJywgdGhpcy5vbk1vdXNlT3Zlcik7XG4gICAgICAgICAgICB0aGlzLm9mZignbW91c2VvdXQnLCB0aGlzLm9uTW91c2VPdXQpO1xuICAgICAgICAgICAgTC5NYXJrZXIucHJvdG90eXBlLm9uUmVtb3ZlLmNhbGwodGhpcywgbWFwKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvbkRyYWc6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLnZlcnRleCA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmVkaXRvci5vblZlcnRleE1hcmtlckRyYWcoZSk7XG4gICAgICAgICAgICB2YXIgaWNvblBvcyA9IEwuRG9tVXRpbC5nZXRQb3NpdGlvbih0aGlzLl9pY29uKSxcbiAgICAgICAgICAgICAgICBsYXRsbmcgPSB0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKGljb25Qb3MpO1xuICAgICAgICAgICAgdGhpcy5sYXRsbmcudXBkYXRlKGxhdGxuZyk7XG4gICAgICAgICAgICB0aGlzLl9sYXRsbmcgPSB0aGlzLmxhdGxuZzsgIC8vIFB1c2ggYmFjayB0byBMZWFmbGV0IG91ciByZWZlcmVuY2UuXG4gICAgICAgICAgICB0aGlzLmVkaXRvci5yZWZyZXNoKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5taWRkbGVNYXJrZXIpIHRoaXMubWlkZGxlTWFya2VyLnVwZGF0ZUxhdExuZygpO1xuICAgICAgICAgICAgdmFyIG5leHQgPSB0aGlzLmdldE5leHQoKTtcbiAgICAgICAgICAgIGlmIChuZXh0ICYmIG5leHQubWlkZGxlTWFya2VyKSBuZXh0Lm1pZGRsZU1hcmtlci51cGRhdGVMYXRMbmcoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvbkRyYWdTdGFydDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUudmVydGV4ID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuZWRpdG9yLm9uVmVydGV4TWFya2VyRHJhZ1N0YXJ0KGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uRHJhZ0VuZDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUudmVydGV4ID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuZWRpdG9yLm9uVmVydGV4TWFya2VyRHJhZ0VuZChlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvbkNsaWNrOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS52ZXJ0ZXggPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5lZGl0b3Iub25WZXJ0ZXhNYXJrZXJDbGljayhlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvbk1vdXNldXA6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBMLkRvbUV2ZW50LnN0b3AoZSk7XG4gICAgICAgICAgICBlLnZlcnRleCA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmVkaXRvci5tYXAuZmlyZSgnbW91c2V1cCcsIGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uQ29udGV4dE1lbnU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLnZlcnRleCA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmVkaXRvci5vblZlcnRleE1hcmtlckNvbnRleHRNZW51KGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uTW91c2VEb3duOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS52ZXJ0ZXggPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5lZGl0b3Iub25WZXJ0ZXhNYXJrZXJNb3VzZURvd24oZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25Nb3VzZU92ZXI6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLnZlcnRleCA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmVkaXRvci5vblZlcnRleE1hcmtlck1vdXNlT3ZlcihlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvbk1vdXNlT3V0OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS52ZXJ0ZXggPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5lZGl0b3Iub25WZXJ0ZXhNYXJrZXJNb3VzZU91dChlKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyDwn42CbWV0aG9kIGRlbGV0ZSgpXG4gICAgICAgIC8vIERlbGV0ZSBhIHZlcnRleCBhbmQgdGhlIHJlbGF0ZWQgTGF0TG5nLlxuICAgICAgICBkZWxldGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBuZXh0ID0gdGhpcy5nZXROZXh0KCk7ICAvLyBDb21wdXRlIGJlZm9yZSBjaGFuZ2luZyBsYXRsbmdcbiAgICAgICAgICAgIHRoaXMubGF0bG5ncy5zcGxpY2UodGhpcy5nZXRJbmRleCgpLCAxKTtcbiAgICAgICAgICAgIHRoaXMuZWRpdG9yLmVkaXRMYXllci5yZW1vdmVMYXllcih0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuZWRpdG9yLm9uVmVydGV4RGVsZXRlZCh7bGF0bG5nOiB0aGlzLmxhdGxuZywgdmVydGV4OiB0aGlzfSk7XG4gICAgICAgICAgICBpZiAoIXRoaXMubGF0bG5ncy5sZW5ndGgpIHRoaXMuZWRpdG9yLmRlbGV0ZVNoYXBlKHRoaXMubGF0bG5ncyk7XG4gICAgICAgICAgICBpZiAobmV4dCkgbmV4dC5yZXNldE1pZGRsZU1hcmtlcigpO1xuICAgICAgICAgICAgdGhpcy5lZGl0b3IucmVmcmVzaCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIPCfjYJtZXRob2QgZ2V0SW5kZXgoKTogaW50XG4gICAgICAgIC8vIEdldCB0aGUgaW5kZXggb2YgdGhlIGN1cnJlbnQgdmVydGV4IGFtb25nIG90aGVycyBvZiB0aGUgc2FtZSBMYXRMbmdzIGdyb3VwLlxuICAgICAgICBnZXRJbmRleDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGF0bG5ncy5pbmRleE9mKHRoaXMubGF0bG5nKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyDwn42CbWV0aG9kIGdldExhc3RJbmRleCgpOiBpbnRcbiAgICAgICAgLy8gR2V0IGxhc3QgdmVydGV4IGluZGV4IG9mIHRoZSBMYXRMbmdzIGdyb3VwIG9mIHRoZSBjdXJyZW50IHZlcnRleC5cbiAgICAgICAgZ2V0TGFzdEluZGV4OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sYXRsbmdzLmxlbmd0aCAtIDE7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8g8J+Ngm1ldGhvZCBnZXRQcmV2aW91cygpOiBWZXJ0ZXhNYXJrZXJcbiAgICAgICAgLy8gR2V0IHRoZSBwcmV2aW91cyBWZXJ0ZXhNYXJrZXIgaW4gdGhlIHNhbWUgTGF0TG5ncyBncm91cC5cbiAgICAgICAgZ2V0UHJldmlvdXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxhdGxuZ3MubGVuZ3RoIDwgMikgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5nZXRJbmRleCgpLFxuICAgICAgICAgICAgICAgIHByZXZpb3VzSW5kZXggPSBpbmRleCAtIDE7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IDAgJiYgdGhpcy5lZGl0b3IuQ0xPU0VEKSBwcmV2aW91c0luZGV4ID0gdGhpcy5nZXRMYXN0SW5kZXgoKTtcbiAgICAgICAgICAgIHZhciBwcmV2aW91cyA9IHRoaXMubGF0bG5nc1twcmV2aW91c0luZGV4XTtcbiAgICAgICAgICAgIGlmIChwcmV2aW91cykgcmV0dXJuIHByZXZpb3VzLl9fdmVydGV4O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIPCfjYJtZXRob2QgZ2V0TmV4dCgpOiBWZXJ0ZXhNYXJrZXJcbiAgICAgICAgLy8gR2V0IHRoZSBuZXh0IFZlcnRleE1hcmtlciBpbiB0aGUgc2FtZSBMYXRMbmdzIGdyb3VwLlxuICAgICAgICBnZXROZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5sYXRsbmdzLmxlbmd0aCA8IDIpIHJldHVybjtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuZ2V0SW5kZXgoKSxcbiAgICAgICAgICAgICAgICBuZXh0SW5kZXggPSBpbmRleCArIDE7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IHRoaXMuZ2V0TGFzdEluZGV4KCkgJiYgdGhpcy5lZGl0b3IuQ0xPU0VEKSBuZXh0SW5kZXggPSAwO1xuICAgICAgICAgICAgdmFyIG5leHQgPSB0aGlzLmxhdGxuZ3NbbmV4dEluZGV4XTtcbiAgICAgICAgICAgIGlmIChuZXh0KSByZXR1cm4gbmV4dC5fX3ZlcnRleDtcbiAgICAgICAgfSxcblxuICAgICAgICBhZGRNaWRkbGVNYXJrZXI6IGZ1bmN0aW9uIChwcmV2aW91cykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmVkaXRvci5oYXNNaWRkbGVNYXJrZXJzKCkpIHJldHVybjtcbiAgICAgICAgICAgIHByZXZpb3VzID0gcHJldmlvdXMgfHwgdGhpcy5nZXRQcmV2aW91cygpO1xuICAgICAgICAgICAgaWYgKHByZXZpb3VzICYmICF0aGlzLm1pZGRsZU1hcmtlcikgdGhpcy5taWRkbGVNYXJrZXIgPSB0aGlzLmVkaXRvci5hZGRNaWRkbGVNYXJrZXIocHJldmlvdXMsIHRoaXMsIHRoaXMubGF0bG5ncywgdGhpcy5lZGl0b3IpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFkZE1pZGRsZU1hcmtlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5lZGl0b3IuaGFzTWlkZGxlTWFya2VycygpKSByZXR1cm47XG4gICAgICAgICAgICB2YXIgcHJldmlvdXMgPSB0aGlzLmdldFByZXZpb3VzKCk7XG4gICAgICAgICAgICBpZiAocHJldmlvdXMpIHRoaXMuYWRkTWlkZGxlTWFya2VyKHByZXZpb3VzKTtcbiAgICAgICAgICAgIHZhciBuZXh0ID0gdGhpcy5nZXROZXh0KCk7XG4gICAgICAgICAgICBpZiAobmV4dCkgbmV4dC5yZXNldE1pZGRsZU1hcmtlcigpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlc2V0TWlkZGxlTWFya2VyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5taWRkbGVNYXJrZXIpIHRoaXMubWlkZGxlTWFya2VyLmRlbGV0ZSgpO1xuICAgICAgICAgICAgdGhpcy5hZGRNaWRkbGVNYXJrZXIoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyDwn42CbWV0aG9kIHNwbGl0KClcbiAgICAgICAgLy8gU3BsaXQgdGhlIHZlcnRleCBMYXRMbmdzIGdyb3VwIGF0IGl0cyBpbmRleCwgaWYgcG9zc2libGUuXG4gICAgICAgIHNwbGl0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZWRpdG9yLnNwbGl0U2hhcGUpIHJldHVybjsgIC8vIE9ubHkgZm9yIFBvbHlsaW5lRWRpdG9yXG4gICAgICAgICAgICB0aGlzLmVkaXRvci5zcGxpdFNoYXBlKHRoaXMubGF0bG5ncywgdGhpcy5nZXRJbmRleCgpKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyDwn42CbWV0aG9kIGNvbnRpbnVlKClcbiAgICAgICAgLy8gQ29udGludWUgdGhlIHZlcnRleCBMYXRMbmdzIGZyb20gdGhpcyB2ZXJ0ZXguIE9ubHkgYWN0aXZlIGZvciBmaXJzdCBhbmQgbGFzdCB2ZXJ0aWNlcyBvZiBhIFBvbHlsaW5lLlxuICAgICAgICBjb250aW51ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmVkaXRvci5jb250aW51ZUJhY2t3YXJkKSByZXR1cm47ICAvLyBPbmx5IGZvciBQb2x5bGluZUVkaXRvclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5nZXRJbmRleCgpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09PSAwKSB0aGlzLmVkaXRvci5jb250aW51ZUJhY2t3YXJkKHRoaXMubGF0bG5ncyk7XG4gICAgICAgICAgICBlbHNlIGlmIChpbmRleCA9PT0gdGhpcy5nZXRMYXN0SW5kZXgoKSkgdGhpcy5lZGl0b3IuY29udGludWVGb3J3YXJkKHRoaXMubGF0bG5ncyk7XG4gICAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgTC5FZGl0YWJsZS5tZXJnZU9wdGlvbnMoe1xuXG4gICAgICAgIC8vIPCfjYJuYW1lc3BhY2UgRWRpdGFibGVcbiAgICAgICAgLy8g8J+Ngm9wdGlvbiB2ZXJ0ZXhNYXJrZXJDbGFzczogY2xhc3MgPSBWZXJ0ZXhNYXJrZXJcbiAgICAgICAgLy8gQ2xhc3MgdG8gYmUgdXNlZCBhcyB2ZXJ0ZXgsIGZvciBwYXRoIGVkaXRpbmcuXG4gICAgICAgIHZlcnRleE1hcmtlckNsYXNzOiBMLkVkaXRhYmxlLlZlcnRleE1hcmtlclxuXG4gICAgfSk7XG5cbiAgICBMLkVkaXRhYmxlLk1pZGRsZU1hcmtlciA9IEwuTWFya2VyLmV4dGVuZCh7XG5cbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgb3BhY2l0eTogMC41LFxuICAgICAgICAgICAgY2xhc3NOYW1lOiAnbGVhZmxldC1kaXYtaWNvbiBsZWFmbGV0LW1pZGRsZS1pY29uJyxcbiAgICAgICAgICAgIGRyYWdnYWJsZTogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIChsZWZ0LCByaWdodCwgbGF0bG5ncywgZWRpdG9yLCBvcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgICAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xuICAgICAgICAgICAgdGhpcy5lZGl0b3IgPSBlZGl0b3I7XG4gICAgICAgICAgICB0aGlzLmxhdGxuZ3MgPSBsYXRsbmdzO1xuICAgICAgICAgICAgTC5NYXJrZXIucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCB0aGlzLmNvbXB1dGVMYXRMbmcoKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLl9vcGFjaXR5ID0gdGhpcy5vcHRpb25zLm9wYWNpdHk7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuaWNvbiA9IHRoaXMuZWRpdG9yLnRvb2xzLmNyZWF0ZVZlcnRleEljb24oe2NsYXNzTmFtZTogdGhpcy5vcHRpb25zLmNsYXNzTmFtZX0pO1xuICAgICAgICAgICAgdGhpcy5lZGl0b3IuZWRpdExheWVyLmFkZExheWVyKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5zZXRWaXNpYmlsaXR5KCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0VmlzaWJpbGl0eTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGxlZnRQb2ludCA9IHRoaXMuX21hcC5sYXRMbmdUb0NvbnRhaW5lclBvaW50KHRoaXMubGVmdC5sYXRsbmcpLFxuICAgICAgICAgICAgICAgIHJpZ2h0UG9pbnQgPSB0aGlzLl9tYXAubGF0TG5nVG9Db250YWluZXJQb2ludCh0aGlzLnJpZ2h0LmxhdGxuZyksXG4gICAgICAgICAgICAgICAgc2l6ZSA9IEwucG9pbnQodGhpcy5vcHRpb25zLmljb24ub3B0aW9ucy5pY29uU2l6ZSk7XG4gICAgICAgICAgICBpZiAobGVmdFBvaW50LmRpc3RhbmNlVG8ocmlnaHRQb2ludCkgPCBzaXplLnggKiAzKSB0aGlzLmhpZGUoKTtcbiAgICAgICAgICAgIGVsc2UgdGhpcy5zaG93KCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2hvdzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5zZXRPcGFjaXR5KHRoaXMuX29wYWNpdHkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhpZGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0T3BhY2l0eSgwKTtcbiAgICAgICAgfSxcblxuICAgICAgICB1cGRhdGVMYXRMbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0TGF0TG5nKHRoaXMuY29tcHV0ZUxhdExuZygpKTtcbiAgICAgICAgICAgIHRoaXMuc2V0VmlzaWJpbGl0eSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNvbXB1dGVMYXRMbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBsZWZ0UG9pbnQgPSB0aGlzLmVkaXRvci5tYXAubGF0TG5nVG9Db250YWluZXJQb2ludCh0aGlzLmxlZnQubGF0bG5nKSxcbiAgICAgICAgICAgICAgICByaWdodFBvaW50ID0gdGhpcy5lZGl0b3IubWFwLmxhdExuZ1RvQ29udGFpbmVyUG9pbnQodGhpcy5yaWdodC5sYXRsbmcpLFxuICAgICAgICAgICAgICAgIHkgPSAobGVmdFBvaW50LnkgKyByaWdodFBvaW50LnkpIC8gMixcbiAgICAgICAgICAgICAgICB4ID0gKGxlZnRQb2ludC54ICsgcmlnaHRQb2ludC54KSAvIDI7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lZGl0b3IubWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcoW3gsIHldKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xuICAgICAgICAgICAgTC5NYXJrZXIucHJvdG90eXBlLm9uQWRkLmNhbGwodGhpcywgbWFwKTtcbiAgICAgICAgICAgIEwuRG9tRXZlbnQub24odGhpcy5faWNvbiwgJ21vdXNlZG93biB0b3VjaHN0YXJ0JywgdGhpcy5vbk1vdXNlRG93biwgdGhpcyk7XG4gICAgICAgICAgICBtYXAub24oJ3pvb21lbmQnLCB0aGlzLnNldFZpc2liaWxpdHksIHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5yaWdodC5taWRkbGVNYXJrZXI7XG4gICAgICAgICAgICBMLkRvbUV2ZW50Lm9mZih0aGlzLl9pY29uLCAnbW91c2Vkb3duIHRvdWNoc3RhcnQnLCB0aGlzLm9uTW91c2VEb3duLCB0aGlzKTtcbiAgICAgICAgICAgIG1hcC5vZmYoJ3pvb21lbmQnLCB0aGlzLnNldFZpc2liaWxpdHksIHRoaXMpO1xuICAgICAgICAgICAgTC5NYXJrZXIucHJvdG90eXBlLm9uUmVtb3ZlLmNhbGwodGhpcywgbWFwKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvbk1vdXNlRG93bjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciBpY29uUG9zID0gTC5Eb21VdGlsLmdldFBvc2l0aW9uKHRoaXMuX2ljb24pLFxuICAgICAgICAgICAgICAgIGxhdGxuZyA9IHRoaXMuZWRpdG9yLm1hcC5sYXllclBvaW50VG9MYXRMbmcoaWNvblBvcyk7XG4gICAgICAgICAgICBlID0ge1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgICAgICAgICAgbGF0bG5nOiBsYXRsbmdcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLm9wYWNpdHkgPT09IDApIHJldHVybjtcbiAgICAgICAgICAgIEwuRWRpdGFibGUubWFrZUNhbmNlbGxhYmxlKGUpO1xuICAgICAgICAgICAgdGhpcy5lZGl0b3Iub25NaWRkbGVNYXJrZXJNb3VzZURvd24oZSk7XG4gICAgICAgICAgICBpZiAoZS5fY2FuY2VsbGVkKSByZXR1cm47XG4gICAgICAgICAgICB0aGlzLmxhdGxuZ3Muc3BsaWNlKHRoaXMuaW5kZXgoKSwgMCwgZS5sYXRsbmcpO1xuICAgICAgICAgICAgdGhpcy5lZGl0b3IucmVmcmVzaCgpO1xuICAgICAgICAgICAgdmFyIGljb24gPSB0aGlzLl9pY29uO1xuICAgICAgICAgICAgdmFyIG1hcmtlciA9IHRoaXMuZWRpdG9yLmFkZFZlcnRleE1hcmtlcihlLmxhdGxuZywgdGhpcy5sYXRsbmdzKTtcbiAgICAgICAgICAgIHRoaXMuZWRpdG9yLm9uTmV3VmVydGV4KG1hcmtlcik7XG4gICAgICAgICAgICAvKiBIYWNrIHRvIHdvcmthcm91bmQgYnJvd3NlciBub3QgZmlyaW5nIHRvdWNoZW5kIHdoZW4gZWxlbWVudCBpcyBubyBtb3JlIG9uIERPTSAqL1xuICAgICAgICAgICAgdmFyIHBhcmVudCA9IG1hcmtlci5faWNvbi5wYXJlbnROb2RlO1xuICAgICAgICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKG1hcmtlci5faWNvbik7XG4gICAgICAgICAgICBtYXJrZXIuX2ljb24gPSBpY29uO1xuICAgICAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKG1hcmtlci5faWNvbik7XG4gICAgICAgICAgICBtYXJrZXIuX2luaXRJY29uKCk7XG4gICAgICAgICAgICBtYXJrZXIuX2luaXRJbnRlcmFjdGlvbigpO1xuICAgICAgICAgICAgbWFya2VyLnNldE9wYWNpdHkoMSk7XG4gICAgICAgICAgICAvKiBFbmQgaGFjayAqL1xuICAgICAgICAgICAgLy8gVHJhbnNmZXIgb25nb2luZyBkcmFnZ2luZyB0byByZWFsIG1hcmtlclxuICAgICAgICAgICAgTC5EcmFnZ2FibGUuX2RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBtYXJrZXIuZHJhZ2dpbmcuX2RyYWdnYWJsZS5fb25Eb3duKGUub3JpZ2luYWxFdmVudCk7XG4gICAgICAgICAgICB0aGlzLmRlbGV0ZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRlbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5lZGl0b3IuZWRpdExheWVyLnJlbW92ZUxheWVyKHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGluZGV4OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sYXRsbmdzLmluZGV4T2YodGhpcy5yaWdodC5sYXRsbmcpO1xuICAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIEwuRWRpdGFibGUubWVyZ2VPcHRpb25zKHtcblxuICAgICAgICAvLyDwn42CbmFtZXNwYWNlIEVkaXRhYmxlXG4gICAgICAgIC8vIPCfjYJvcHRpb24gbWlkZGxlTWFya2VyQ2xhc3M6IGNsYXNzID0gVmVydGV4TWFya2VyXG4gICAgICAgIC8vIENsYXNzIHRvIGJlIHVzZWQgYXMgbWlkZGxlIHZlcnRleCwgcHVsbGVkIGJ5IHRoZSB1c2VyIHRvIGNyZWF0ZSBhIG5ldyBwb2ludCBpbiB0aGUgbWlkZGxlIG9mIGEgcGF0aC5cbiAgICAgICAgbWlkZGxlTWFya2VyQ2xhc3M6IEwuRWRpdGFibGUuTWlkZGxlTWFya2VyXG5cbiAgICB9KTtcblxuICAgIC8vIPCfjYJuYW1lc3BhY2UgRWRpdGFibGU7IPCfjYJjbGFzcyBCYXNlRWRpdG9yOyDwn42CYWthIEwuRWRpdGFibGUuQmFzZUVkaXRvclxuICAgIC8vIFdoZW4gZWRpdGluZyBhIGZlYXR1cmUgKE1hcmtlciwgUG9seWxpbmXigKYpLCBhbiBlZGl0b3IgaXMgYXR0YWNoZWQgdG8gaXQuIFRoaXNcbiAgICAvLyBlZGl0b3IgYmFzaWNhbGx5IGtub3dzIGhvdyB0byBoYW5kbGUgdGhlIGVkaXRpb24uXG4gICAgTC5FZGl0YWJsZS5CYXNlRWRpdG9yID0gTC5IYW5kbGVyLmV4dGVuZCh7XG5cbiAgICAgICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcCwgZmVhdHVyZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgTC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5tYXAgPSBtYXA7XG4gICAgICAgICAgICB0aGlzLmZlYXR1cmUgPSBmZWF0dXJlO1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlLmVkaXRvciA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmVkaXRMYXllciA9IG5ldyBMLkxheWVyR3JvdXAoKTtcbiAgICAgICAgICAgIHRoaXMudG9vbHMgPSB0aGlzLm9wdGlvbnMuZWRpdFRvb2xzIHx8IG1hcC5lZGl0VG9vbHM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8g8J+Ngm1ldGhvZCBlbmFibGUoKTogdGhpc1xuICAgICAgICAvLyBTZXQgdXAgdGhlIGRyYXdpbmcgdG9vbHMgZm9yIHRoZSBmZWF0dXJlIHRvIGJlIGVkaXRhYmxlLlxuICAgICAgICBhZGRIb29rczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNDb25uZWN0ZWQoKSkgdGhpcy5vbkZlYXR1cmVBZGQoKTtcbiAgICAgICAgICAgIGVsc2UgdGhpcy5mZWF0dXJlLm9uY2UoJ2FkZCcsIHRoaXMub25GZWF0dXJlQWRkLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMub25FbmFibGUoKTtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZS5vbih0aGlzLl9nZXRFdmVudHMoKSwgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8g8J+Ngm1ldGhvZCBkaXNhYmxlKCk6IHRoaXNcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBkcmF3aW5nIHRvb2xzIGZvciB0aGUgZmVhdHVyZS5cbiAgICAgICAgcmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZS5vZmYodGhpcy5fZ2V0RXZlbnRzKCksIHRoaXMpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZmVhdHVyZS5kcmFnZ2luZykgdGhpcy5mZWF0dXJlLmRyYWdnaW5nLmRpc2FibGUoKTtcbiAgICAgICAgICAgIHRoaXMuZWRpdExheWVyLmNsZWFyTGF5ZXJzKCk7XG4gICAgICAgICAgICB0aGlzLnRvb2xzLmVkaXRMYXllci5yZW1vdmVMYXllcih0aGlzLmVkaXRMYXllcik7XG4gICAgICAgICAgICB0aGlzLm9uRGlzYWJsZSgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2RyYXdpbmcpIHRoaXMuY2FuY2VsRHJhd2luZygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIPCfjYJtZXRob2QgZHJhd2luZygpOiBib29sZWFuXG4gICAgICAgIC8vIFJldHVybiB0cnVlIGlmIGFueSBkcmF3aW5nIGFjdGlvbiBpcyBvbmdvaW5nIHdpdGggdGhpcyBlZGl0b3IuXG4gICAgICAgIGRyYXdpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAhIXRoaXMuX2RyYXdpbmc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uICgpIHt9LFxuXG4gICAgICAgIG9uRmVhdHVyZUFkZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy50b29scy5lZGl0TGF5ZXIuYWRkTGF5ZXIodGhpcy5lZGl0TGF5ZXIpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZmVhdHVyZS5kcmFnZ2luZykgdGhpcy5mZWF0dXJlLmRyYWdnaW5nLmVuYWJsZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhc01pZGRsZU1hcmtlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAhdGhpcy5vcHRpb25zLnNraXBNaWRkbGVNYXJrZXJzICYmICF0aGlzLnRvb2xzLm9wdGlvbnMuc2tpcE1pZGRsZU1hcmtlcnM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmlyZUFuZEZvcndhcmQ6IGZ1bmN0aW9uICh0eXBlLCBlKSB7XG4gICAgICAgICAgICBlID0gZSB8fCB7fTtcbiAgICAgICAgICAgIGUubGF5ZXIgPSB0aGlzLmZlYXR1cmU7XG4gICAgICAgICAgICB0aGlzLmZlYXR1cmUuZmlyZSh0eXBlLCBlKTtcbiAgICAgICAgICAgIHRoaXMudG9vbHMuZmlyZUFuZEZvcndhcmQodHlwZSwgZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25FbmFibGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIPCfjYJuYW1lc3BhY2UgRWRpdGFibGVcbiAgICAgICAgICAgIC8vIPCfjYJldmVudCBlZGl0YWJsZTplbmFibGU6IEV2ZW50XG4gICAgICAgICAgICAvLyBGaXJlZCB3aGVuIGFuIGV4aXN0aW5nIGZlYXR1cmUgaXMgcmVhZHkgdG8gYmUgZWRpdGVkLlxuICAgICAgICAgICAgdGhpcy5maXJlQW5kRm9yd2FyZCgnZWRpdGFibGU6ZW5hYmxlJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25EaXNhYmxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyDwn42CbmFtZXNwYWNlIEVkaXRhYmxlXG4gICAgICAgICAgICAvLyDwn42CZXZlbnQgZWRpdGFibGU6ZGlzYWJsZTogRXZlbnRcbiAgICAgICAgICAgIC8vIEZpcmVkIHdoZW4gYW4gZXhpc3RpbmcgZmVhdHVyZSBpcyBub3QgcmVhZHkgYW55bW9yZSB0byBiZSBlZGl0ZWQuXG4gICAgICAgICAgICB0aGlzLmZpcmVBbmRGb3J3YXJkKCdlZGl0YWJsZTpkaXNhYmxlJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25FZGl0aW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyDwn42CbmFtZXNwYWNlIEVkaXRhYmxlXG4gICAgICAgICAgICAvLyDwn42CZXZlbnQgZWRpdGFibGU6ZWRpdGluZzogRXZlbnRcbiAgICAgICAgICAgIC8vIEZpcmVkIGFzIHNvb24gYXMgYW55IGNoYW5nZSBpcyBtYWRlIHRvIHRoZSBmZWF0dXJlIGdlb21ldHJ5LlxuICAgICAgICAgICAgdGhpcy5maXJlQW5kRm9yd2FyZCgnZWRpdGFibGU6ZWRpdGluZycpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uU3RhcnREcmF3aW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyDwn42CbmFtZXNwYWNlIEVkaXRhYmxlXG4gICAgICAgICAgICAvLyDwn42Cc2VjdGlvbiBEcmF3aW5nIGV2ZW50c1xuICAgICAgICAgICAgLy8g8J+NgmV2ZW50IGVkaXRhYmxlOmRyYXdpbmc6c3RhcnQ6IEV2ZW50XG4gICAgICAgICAgICAvLyBGaXJlZCB3aGVuIGEgZmVhdHVyZSBpcyB0byBiZSBkcmF3bi5cbiAgICAgICAgICAgIHRoaXMuZmlyZUFuZEZvcndhcmQoJ2VkaXRhYmxlOmRyYXdpbmc6c3RhcnQnKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvbkVuZERyYXdpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIPCfjYJuYW1lc3BhY2UgRWRpdGFibGVcbiAgICAgICAgICAgIC8vIPCfjYJzZWN0aW9uIERyYXdpbmcgZXZlbnRzXG4gICAgICAgICAgICAvLyDwn42CZXZlbnQgZWRpdGFibGU6ZHJhd2luZzplbmQ6IEV2ZW50XG4gICAgICAgICAgICAvLyBGaXJlZCB3aGVuIGEgZmVhdHVyZSBpcyBub3QgZHJhd24gYW55bW9yZS5cbiAgICAgICAgICAgIHRoaXMuZmlyZUFuZEZvcndhcmQoJ2VkaXRhYmxlOmRyYXdpbmc6ZW5kJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25DYW5jZWxEcmF3aW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyDwn42CbmFtZXNwYWNlIEVkaXRhYmxlXG4gICAgICAgICAgICAvLyDwn42Cc2VjdGlvbiBEcmF3aW5nIGV2ZW50c1xuICAgICAgICAgICAgLy8g8J+NgmV2ZW50IGVkaXRhYmxlOmRyYXdpbmc6Y2FuY2VsOiBFdmVudFxuICAgICAgICAgICAgLy8gRmlyZWQgd2hlbiB1c2VyIGNhbmNlbCBkcmF3aW5nIHdoaWxlIGEgZmVhdHVyZSBpcyBiZWluZyBkcmF3bi5cbiAgICAgICAgICAgIHRoaXMuZmlyZUFuZEZvcndhcmQoJ2VkaXRhYmxlOmRyYXdpbmc6Y2FuY2VsJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25Db21taXREcmF3aW5nOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgLy8g8J+Ngm5hbWVzcGFjZSBFZGl0YWJsZVxuICAgICAgICAgICAgLy8g8J+NgnNlY3Rpb24gRHJhd2luZyBldmVudHNcbiAgICAgICAgICAgIC8vIPCfjYJldmVudCBlZGl0YWJsZTpkcmF3aW5nOmNvbW1pdDogRXZlbnRcbiAgICAgICAgICAgIC8vIEZpcmVkIHdoZW4gdXNlciBmaW5pc2ggZHJhd2luZyBhIGZlYXR1cmUuXG4gICAgICAgICAgICB0aGlzLmZpcmVBbmRGb3J3YXJkKCdlZGl0YWJsZTpkcmF3aW5nOmNvbW1pdCcsIGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uRHJhd2luZ01vdXNlRG93bjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIC8vIPCfjYJuYW1lc3BhY2UgRWRpdGFibGVcbiAgICAgICAgICAgIC8vIPCfjYJzZWN0aW9uIERyYXdpbmcgZXZlbnRzXG4gICAgICAgICAgICAvLyDwn42CZXZlbnQgZWRpdGFibGU6ZHJhd2luZzptb3VzZWRvd246IEV2ZW50XG4gICAgICAgICAgICAvLyBGaXJlZCB3aGVuIHVzZXIgYG1vdXNlZG93bmAgd2hpbGUgZHJhd2luZy5cbiAgICAgICAgICAgIHRoaXMuZmlyZUFuZEZvcndhcmQoJ2VkaXRhYmxlOmRyYXdpbmc6bW91c2Vkb3duJywgZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25EcmF3aW5nTW91c2VVcDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIC8vIPCfjYJuYW1lc3BhY2UgRWRpdGFibGVcbiAgICAgICAgICAgIC8vIPCfjYJzZWN0aW9uIERyYXdpbmcgZXZlbnRzXG4gICAgICAgICAgICAvLyDwn42CZXZlbnQgZWRpdGFibGU6ZHJhd2luZzptb3VzZXVwOiBFdmVudFxuICAgICAgICAgICAgLy8gRmlyZWQgd2hlbiB1c2VyIGBtb3VzZXVwYCB3aGlsZSBkcmF3aW5nLlxuICAgICAgICAgICAgdGhpcy5maXJlQW5kRm9yd2FyZCgnZWRpdGFibGU6ZHJhd2luZzptb3VzZXVwJywgZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc3RhcnREcmF3aW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2RyYXdpbmcpIHRoaXMuX2RyYXdpbmcgPSBMLkVkaXRhYmxlLkZPUldBUkQ7XG4gICAgICAgICAgICB0aGlzLnRvb2xzLnJlZ2lzdGVyRm9yRHJhd2luZyh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMub25TdGFydERyYXdpbmcoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjb21taXREcmF3aW5nOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdGhpcy5vbkNvbW1pdERyYXdpbmcoZSk7XG4gICAgICAgICAgICB0aGlzLmVuZERyYXdpbmcoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjYW5jZWxEcmF3aW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBJZiBjYWxsZWQgZHVyaW5nIGEgdmVydGV4IGRyYWcsIHRoZSB2ZXJ0ZXggd2lsbCBiZSByZW1vdmVkIGJlZm9yZVxuICAgICAgICAgICAgLy8gdGhlIG1vdXNldXAgZmlyZXMgb24gaXQuIFRoaXMgaXMgYSB3b3JrYXJvdW5kLiBNYXliZSBiZXR0ZXIgZml4IGlzXG4gICAgICAgICAgICAvLyBUbyBoYXZlIEwuRHJhZ2dhYmxlIHJlc2V0IGl0J3Mgc3RhdHVzIG9uIGRpc2FibGUgKExlYWZsZXQgc2lkZSkuXG4gICAgICAgICAgICBMLkRyYWdnYWJsZS5fZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMub25DYW5jZWxEcmF3aW5nKCk7XG4gICAgICAgICAgICB0aGlzLmVuZERyYXdpbmcoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBlbmREcmF3aW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9kcmF3aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnRvb2xzLnVucmVnaXN0ZXJGb3JEcmF3aW5nKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5vbkVuZERyYXdpbmcoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvbkRyYXdpbmdDbGljazogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5kcmF3aW5nKCkpIHJldHVybjtcbiAgICAgICAgICAgIEwuRWRpdGFibGUubWFrZUNhbmNlbGxhYmxlKGUpO1xuICAgICAgICAgICAgLy8g8J+Ngm5hbWVzcGFjZSBFZGl0YWJsZVxuICAgICAgICAgICAgLy8g8J+NgnNlY3Rpb24gRHJhd2luZyBldmVudHNcbiAgICAgICAgICAgIC8vIPCfjYJldmVudCBlZGl0YWJsZTpkcmF3aW5nOmNsaWNrOiBDYW5jZWxhYmxlRXZlbnRcbiAgICAgICAgICAgIC8vIEZpcmVkIHdoZW4gdXNlciBgY2xpY2tgIHdoaWxlIGRyYXdpbmcsIGJlZm9yZSBhbnkgaW50ZXJuYWwgYWN0aW9uIGlzIGJlaW5nIHByb2Nlc3NlZC5cbiAgICAgICAgICAgIHRoaXMuZmlyZUFuZEZvcndhcmQoJ2VkaXRhYmxlOmRyYXdpbmc6Y2xpY2snLCBlKTtcbiAgICAgICAgICAgIGlmIChlLl9jYW5jZWxsZWQpIHJldHVybjtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0Nvbm5lY3RlZCgpKSB0aGlzLmNvbm5lY3QoZSk7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NEcmF3aW5nQ2xpY2soZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNDb25uZWN0ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hcC5oYXNMYXllcih0aGlzLmZlYXR1cmUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNvbm5lY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMudG9vbHMuY29ubmVjdENyZWF0ZWRUb01hcCh0aGlzLmZlYXR1cmUpO1xuICAgICAgICAgICAgdGhpcy50b29scy5lZGl0TGF5ZXIuYWRkTGF5ZXIodGhpcy5lZGl0TGF5ZXIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uTW92ZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIC8vIPCfjYJuYW1lc3BhY2UgRWRpdGFibGVcbiAgICAgICAgICAgIC8vIPCfjYJzZWN0aW9uIERyYXdpbmcgZXZlbnRzXG4gICAgICAgICAgICAvLyDwn42CZXZlbnQgZWRpdGFibGU6ZHJhd2luZzptb3ZlOiBFdmVudFxuICAgICAgICAgICAgLy8gRmlyZWQgd2hlbiBgbW92ZWAgbW91c2Ugd2hpbGUgZHJhd2luZywgd2hpbGUgZHJhZ2dpbmcgYSBtYXJrZXIsIGFuZCB3aGlsZSBkcmFnZ2luZyBhIHZlcnRleC5cbiAgICAgICAgICAgIHRoaXMuZmlyZUFuZEZvcndhcmQoJ2VkaXRhYmxlOmRyYXdpbmc6bW92ZScsIGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uRHJhd2luZ01vdXNlTW92ZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHRoaXMub25Nb3ZlKGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9nZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZHJhZ3N0YXJ0OiB0aGlzLm9uRHJhZ1N0YXJ0LFxuICAgICAgICAgICAgICAgIGRyYWc6IHRoaXMub25EcmFnLFxuICAgICAgICAgICAgICAgIGRyYWdlbmQ6IHRoaXMub25EcmFnRW5kLFxuICAgICAgICAgICAgICAgIHJlbW92ZTogdGhpcy5kaXNhYmxlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uRHJhZ1N0YXJ0OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdGhpcy5vbkVkaXRpbmcoKTtcbiAgICAgICAgICAgIC8vIPCfjYJuYW1lc3BhY2UgRWRpdGFibGVcbiAgICAgICAgICAgIC8vIPCfjYJldmVudCBlZGl0YWJsZTpkcmFnc3RhcnQ6IEV2ZW50XG4gICAgICAgICAgICAvLyBGaXJlZCBiZWZvcmUgYSBwYXRoIGZlYXR1cmUgaXMgZHJhZ2dlZC5cbiAgICAgICAgICAgIHRoaXMuZmlyZUFuZEZvcndhcmQoJ2VkaXRhYmxlOmRyYWdzdGFydCcsIGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uRHJhZzogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHRoaXMub25Nb3ZlKGUpO1xuICAgICAgICAgICAgLy8g8J+Ngm5hbWVzcGFjZSBFZGl0YWJsZVxuICAgICAgICAgICAgLy8g8J+NgmV2ZW50IGVkaXRhYmxlOmRyYWc6IEV2ZW50XG4gICAgICAgICAgICAvLyBGaXJlZCB3aGVuIGEgcGF0aCBmZWF0dXJlIGlzIGJlaW5nIGRyYWdnZWQuXG4gICAgICAgICAgICB0aGlzLmZpcmVBbmRGb3J3YXJkKCdlZGl0YWJsZTpkcmFnJywgZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25EcmFnRW5kOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgLy8g8J+Ngm5hbWVzcGFjZSBFZGl0YWJsZVxuICAgICAgICAgICAgLy8g8J+NgmV2ZW50IGVkaXRhYmxlOmRyYWdlbmQ6IEV2ZW50XG4gICAgICAgICAgICAvLyBGaXJlZCBhZnRlciBhIHBhdGggZmVhdHVyZSBoYXMgYmVlbiBkcmFnZ2VkLlxuICAgICAgICAgICAgdGhpcy5maXJlQW5kRm9yd2FyZCgnZWRpdGFibGU6ZHJhZ2VuZCcsIGUpO1xuICAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIC8vIPCfjYJuYW1lc3BhY2UgRWRpdGFibGU7IPCfjYJjbGFzcyBNYXJrZXJFZGl0b3I7IPCfjYJha2EgTC5FZGl0YWJsZS5NYXJrZXJFZGl0b3JcbiAgICAvLyDwn42CaW5oZXJpdHMgQmFzZUVkaXRvclxuICAgIC8vIEVkaXRvciBmb3IgTWFya2VyLlxuICAgIEwuRWRpdGFibGUuTWFya2VyRWRpdG9yID0gTC5FZGl0YWJsZS5CYXNlRWRpdG9yLmV4dGVuZCh7XG5cbiAgICAgICAgb25EcmF3aW5nTW91c2VNb3ZlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgTC5FZGl0YWJsZS5CYXNlRWRpdG9yLnByb3RvdHlwZS5vbkRyYXdpbmdNb3VzZU1vdmUuY2FsbCh0aGlzLCBlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9kcmF3aW5nKSB0aGlzLmZlYXR1cmUuc2V0TGF0TG5nKGUubGF0bG5nKTtcbiAgICAgICAgfSxcblxuICAgICAgICBwcm9jZXNzRHJhd2luZ0NsaWNrOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgLy8g8J+Ngm5hbWVzcGFjZSBFZGl0YWJsZVxuICAgICAgICAgICAgLy8g8J+NgnNlY3Rpb24gRHJhd2luZyBldmVudHNcbiAgICAgICAgICAgIC8vIPCfjYJldmVudCBlZGl0YWJsZTpkcmF3aW5nOmNsaWNrZWQ6IEV2ZW50XG4gICAgICAgICAgICAvLyBGaXJlZCB3aGVuIHVzZXIgYGNsaWNrYCB3aGlsZSBkcmF3aW5nLCBhZnRlciBhbGwgaW50ZXJuYWwgYWN0aW9ucy5cbiAgICAgICAgICAgIHRoaXMuZmlyZUFuZEZvcndhcmQoJ2VkaXRhYmxlOmRyYXdpbmc6Y2xpY2tlZCcsIGUpO1xuICAgICAgICAgICAgdGhpcy5jb21taXREcmF3aW5nKGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNvbm5lY3Q6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAvLyBPbiB0b3VjaCwgdGhlIGxhdGxuZyBoYXMgbm90IGJlZW4gdXBkYXRlZCBiZWNhdXNlIHRoZXJlIGlzXG4gICAgICAgICAgICAvLyBubyBtb3VzZW1vdmUuXG4gICAgICAgICAgICBpZiAoZSkgdGhpcy5mZWF0dXJlLl9sYXRsbmcgPSBlLmxhdGxuZztcbiAgICAgICAgICAgIEwuRWRpdGFibGUuQmFzZUVkaXRvci5wcm90b3R5cGUuY29ubmVjdC5jYWxsKHRoaXMsIGUpO1xuICAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIC8vIPCfjYJuYW1lc3BhY2UgRWRpdGFibGU7IPCfjYJjbGFzcyBQYXRoRWRpdG9yOyDwn42CYWthIEwuRWRpdGFibGUuUGF0aEVkaXRvclxuICAgIC8vIPCfjYJpbmhlcml0cyBCYXNlRWRpdG9yXG4gICAgLy8gQmFzZSBjbGFzcyBmb3IgYWxsIHBhdGggZWRpdG9ycy5cbiAgICBMLkVkaXRhYmxlLlBhdGhFZGl0b3IgPSBMLkVkaXRhYmxlLkJhc2VFZGl0b3IuZXh0ZW5kKHtcblxuICAgICAgICBDTE9TRUQ6IGZhbHNlLFxuICAgICAgICBNSU5fVkVSVEVYOiAyLFxuXG4gICAgICAgIGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBMLkVkaXRhYmxlLkJhc2VFZGl0b3IucHJvdG90eXBlLmFkZEhvb2tzLmNhbGwodGhpcyk7XG4gICAgICAgICAgICBpZiAodGhpcy5mZWF0dXJlKSB0aGlzLmluaXRWZXJ0ZXhNYXJrZXJzKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBpbml0VmVydGV4TWFya2VyczogZnVuY3Rpb24gKGxhdGxuZ3MpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5lbmFibGVkKCkpIHJldHVybjtcbiAgICAgICAgICAgIGxhdGxuZ3MgPSBsYXRsbmdzIHx8IHRoaXMuZ2V0TGF0TG5ncygpO1xuICAgICAgICAgICAgaWYgKGlzRmxhdChsYXRsbmdzKSkgdGhpcy5hZGRWZXJ0ZXhNYXJrZXJzKGxhdGxuZ3MpO1xuICAgICAgICAgICAgZWxzZSBmb3IgKHZhciBpID0gMDsgaSA8IGxhdGxuZ3MubGVuZ3RoOyBpKyspIHRoaXMuaW5pdFZlcnRleE1hcmtlcnMobGF0bG5nc1tpXSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0TGF0TG5nczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmVhdHVyZS5nZXRMYXRMbmdzKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8g8J+Ngm1ldGhvZCByZXNldCgpXG4gICAgICAgIC8vIFJlYnVpbGQgZWRpdCBlbGVtZW50cyAoVmVydGV4LCBNaWRkbGVNYXJrZXIsIGV0Yy4pLlxuICAgICAgICByZXNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5lZGl0TGF5ZXIuY2xlYXJMYXllcnMoKTtcbiAgICAgICAgICAgIHRoaXMuaW5pdFZlcnRleE1hcmtlcnMoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBhZGRWZXJ0ZXhNYXJrZXI6IGZ1bmN0aW9uIChsYXRsbmcsIGxhdGxuZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgdGhpcy50b29scy5vcHRpb25zLnZlcnRleE1hcmtlckNsYXNzKGxhdGxuZywgbGF0bG5ncywgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25OZXdWZXJ0ZXg6IGZ1bmN0aW9uICh2ZXJ0ZXgpIHtcbiAgICAgICAgICAgIC8vIPCfjYJuYW1lc3BhY2UgRWRpdGFibGVcbiAgICAgICAgICAgIC8vIPCfjYJzZWN0aW9uIFZlcnRleCBldmVudHNcbiAgICAgICAgICAgIC8vIPCfjYJldmVudCBlZGl0YWJsZTp2ZXJ0ZXg6bmV3OiBWZXJ0ZXhFdmVudFxuICAgICAgICAgICAgLy8gRmlyZWQgd2hlbiBhIG5ldyB2ZXJ0ZXggaXMgY3JlYXRlZC5cbiAgICAgICAgICAgIHRoaXMuZmlyZUFuZEZvcndhcmQoJ2VkaXRhYmxlOnZlcnRleDpuZXcnLCB7bGF0bG5nOiB2ZXJ0ZXgubGF0bG5nLCB2ZXJ0ZXg6IHZlcnRleH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFkZFZlcnRleE1hcmtlcnM6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhdGxuZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFZlcnRleE1hcmtlcihsYXRsbmdzW2ldLCBsYXRsbmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICByZWZyZXNoVmVydGV4TWFya2VyczogZnVuY3Rpb24gKGxhdGxuZ3MpIHtcbiAgICAgICAgICAgIGxhdGxuZ3MgPSBsYXRsbmdzIHx8IHRoaXMuZ2V0RGVmYXVsdExhdExuZ3MoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF0bG5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxhdGxuZ3NbaV0uX192ZXJ0ZXgudXBkYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWRkTWlkZGxlTWFya2VyOiBmdW5jdGlvbiAobGVmdCwgcmlnaHQsIGxhdGxuZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgdGhpcy50b29scy5vcHRpb25zLm1pZGRsZU1hcmtlckNsYXNzKGxlZnQsIHJpZ2h0LCBsYXRsbmdzLCB0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvblZlcnRleE1hcmtlckNsaWNrOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgTC5FZGl0YWJsZS5tYWtlQ2FuY2VsbGFibGUoZSk7XG4gICAgICAgICAgICAvLyDwn42CbmFtZXNwYWNlIEVkaXRhYmxlXG4gICAgICAgICAgICAvLyDwn42Cc2VjdGlvbiBWZXJ0ZXggZXZlbnRzXG4gICAgICAgICAgICAvLyDwn42CZXZlbnQgZWRpdGFibGU6dmVydGV4OmNsaWNrOiBDYW5jZWxhYmxlVmVydGV4RXZlbnRcbiAgICAgICAgICAgIC8vIEZpcmVkIHdoZW4gYSBgY2xpY2tgIGlzIGlzc3VlZCBvbiBhIHZlcnRleCwgYmVmb3JlIGFueSBpbnRlcm5hbCBhY3Rpb24gaXMgYmVpbmcgcHJvY2Vzc2VkLlxuICAgICAgICAgICAgdGhpcy5maXJlQW5kRm9yd2FyZCgnZWRpdGFibGU6dmVydGV4OmNsaWNrJywgZSk7XG4gICAgICAgICAgICBpZiAoZS5fY2FuY2VsbGVkKSByZXR1cm47XG4gICAgICAgICAgICBpZiAodGhpcy50b29scy5kcmF3aW5nKCkgJiYgdGhpcy50b29scy5fZHJhd2luZ0VkaXRvciAhPT0gdGhpcykgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gZS52ZXJ0ZXguZ2V0SW5kZXgoKSwgY29tbWl0O1xuICAgICAgICAgICAgaWYgKGUub3JpZ2luYWxFdmVudC5jdHJsS2V5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vblZlcnRleE1hcmtlckN0cmxDbGljayhlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZS5vcmlnaW5hbEV2ZW50LmFsdEtleSkge1xuICAgICAgICAgICAgICAgIHRoaXMub25WZXJ0ZXhNYXJrZXJBbHRDbGljayhlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZS5vcmlnaW5hbEV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vblZlcnRleE1hcmtlclNoaWZ0Q2xpY2soZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGUub3JpZ2luYWxFdmVudC5tZXRhS2V5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vblZlcnRleE1hcmtlck1ldGFLZXlDbGljayhlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPT09IGUudmVydGV4LmdldExhc3RJbmRleCgpICYmIHRoaXMuX2RyYXdpbmcgPT09IEwuRWRpdGFibGUuRk9SV0FSRCkge1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA+PSB0aGlzLk1JTl9WRVJURVggLSAxKSBjb21taXQgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpbmRleCA9PT0gMCAmJiB0aGlzLl9kcmF3aW5nID09PSBMLkVkaXRhYmxlLkJBQ0tXQVJEICYmIHRoaXMuX2RyYXduTGF0TG5ncy5sZW5ndGggPj0gdGhpcy5NSU5fVkVSVEVYKSB7XG4gICAgICAgICAgICAgICAgY29tbWl0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPT09IDAgJiYgdGhpcy5fZHJhd2luZyA9PT0gTC5FZGl0YWJsZS5GT1JXQVJEICYmIHRoaXMuX2RyYXduTGF0TG5ncy5sZW5ndGggPj0gdGhpcy5NSU5fVkVSVEVYICYmIHRoaXMuQ0xPU0VEKSB7XG4gICAgICAgICAgICAgICAgY29tbWl0ID0gdHJ1ZTsgIC8vIEFsbG93IHRvIGNsb3NlIG9uIGZpcnN0IHBvaW50IGFsc28gZm9yIHBvbHlnb25zXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMub25WZXJ0ZXhSYXdNYXJrZXJDbGljayhlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIPCfjYJuYW1lc3BhY2UgRWRpdGFibGVcbiAgICAgICAgICAgIC8vIPCfjYJzZWN0aW9uIFZlcnRleCBldmVudHNcbiAgICAgICAgICAgIC8vIPCfjYJldmVudCBlZGl0YWJsZTp2ZXJ0ZXg6Y2xpY2tlZDogVmVydGV4RXZlbnRcbiAgICAgICAgICAgIC8vIEZpcmVkIHdoZW4gYSBgY2xpY2tgIGlzIGlzc3VlZCBvbiBhIHZlcnRleCwgYWZ0ZXIgYWxsIGludGVybmFsIGFjdGlvbnMuXG4gICAgICAgICAgICB0aGlzLmZpcmVBbmRGb3J3YXJkKCdlZGl0YWJsZTp2ZXJ0ZXg6Y2xpY2tlZCcsIGUpO1xuICAgICAgICAgICAgaWYgKGNvbW1pdCkgdGhpcy5jb21taXREcmF3aW5nKGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uVmVydGV4UmF3TWFya2VyQ2xpY2s6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAvLyDwn42CbmFtZXNwYWNlIEVkaXRhYmxlXG4gICAgICAgICAgICAvLyDwn42Cc2VjdGlvbiBWZXJ0ZXggZXZlbnRzXG4gICAgICAgICAgICAvLyDwn42CZXZlbnQgZWRpdGFibGU6dmVydGV4OnJhd2NsaWNrOiBDYW5jZWxhYmxlVmVydGV4RXZlbnRcbiAgICAgICAgICAgIC8vIEZpcmVkIHdoZW4gYSBgY2xpY2tgIGlzIGlzc3VlZCBvbiBhIHZlcnRleCB3aXRob3V0IGFueSBzcGVjaWFsIGtleSBhbmQgd2l0aG91dCBiZWluZyBpbiBkcmF3aW5nIG1vZGUuXG4gICAgICAgICAgICB0aGlzLmZpcmVBbmRGb3J3YXJkKCdlZGl0YWJsZTp2ZXJ0ZXg6cmF3Y2xpY2snLCBlKTtcbiAgICAgICAgICAgIGlmIChlLl9jYW5jZWxsZWQpIHJldHVybjtcbiAgICAgICAgICAgIGlmICghdGhpcy52ZXJ0ZXhDYW5CZURlbGV0ZWQoZS52ZXJ0ZXgpKSByZXR1cm47XG4gICAgICAgICAgICBlLnZlcnRleC5kZWxldGUoKTtcbiAgICAgICAgfSxcblxuICAgICAgICB2ZXJ0ZXhDYW5CZURlbGV0ZWQ6IGZ1bmN0aW9uICh2ZXJ0ZXgpIHtcbiAgICAgICAgICAgIHJldHVybiB2ZXJ0ZXgubGF0bG5ncy5sZW5ndGggPiB0aGlzLk1JTl9WRVJURVg7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25WZXJ0ZXhEZWxldGVkOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgLy8g8J+Ngm5hbWVzcGFjZSBFZGl0YWJsZVxuICAgICAgICAgICAgLy8g8J+NgnNlY3Rpb24gVmVydGV4IGV2ZW50c1xuICAgICAgICAgICAgLy8g8J+NgmV2ZW50IGVkaXRhYmxlOnZlcnRleDpkZWxldGVkOiBWZXJ0ZXhFdmVudFxuICAgICAgICAgICAgLy8gRmlyZWQgYWZ0ZXIgYSB2ZXJ0ZXggaGFzIGJlZW4gZGVsZXRlZCBieSB1c2VyLlxuICAgICAgICAgICAgdGhpcy5maXJlQW5kRm9yd2FyZCgnZWRpdGFibGU6dmVydGV4OmRlbGV0ZWQnLCBlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvblZlcnRleE1hcmtlckN0cmxDbGljazogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIC8vIPCfjYJuYW1lc3BhY2UgRWRpdGFibGVcbiAgICAgICAgICAgIC8vIPCfjYJzZWN0aW9uIFZlcnRleCBldmVudHNcbiAgICAgICAgICAgIC8vIPCfjYJldmVudCBlZGl0YWJsZTp2ZXJ0ZXg6Y3RybGNsaWNrOiBWZXJ0ZXhFdmVudFxuICAgICAgICAgICAgLy8gRmlyZWQgd2hlbiBhIGBjbGlja2Agd2l0aCBgY3RybEtleWAgaXMgaXNzdWVkIG9uIGEgdmVydGV4LlxuICAgICAgICAgICAgdGhpcy5maXJlQW5kRm9yd2FyZCgnZWRpdGFibGU6dmVydGV4OmN0cmxjbGljaycsIGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uVmVydGV4TWFya2VyU2hpZnRDbGljazogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIC8vIPCfjYJuYW1lc3BhY2UgRWRpdGFibGVcbiAgICAgICAgICAgIC8vIPCfjYJzZWN0aW9uIFZlcnRleCBldmVudHNcbiAgICAgICAgICAgIC8vIPCfjYJldmVudCBlZGl0YWJsZTp2ZXJ0ZXg6c2hpZnRjbGljazogVmVydGV4RXZlbnRcbiAgICAgICAgICAgIC8vIEZpcmVkIHdoZW4gYSBgY2xpY2tgIHdpdGggYHNoaWZ0S2V5YCBpcyBpc3N1ZWQgb24gYSB2ZXJ0ZXguXG4gICAgICAgICAgICB0aGlzLmZpcmVBbmRGb3J3YXJkKCdlZGl0YWJsZTp2ZXJ0ZXg6c2hpZnRjbGljaycsIGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uVmVydGV4TWFya2VyTWV0YUtleUNsaWNrOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgLy8g8J+Ngm5hbWVzcGFjZSBFZGl0YWJsZVxuICAgICAgICAgICAgLy8g8J+NgnNlY3Rpb24gVmVydGV4IGV2ZW50c1xuICAgICAgICAgICAgLy8g8J+NgmV2ZW50IGVkaXRhYmxlOnZlcnRleDptZXRha2V5Y2xpY2s6IFZlcnRleEV2ZW50XG4gICAgICAgICAgICAvLyBGaXJlZCB3aGVuIGEgYGNsaWNrYCB3aXRoIGBtZXRhS2V5YCBpcyBpc3N1ZWQgb24gYSB2ZXJ0ZXguXG4gICAgICAgICAgICB0aGlzLmZpcmVBbmRGb3J3YXJkKCdlZGl0YWJsZTp2ZXJ0ZXg6bWV0YWtleWNsaWNrJywgZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25WZXJ0ZXhNYXJrZXJBbHRDbGljazogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIC8vIPCfjYJuYW1lc3BhY2UgRWRpdGFibGVcbiAgICAgICAgICAgIC8vIPCfjYJzZWN0aW9uIFZlcnRleCBldmVudHNcbiAgICAgICAgICAgIC8vIPCfjYJldmVudCBlZGl0YWJsZTp2ZXJ0ZXg6YWx0Y2xpY2s6IFZlcnRleEV2ZW50XG4gICAgICAgICAgICAvLyBGaXJlZCB3aGVuIGEgYGNsaWNrYCB3aXRoIGBhbHRLZXlgIGlzIGlzc3VlZCBvbiBhIHZlcnRleC5cbiAgICAgICAgICAgIHRoaXMuZmlyZUFuZEZvcndhcmQoJ2VkaXRhYmxlOnZlcnRleDphbHRjbGljaycsIGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uVmVydGV4TWFya2VyQ29udGV4dE1lbnU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAvLyDwn42CbmFtZXNwYWNlIEVkaXRhYmxlXG4gICAgICAgICAgICAvLyDwn42Cc2VjdGlvbiBWZXJ0ZXggZXZlbnRzXG4gICAgICAgICAgICAvLyDwn42CZXZlbnQgZWRpdGFibGU6dmVydGV4OmNvbnRleHRtZW51OiBWZXJ0ZXhFdmVudFxuICAgICAgICAgICAgLy8gRmlyZWQgd2hlbiBhIGBjb250ZXh0bWVudWAgaXMgaXNzdWVkIG9uIGEgdmVydGV4LlxuICAgICAgICAgICAgdGhpcy5maXJlQW5kRm9yd2FyZCgnZWRpdGFibGU6dmVydGV4OmNvbnRleHRtZW51JywgZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25WZXJ0ZXhNYXJrZXJNb3VzZURvd246IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAvLyDwn42CbmFtZXNwYWNlIEVkaXRhYmxlXG4gICAgICAgICAgICAvLyDwn42Cc2VjdGlvbiBWZXJ0ZXggZXZlbnRzXG4gICAgICAgICAgICAvLyDwn42CZXZlbnQgZWRpdGFibGU6dmVydGV4Om1vdXNlZG93bjogVmVydGV4RXZlbnRcbiAgICAgICAgICAgIC8vIEZpcmVkIHdoZW4gdXNlciBgbW91c2Vkb3duYCBhIHZlcnRleC5cbiAgICAgICAgICAgIHRoaXMuZmlyZUFuZEZvcndhcmQoJ2VkaXRhYmxlOnZlcnRleDptb3VzZWRvd24nLCBlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvblZlcnRleE1hcmtlck1vdXNlT3ZlcjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIC8vIPCfjYJuYW1lc3BhY2UgRWRpdGFibGVcbiAgICAgICAgICAgIC8vIPCfjYJzZWN0aW9uIFZlcnRleCBldmVudHNcbiAgICAgICAgICAgIC8vIPCfjYJldmVudCBlZGl0YWJsZTp2ZXJ0ZXg6bW91c2VvdmVyOiBWZXJ0ZXhFdmVudFxuICAgICAgICAgICAgLy8gRmlyZWQgd2hlbiBhIHVzZXIncyBtb3VzZSBlbnRlcnMgdGhlIHZlcnRleFxuICAgICAgICAgICAgdGhpcy5maXJlQW5kRm9yd2FyZCgnZWRpdGFibGU6dmVydGV4Om1vdXNlb3ZlcicsIGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uVmVydGV4TWFya2VyTW91c2VPdXQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAvLyDwn42CbmFtZXNwYWNlIEVkaXRhYmxlXG4gICAgICAgICAgICAvLyDwn42Cc2VjdGlvbiBWZXJ0ZXggZXZlbnRzXG4gICAgICAgICAgICAvLyDwn42CZXZlbnQgZWRpdGFibGU6dmVydGV4Om1vdXNlb3V0OiBWZXJ0ZXhFdmVudFxuICAgICAgICAgICAgLy8gRmlyZWQgd2hlbiBhIHVzZXIncyBtb3VzZSBsZWF2ZXMgdGhlIHZlcnRleFxuICAgICAgICAgICAgdGhpcy5maXJlQW5kRm9yd2FyZCgnZWRpdGFibGU6dmVydGV4Om1vdXNlb3V0JywgZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25NaWRkbGVNYXJrZXJNb3VzZURvd246IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAvLyDwn42CbmFtZXNwYWNlIEVkaXRhYmxlXG4gICAgICAgICAgICAvLyDwn42Cc2VjdGlvbiBNaWRkbGVNYXJrZXIgZXZlbnRzXG4gICAgICAgICAgICAvLyDwn42CZXZlbnQgZWRpdGFibGU6bWlkZGxlbWFya2VyOm1vdXNlZG93bjogVmVydGV4RXZlbnRcbiAgICAgICAgICAgIC8vIEZpcmVkIHdoZW4gdXNlciBgbW91c2Vkb3duYCBhIG1pZGRsZSBtYXJrZXIuXG4gICAgICAgICAgICB0aGlzLmZpcmVBbmRGb3J3YXJkKCdlZGl0YWJsZTptaWRkbGVtYXJrZXI6bW91c2Vkb3duJywgZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25WZXJ0ZXhNYXJrZXJEcmFnOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdGhpcy5vbk1vdmUoZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5mZWF0dXJlLl9ib3VuZHMpIHRoaXMuZXh0ZW5kQm91bmRzKGUpO1xuICAgICAgICAgICAgLy8g8J+Ngm5hbWVzcGFjZSBFZGl0YWJsZVxuICAgICAgICAgICAgLy8g8J+NgnNlY3Rpb24gVmVydGV4IGV2ZW50c1xuICAgICAgICAgICAgLy8g8J+NgmV2ZW50IGVkaXRhYmxlOnZlcnRleDpkcmFnOiBWZXJ0ZXhFdmVudFxuICAgICAgICAgICAgLy8gRmlyZWQgd2hlbiBhIHZlcnRleCBpcyBkcmFnZ2VkIGJ5IHVzZXIuXG4gICAgICAgICAgICB0aGlzLmZpcmVBbmRGb3J3YXJkKCdlZGl0YWJsZTp2ZXJ0ZXg6ZHJhZycsIGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uVmVydGV4TWFya2VyRHJhZ1N0YXJ0OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgLy8g8J+Ngm5hbWVzcGFjZSBFZGl0YWJsZVxuICAgICAgICAgICAgLy8g8J+NgnNlY3Rpb24gVmVydGV4IGV2ZW50c1xuICAgICAgICAgICAgLy8g8J+NgmV2ZW50IGVkaXRhYmxlOnZlcnRleDpkcmFnc3RhcnQ6IFZlcnRleEV2ZW50XG4gICAgICAgICAgICAvLyBGaXJlZCBiZWZvcmUgYSB2ZXJ0ZXggaXMgZHJhZ2dlZCBieSB1c2VyLlxuICAgICAgICAgICAgdGhpcy5maXJlQW5kRm9yd2FyZCgnZWRpdGFibGU6dmVydGV4OmRyYWdzdGFydCcsIGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uVmVydGV4TWFya2VyRHJhZ0VuZDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIC8vIPCfjYJuYW1lc3BhY2UgRWRpdGFibGVcbiAgICAgICAgICAgIC8vIPCfjYJzZWN0aW9uIFZlcnRleCBldmVudHNcbiAgICAgICAgICAgIC8vIPCfjYJldmVudCBlZGl0YWJsZTp2ZXJ0ZXg6ZHJhZ2VuZDogVmVydGV4RXZlbnRcbiAgICAgICAgICAgIC8vIEZpcmVkIGFmdGVyIGEgdmVydGV4IGlzIGRyYWdnZWQgYnkgdXNlci5cbiAgICAgICAgICAgIHRoaXMuZmlyZUFuZEZvcndhcmQoJ2VkaXRhYmxlOnZlcnRleDpkcmFnZW5kJywgZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0RHJhd25MYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuICAgICAgICAgICAgdGhpcy5fZHJhd25MYXRMbmdzID0gbGF0bG5ncyB8fCB0aGlzLmdldERlZmF1bHRMYXRMbmdzKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc3RhcnREcmF3aW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2RyYXduTGF0TG5ncykgdGhpcy5zZXREcmF3bkxhdExuZ3MoKTtcbiAgICAgICAgICAgIEwuRWRpdGFibGUuQmFzZUVkaXRvci5wcm90b3R5cGUuc3RhcnREcmF3aW5nLmNhbGwodGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc3RhcnREcmF3aW5nRm9yd2FyZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5zdGFydERyYXdpbmcoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBlbmREcmF3aW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnRvb2xzLmRldGFjaEZvcndhcmRMaW5lR3VpZGUoKTtcbiAgICAgICAgICAgIHRoaXMudG9vbHMuZGV0YWNoQmFja3dhcmRMaW5lR3VpZGUoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9kcmF3bkxhdExuZ3MgJiYgdGhpcy5fZHJhd25MYXRMbmdzLmxlbmd0aCA8IHRoaXMuTUlOX1ZFUlRFWCkgdGhpcy5kZWxldGVTaGFwZSh0aGlzLl9kcmF3bkxhdExuZ3MpO1xuICAgICAgICAgICAgTC5FZGl0YWJsZS5CYXNlRWRpdG9yLnByb3RvdHlwZS5lbmREcmF3aW5nLmNhbGwodGhpcyk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fZHJhd25MYXRMbmdzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFkZExhdExuZzogZnVuY3Rpb24gKGxhdGxuZykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2RyYXdpbmcgPT09IEwuRWRpdGFibGUuRk9SV0FSRCkgdGhpcy5fZHJhd25MYXRMbmdzLnB1c2gobGF0bG5nKTtcbiAgICAgICAgICAgIGVsc2UgdGhpcy5fZHJhd25MYXRMbmdzLnVuc2hpZnQobGF0bG5nKTtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZS5fYm91bmRzLmV4dGVuZChsYXRsbmcpO1xuICAgICAgICAgICAgdmFyIHZlcnRleCA9IHRoaXMuYWRkVmVydGV4TWFya2VyKGxhdGxuZywgdGhpcy5fZHJhd25MYXRMbmdzKTtcbiAgICAgICAgICAgIHRoaXMub25OZXdWZXJ0ZXgodmVydGV4KTtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG5ld1BvaW50Rm9yd2FyZDogZnVuY3Rpb24gKGxhdGxuZykge1xuICAgICAgICAgICAgdGhpcy5hZGRMYXRMbmcobGF0bG5nKTtcbiAgICAgICAgICAgIHRoaXMudG9vbHMuYXR0YWNoRm9yd2FyZExpbmVHdWlkZSgpO1xuICAgICAgICAgICAgdGhpcy50b29scy5hbmNob3JGb3J3YXJkTGluZUd1aWRlKGxhdGxuZyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbmV3UG9pbnRCYWNrd2FyZDogZnVuY3Rpb24gKGxhdGxuZykge1xuICAgICAgICAgICAgdGhpcy5hZGRMYXRMbmcobGF0bG5nKTtcbiAgICAgICAgICAgIHRoaXMudG9vbHMuYW5jaG9yQmFja3dhcmRMaW5lR3VpZGUobGF0bG5nKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyDwn42CbmFtZXNwYWNlIFBhdGhFZGl0b3JcbiAgICAgICAgLy8g8J+Ngm1ldGhvZCBwdXNoKClcbiAgICAgICAgLy8gUHJvZ3JhbW1hdGljYWxseSBhZGQgYSBwb2ludCB3aGlsZSBkcmF3aW5nLlxuICAgICAgICBwdXNoOiBmdW5jdGlvbiAobGF0bG5nKSB7XG4gICAgICAgICAgICBpZiAoIWxhdGxuZykgcmV0dXJuIGNvbnNvbGUuZXJyb3IoJ0wuRWRpdGFibGUuUGF0aEVkaXRvci5wdXNoIGV4cGVjdCBhIHZhbGlkIGxhdGxuZyBhcyBwYXJhbWV0ZXInKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9kcmF3aW5nID09PSBMLkVkaXRhYmxlLkZPUldBUkQpIHRoaXMubmV3UG9pbnRGb3J3YXJkKGxhdGxuZyk7XG4gICAgICAgICAgICBlbHNlIHRoaXMubmV3UG9pbnRCYWNrd2FyZChsYXRsbmcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbW92ZUxhdExuZzogZnVuY3Rpb24gKGxhdGxuZykge1xuICAgICAgICAgICAgbGF0bG5nLl9fdmVydGV4LmRlbGV0ZSgpO1xuICAgICAgICAgICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8g8J+Ngm1ldGhvZCBwb3AoKTogTC5MYXRMbmcgb3IgbnVsbFxuICAgICAgICAvLyBQcm9ncmFtbWF0aWNhbGx5IHJlbW92ZSBsYXN0IHBvaW50IChpZiBhbnkpIHdoaWxlIGRyYXdpbmcuXG4gICAgICAgIHBvcDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2RyYXduTGF0TG5ncy5sZW5ndGggPD0gMSkgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGxhdGxuZztcbiAgICAgICAgICAgIGlmICh0aGlzLl9kcmF3aW5nID09PSBMLkVkaXRhYmxlLkZPUldBUkQpIGxhdGxuZyA9IHRoaXMuX2RyYXduTGF0TG5nc1t0aGlzLl9kcmF3bkxhdExuZ3MubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBlbHNlIGxhdGxuZyA9IHRoaXMuX2RyYXduTGF0TG5nc1swXTtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlTGF0TG5nKGxhdGxuZyk7XG4gICAgICAgICAgICBpZiAodGhpcy5fZHJhd2luZyA9PT0gTC5FZGl0YWJsZS5GT1JXQVJEKSB0aGlzLnRvb2xzLmFuY2hvckZvcndhcmRMaW5lR3VpZGUodGhpcy5fZHJhd25MYXRMbmdzW3RoaXMuX2RyYXduTGF0TG5ncy5sZW5ndGggLSAxXSk7XG4gICAgICAgICAgICBlbHNlIHRoaXMudG9vbHMuYW5jaG9yRm9yd2FyZExpbmVHdWlkZSh0aGlzLl9kcmF3bkxhdExuZ3NbMF0pO1xuICAgICAgICAgICAgcmV0dXJuIGxhdGxuZztcbiAgICAgICAgfSxcblxuICAgICAgICBwcm9jZXNzRHJhd2luZ0NsaWNrOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKGUudmVydGV4ICYmIGUudmVydGV4LmVkaXRvciA9PT0gdGhpcykgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2RyYXdpbmcgPT09IEwuRWRpdGFibGUuRk9SV0FSRCkgdGhpcy5uZXdQb2ludEZvcndhcmQoZS5sYXRsbmcpO1xuICAgICAgICAgICAgZWxzZSB0aGlzLm5ld1BvaW50QmFja3dhcmQoZS5sYXRsbmcpO1xuICAgICAgICAgICAgdGhpcy5maXJlQW5kRm9yd2FyZCgnZWRpdGFibGU6ZHJhd2luZzpjbGlja2VkJywgZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25EcmF3aW5nTW91c2VNb3ZlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgTC5FZGl0YWJsZS5CYXNlRWRpdG9yLnByb3RvdHlwZS5vbkRyYXdpbmdNb3VzZU1vdmUuY2FsbCh0aGlzLCBlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9kcmF3aW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50b29scy5tb3ZlRm9yd2FyZExpbmVHdWlkZShlLmxhdGxuZyk7XG4gICAgICAgICAgICAgICAgdGhpcy50b29scy5tb3ZlQmFja3dhcmRMaW5lR3VpZGUoZS5sYXRsbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHJlZnJlc2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZS5yZWRyYXcoKTtcbiAgICAgICAgICAgIHRoaXMub25FZGl0aW5nKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8g8J+Ngm5hbWVzcGFjZSBQYXRoRWRpdG9yXG4gICAgICAgIC8vIPCfjYJtZXRob2QgbmV3U2hhcGUobGF0bG5nPzogTC5MYXRMbmcpXG4gICAgICAgIC8vIEFkZCBhIG5ldyBzaGFwZSAoUG9seWxpbmUsIFBvbHlnb24pIGluIGEgbXVsdGksIGFuZCBzZXR1cCB1cCBkcmF3aW5nIHRvb2xzIHRvIGRyYXcgaXQ7XG4gICAgICAgIC8vIGlmIG9wdGlvbmFsIGBsYXRsbmdgIGlzIGdpdmVuLCBzdGFydCBhIHBhdGggYXQgdGhpcyBwb2ludC5cbiAgICAgICAgbmV3U2hhcGU6IGZ1bmN0aW9uIChsYXRsbmcpIHtcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IHRoaXMuYWRkTmV3RW1wdHlTaGFwZSgpO1xuICAgICAgICAgICAgaWYgKCFzaGFwZSkgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5zZXREcmF3bkxhdExuZ3Moc2hhcGVbMF0gfHwgc2hhcGUpOyAgLy8gUG9seWdvbiBvciBwb2x5bGluZVxuICAgICAgICAgICAgdGhpcy5zdGFydERyYXdpbmdGb3J3YXJkKCk7XG4gICAgICAgICAgICAvLyDwn42CbmFtZXNwYWNlIEVkaXRhYmxlXG4gICAgICAgICAgICAvLyDwn42Cc2VjdGlvbiBTaGFwZSBldmVudHNcbiAgICAgICAgICAgIC8vIPCfjYJldmVudCBlZGl0YWJsZTpzaGFwZTpuZXc6IFNoYXBlRXZlbnRcbiAgICAgICAgICAgIC8vIEZpcmVkIHdoZW4gYSBuZXcgc2hhcGUgaXMgY3JlYXRlZCBpbiBhIG11bHRpIChQb2x5Z29uIG9yIFBvbHlsaW5lKS5cbiAgICAgICAgICAgIHRoaXMuZmlyZUFuZEZvcndhcmQoJ2VkaXRhYmxlOnNoYXBlOm5ldycsIHtzaGFwZTogc2hhcGV9KTtcbiAgICAgICAgICAgIGlmIChsYXRsbmcpIHRoaXMubmV3UG9pbnRGb3J3YXJkKGxhdGxuZyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGVsZXRlU2hhcGU6IGZ1bmN0aW9uIChzaGFwZSwgbGF0bG5ncykge1xuICAgICAgICAgICAgdmFyIGUgPSB7c2hhcGU6IHNoYXBlfTtcbiAgICAgICAgICAgIEwuRWRpdGFibGUubWFrZUNhbmNlbGxhYmxlKGUpO1xuICAgICAgICAgICAgLy8g8J+Ngm5hbWVzcGFjZSBFZGl0YWJsZVxuICAgICAgICAgICAgLy8g8J+NgnNlY3Rpb24gU2hhcGUgZXZlbnRzXG4gICAgICAgICAgICAvLyDwn42CZXZlbnQgZWRpdGFibGU6c2hhcGU6ZGVsZXRlOiBDYW5jZWxhYmxlU2hhcGVFdmVudFxuICAgICAgICAgICAgLy8gRmlyZWQgYmVmb3JlIGEgbmV3IHNoYXBlIGlzIGRlbGV0ZWQgaW4gYSBtdWx0aSAoUG9seWdvbiBvciBQb2x5bGluZSkuXG4gICAgICAgICAgICB0aGlzLmZpcmVBbmRGb3J3YXJkKCdlZGl0YWJsZTpzaGFwZTpkZWxldGUnLCBlKTtcbiAgICAgICAgICAgIGlmIChlLl9jYW5jZWxsZWQpIHJldHVybjtcbiAgICAgICAgICAgIHNoYXBlID0gdGhpcy5fZGVsZXRlU2hhcGUoc2hhcGUsIGxhdGxuZ3MpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZW5zdXJlTm90RmxhdCkgdGhpcy5lbnN1cmVOb3RGbGF0KCk7ICAvLyBQb2x5Z29uLlxuICAgICAgICAgICAgdGhpcy5mZWF0dXJlLnNldExhdExuZ3ModGhpcy5nZXRMYXRMbmdzKCkpOyAgLy8gRm9yY2UgYm91bmRzIHJlc2V0LlxuICAgICAgICAgICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICAvLyDwn42CbmFtZXNwYWNlIEVkaXRhYmxlXG4gICAgICAgICAgICAvLyDwn42Cc2VjdGlvbiBTaGFwZSBldmVudHNcbiAgICAgICAgICAgIC8vIPCfjYJldmVudCBlZGl0YWJsZTpzaGFwZTpkZWxldGVkOiBTaGFwZUV2ZW50XG4gICAgICAgICAgICAvLyBGaXJlZCBhZnRlciBhIG5ldyBzaGFwZSBpcyBkZWxldGVkIGluIGEgbXVsdGkgKFBvbHlnb24gb3IgUG9seWxpbmUpLlxuICAgICAgICAgICAgdGhpcy5maXJlQW5kRm9yd2FyZCgnZWRpdGFibGU6c2hhcGU6ZGVsZXRlZCcsIHtzaGFwZTogc2hhcGV9KTtcbiAgICAgICAgICAgIHJldHVybiBzaGFwZTtcbiAgICAgICAgfSxcblxuICAgICAgICBfZGVsZXRlU2hhcGU6IGZ1bmN0aW9uIChzaGFwZSwgbGF0bG5ncykge1xuICAgICAgICAgICAgbGF0bG5ncyA9IGxhdGxuZ3MgfHwgdGhpcy5nZXRMYXRMbmdzKCk7XG4gICAgICAgICAgICBpZiAoIWxhdGxuZ3MubGVuZ3RoKSByZXR1cm47XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICAgICAgaW5wbGFjZURlbGV0ZSA9IGZ1bmN0aW9uIChsYXRsbmdzLCBzaGFwZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDYWxsZWQgd2hlbiBkZWxldGluZyBhIGZsYXQgbGF0bG5nc1xuICAgICAgICAgICAgICAgICAgICBzaGFwZSA9IGxhdGxuZ3Muc3BsaWNlKDAsIE51bWJlci5NQVhfVkFMVUUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2hhcGU7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzcGxpY2VEZWxldGUgPSBmdW5jdGlvbiAobGF0bG5ncywgc2hhcGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FsbGVkIHdoZW4gcmVtb3ZpbmcgYSBsYXRsbmdzIGluc2lkZSBhbiBhcnJheVxuICAgICAgICAgICAgICAgICAgICBsYXRsbmdzLnNwbGljZShsYXRsbmdzLmluZGV4T2Yoc2hhcGUpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFsYXRsbmdzLmxlbmd0aCkgc2VsZi5fZGVsZXRlU2hhcGUobGF0bG5ncyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaGFwZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGxhdGxuZ3MgPT09IHNoYXBlKSByZXR1cm4gaW5wbGFjZURlbGV0ZShsYXRsbmdzLCBzaGFwZSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhdGxuZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAobGF0bG5nc1tpXSA9PT0gc2hhcGUpIHJldHVybiBzcGxpY2VEZWxldGUobGF0bG5ncywgc2hhcGUpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGxhdGxuZ3NbaV0uaW5kZXhPZihzaGFwZSkgIT09IC0xKSByZXR1cm4gc3BsaWNlRGVsZXRlKGxhdGxuZ3NbaV0sIHNoYXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyDwn42CbmFtZXNwYWNlIFBhdGhFZGl0b3JcbiAgICAgICAgLy8g8J+Ngm1ldGhvZCBkZWxldGVTaGFwZUF0KGxhdGxuZzogTC5MYXRMbmcpOiBBcnJheVxuICAgICAgICAvLyBSZW1vdmUgYSBwYXRoIHNoYXBlIGF0IHRoZSBnaXZlbiBgbGF0bG5nYC5cbiAgICAgICAgZGVsZXRlU2hhcGVBdDogZnVuY3Rpb24gKGxhdGxuZykge1xuICAgICAgICAgICAgdmFyIHNoYXBlID0gdGhpcy5mZWF0dXJlLnNoYXBlQXQobGF0bG5nKTtcbiAgICAgICAgICAgIGlmIChzaGFwZSkgcmV0dXJuIHRoaXMuZGVsZXRlU2hhcGUoc2hhcGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIPCfjYJtZXRob2QgYXBwZW5kU2hhcGUoc2hhcGU6IEFycmF5KVxuICAgICAgICAvLyBBcHBlbmQgYSBuZXcgc2hhcGUgdG8gdGhlIFBvbHlnb24gb3IgUG9seWxpbmUuXG4gICAgICAgIGFwcGVuZFNoYXBlOiBmdW5jdGlvbiAoc2hhcGUpIHtcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0U2hhcGUoc2hhcGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIPCfjYJtZXRob2QgcHJlcGVuZFNoYXBlKHNoYXBlOiBBcnJheSlcbiAgICAgICAgLy8gUHJlcGVuZCBhIG5ldyBzaGFwZSB0byB0aGUgUG9seWdvbiBvciBQb2x5bGluZS5cbiAgICAgICAgcHJlcGVuZFNoYXBlOiBmdW5jdGlvbiAoc2hhcGUpIHtcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0U2hhcGUoc2hhcGUsIDApO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIPCfjYJtZXRob2QgaW5zZXJ0U2hhcGUoc2hhcGU6IEFycmF5LCBpbmRleDogaW50KVxuICAgICAgICAvLyBJbnNlcnQgYSBuZXcgc2hhcGUgdG8gdGhlIFBvbHlnb24gb3IgUG9seWxpbmUgYXQgZ2l2ZW4gaW5kZXggKGRlZmF1bHQgaXMgdG8gYXBwZW5kKS5cbiAgICAgICAgaW5zZXJ0U2hhcGU6IGZ1bmN0aW9uIChzaGFwZSwgaW5kZXgpIHtcbiAgICAgICAgICAgIHRoaXMuZW5zdXJlTXVsdGkoKTtcbiAgICAgICAgICAgIHNoYXBlID0gdGhpcy5mb3JtYXRTaGFwZShzaGFwZSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGluZGV4ID09PSAndW5kZWZpbmVkJykgaW5kZXggPSB0aGlzLmZlYXR1cmUuX2xhdGxuZ3MubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlLl9sYXRsbmdzLnNwbGljZShpbmRleCwgMCwgc2hhcGUpO1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlLnJlZHJhdygpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2VuYWJsZWQpIHRoaXMucmVzZXQoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBleHRlbmRCb3VuZHM6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB0aGlzLmZlYXR1cmUuX2JvdW5kcy5leHRlbmQoZS52ZXJ0ZXgubGF0bG5nKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvbkRyYWdTdGFydDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHRoaXMuZWRpdExheWVyLmNsZWFyTGF5ZXJzKCk7XG4gICAgICAgICAgICBMLkVkaXRhYmxlLkJhc2VFZGl0b3IucHJvdG90eXBlLm9uRHJhZ1N0YXJ0LmNhbGwodGhpcywgZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25EcmFnRW5kOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdGhpcy5pbml0VmVydGV4TWFya2VycygpO1xuICAgICAgICAgICAgTC5FZGl0YWJsZS5CYXNlRWRpdG9yLnByb3RvdHlwZS5vbkRyYWdFbmQuY2FsbCh0aGlzLCBlKTtcbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICAvLyDwn42CbmFtZXNwYWNlIEVkaXRhYmxlOyDwn42CY2xhc3MgUG9seWxpbmVFZGl0b3I7IPCfjYJha2EgTC5FZGl0YWJsZS5Qb2x5bGluZUVkaXRvclxuICAgIC8vIPCfjYJpbmhlcml0cyBQYXRoRWRpdG9yXG4gICAgTC5FZGl0YWJsZS5Qb2x5bGluZUVkaXRvciA9IEwuRWRpdGFibGUuUGF0aEVkaXRvci5leHRlbmQoe1xuXG4gICAgICAgIHN0YXJ0RHJhd2luZ0JhY2t3YXJkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9kcmF3aW5nID0gTC5FZGl0YWJsZS5CQUNLV0FSRDtcbiAgICAgICAgICAgIHRoaXMuc3RhcnREcmF3aW5nKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8g8J+Ngm1ldGhvZCBjb250aW51ZUJhY2t3YXJkKGxhdGxuZ3M/OiBBcnJheSlcbiAgICAgICAgLy8gU2V0IHVwIGRyYXdpbmcgdG9vbHMgdG8gY29udGludWUgdGhlIGxpbmUgYmFja3dhcmQuXG4gICAgICAgIGNvbnRpbnVlQmFja3dhcmQ6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kcmF3aW5nKCkpIHJldHVybjtcbiAgICAgICAgICAgIGxhdGxuZ3MgPSBsYXRsbmdzIHx8IHRoaXMuZ2V0RGVmYXVsdExhdExuZ3MoKTtcbiAgICAgICAgICAgIHRoaXMuc2V0RHJhd25MYXRMbmdzKGxhdGxuZ3MpO1xuICAgICAgICAgICAgaWYgKGxhdGxuZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMudG9vbHMuYXR0YWNoQmFja3dhcmRMaW5lR3VpZGUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRvb2xzLmFuY2hvckJhY2t3YXJkTGluZUd1aWRlKGxhdGxuZ3NbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdGFydERyYXdpbmdCYWNrd2FyZCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIPCfjYJtZXRob2QgY29udGludWVGb3J3YXJkKGxhdGxuZ3M/OiBBcnJheSlcbiAgICAgICAgLy8gU2V0IHVwIGRyYXdpbmcgdG9vbHMgdG8gY29udGludWUgdGhlIGxpbmUgZm9yd2FyZC5cbiAgICAgICAgY29udGludWVGb3J3YXJkOiBmdW5jdGlvbiAobGF0bG5ncykge1xuICAgICAgICAgICAgaWYgKHRoaXMuZHJhd2luZygpKSByZXR1cm47XG4gICAgICAgICAgICBsYXRsbmdzID0gbGF0bG5ncyB8fCB0aGlzLmdldERlZmF1bHRMYXRMbmdzKCk7XG4gICAgICAgICAgICB0aGlzLnNldERyYXduTGF0TG5ncyhsYXRsbmdzKTtcbiAgICAgICAgICAgIGlmIChsYXRsbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRvb2xzLmF0dGFjaEZvcndhcmRMaW5lR3VpZGUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRvb2xzLmFuY2hvckZvcndhcmRMaW5lR3VpZGUobGF0bG5nc1tsYXRsbmdzLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3RhcnREcmF3aW5nRm9yd2FyZCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldERlZmF1bHRMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuICAgICAgICAgICAgbGF0bG5ncyA9IGxhdGxuZ3MgfHwgdGhpcy5mZWF0dXJlLl9sYXRsbmdzO1xuICAgICAgICAgICAgaWYgKCFsYXRsbmdzLmxlbmd0aCB8fCBsYXRsbmdzWzBdIGluc3RhbmNlb2YgTC5MYXRMbmcpIHJldHVybiBsYXRsbmdzO1xuICAgICAgICAgICAgZWxzZSByZXR1cm4gdGhpcy5nZXREZWZhdWx0TGF0TG5ncyhsYXRsbmdzWzBdKTtcbiAgICAgICAgfSxcblxuICAgICAgICBlbnN1cmVNdWx0aTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZmVhdHVyZS5fbGF0bG5ncy5sZW5ndGggJiYgaXNGbGF0KHRoaXMuZmVhdHVyZS5fbGF0bG5ncykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZlYXR1cmUuX2xhdGxuZ3MgPSBbdGhpcy5mZWF0dXJlLl9sYXRsbmdzXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBhZGROZXdFbXB0eVNoYXBlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5mZWF0dXJlLl9sYXRsbmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBzaGFwZSA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kU2hhcGUoc2hhcGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzaGFwZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmVhdHVyZS5fbGF0bG5ncztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBmb3JtYXRTaGFwZTogZnVuY3Rpb24gKHNoYXBlKSB7XG4gICAgICAgICAgICBpZiAoaXNGbGF0KHNoYXBlKSkgcmV0dXJuIHNoYXBlO1xuICAgICAgICAgICAgZWxzZSBpZiAoc2hhcGVbMF0pIHJldHVybiB0aGlzLmZvcm1hdFNoYXBlKHNoYXBlWzBdKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyDwn42CbWV0aG9kIHNwbGl0U2hhcGUobGF0bG5ncz86IEFycmF5LCBpbmRleDogaW50KVxuICAgICAgICAvLyBTcGxpdCB0aGUgZ2l2ZW4gYGxhdGxuZ3NgIHNoYXBlIGF0IGluZGV4IGBpbmRleGAgYW5kIGludGVncmF0ZSBuZXcgc2hhcGUgaW4gaW5zdGFuY2UgYGxhdGxuZ3NgLlxuICAgICAgICBzcGxpdFNoYXBlOiBmdW5jdGlvbiAoc2hhcGUsIGluZGV4KSB7XG4gICAgICAgICAgICBpZiAoIWluZGV4IHx8IGluZGV4ID49IHNoYXBlLmxlbmd0aCAtIDEpIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMuZW5zdXJlTXVsdGkoKTtcbiAgICAgICAgICAgIHZhciBzaGFwZUluZGV4ID0gdGhpcy5mZWF0dXJlLl9sYXRsbmdzLmluZGV4T2Yoc2hhcGUpO1xuICAgICAgICAgICAgaWYgKHNoYXBlSW5kZXggPT09IC0xKSByZXR1cm47XG4gICAgICAgICAgICB2YXIgZmlyc3QgPSBzaGFwZS5zbGljZSgwLCBpbmRleCArIDEpLFxuICAgICAgICAgICAgICAgIHNlY29uZCA9IHNoYXBlLnNsaWNlKGluZGV4KTtcbiAgICAgICAgICAgIC8vIFdlIGRlYWwgd2l0aCByZWZlcmVuY2UsIHdlIGRvbid0IHdhbnQgdHdpY2UgdGhlIHNhbWUgbGF0bG5nIGFyb3VuZC5cbiAgICAgICAgICAgIHNlY29uZFswXSA9IEwubGF0TG5nKHNlY29uZFswXS5sYXQsIHNlY29uZFswXS5sbmcsIHNlY29uZFswXS5hbHQpO1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlLl9sYXRsbmdzLnNwbGljZShzaGFwZUluZGV4LCAxLCBmaXJzdCwgc2Vjb25kKTtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaCgpO1xuICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIC8vIPCfjYJuYW1lc3BhY2UgRWRpdGFibGU7IPCfjYJjbGFzcyBQb2x5Z29uRWRpdG9yOyDwn42CYWthIEwuRWRpdGFibGUuUG9seWdvbkVkaXRvclxuICAgIC8vIPCfjYJpbmhlcml0cyBQYXRoRWRpdG9yXG4gICAgTC5FZGl0YWJsZS5Qb2x5Z29uRWRpdG9yID0gTC5FZGl0YWJsZS5QYXRoRWRpdG9yLmV4dGVuZCh7XG5cbiAgICAgICAgQ0xPU0VEOiB0cnVlLFxuICAgICAgICBNSU5fVkVSVEVYOiAzLFxuXG4gICAgICAgIG5ld1BvaW50Rm9yd2FyZDogZnVuY3Rpb24gKGxhdGxuZykge1xuICAgICAgICAgICAgTC5FZGl0YWJsZS5QYXRoRWRpdG9yLnByb3RvdHlwZS5uZXdQb2ludEZvcndhcmQuY2FsbCh0aGlzLCBsYXRsbmcpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnRvb2xzLmJhY2t3YXJkTGluZUd1aWRlLl9sYXRsbmdzLmxlbmd0aCkgdGhpcy50b29scy5hbmNob3JCYWNrd2FyZExpbmVHdWlkZShsYXRsbmcpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2RyYXduTGF0TG5ncy5sZW5ndGggPT09IDIpIHRoaXMudG9vbHMuYXR0YWNoQmFja3dhcmRMaW5lR3VpZGUoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBhZGROZXdFbXB0eUhvbGU6IGZ1bmN0aW9uIChsYXRsbmcpIHtcbiAgICAgICAgICAgIHRoaXMuZW5zdXJlTm90RmxhdCgpO1xuICAgICAgICAgICAgdmFyIGxhdGxuZ3MgPSB0aGlzLmZlYXR1cmUuc2hhcGVBdChsYXRsbmcpO1xuICAgICAgICAgICAgaWYgKCFsYXRsbmdzKSByZXR1cm47XG4gICAgICAgICAgICB2YXIgaG9sZXMgPSBbXTtcbiAgICAgICAgICAgIGxhdGxuZ3MucHVzaChob2xlcyk7XG4gICAgICAgICAgICByZXR1cm4gaG9sZXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8g8J+Ngm1ldGhvZCBuZXdIb2xlKGxhdGxuZz86IEwuTGF0TG5nLCBpbmRleDogaW50KVxuICAgICAgICAvLyBTZXQgdXAgZHJhd2luZyB0b29scyBmb3IgY3JlYXRpbmcgYSBuZXcgaG9sZSBvbiB0aGUgUG9seWdvbi4gSWYgdGhlIGBsYXRsbmdgIHBhcmFtIGlzIGdpdmVuLCBhIGZpcnN0IHBvaW50IGlzIGNyZWF0ZWQuXG4gICAgICAgIG5ld0hvbGU6IGZ1bmN0aW9uIChsYXRsbmcpIHtcbiAgICAgICAgICAgIHZhciBob2xlcyA9IHRoaXMuYWRkTmV3RW1wdHlIb2xlKGxhdGxuZyk7XG4gICAgICAgICAgICBpZiAoIWhvbGVzKSByZXR1cm47XG4gICAgICAgICAgICB0aGlzLnNldERyYXduTGF0TG5ncyhob2xlcyk7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0RHJhd2luZ0ZvcndhcmQoKTtcbiAgICAgICAgICAgIGlmIChsYXRsbmcpIHRoaXMubmV3UG9pbnRGb3J3YXJkKGxhdGxuZyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWRkTmV3RW1wdHlTaGFwZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZmVhdHVyZS5fbGF0bG5ncy5sZW5ndGggJiYgdGhpcy5mZWF0dXJlLl9sYXRsbmdzWzBdLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBzaGFwZSA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kU2hhcGUoc2hhcGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzaGFwZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmVhdHVyZS5fbGF0bG5ncztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBlbnN1cmVNdWx0aTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZmVhdHVyZS5fbGF0bG5ncy5sZW5ndGggJiYgaXNGbGF0KHRoaXMuZmVhdHVyZS5fbGF0bG5nc1swXSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZlYXR1cmUuX2xhdGxuZ3MgPSBbdGhpcy5mZWF0dXJlLl9sYXRsbmdzXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBlbnN1cmVOb3RGbGF0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZmVhdHVyZS5fbGF0bG5ncy5sZW5ndGggfHwgaXNGbGF0KHRoaXMuZmVhdHVyZS5fbGF0bG5ncykpIHRoaXMuZmVhdHVyZS5fbGF0bG5ncyA9IFt0aGlzLmZlYXR1cmUuX2xhdGxuZ3NdO1xuICAgICAgICB9LFxuXG4gICAgICAgIHZlcnRleENhbkJlRGVsZXRlZDogZnVuY3Rpb24gKHZlcnRleCkge1xuICAgICAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMuZmVhdHVyZS5wYXJlbnRTaGFwZSh2ZXJ0ZXgubGF0bG5ncyksXG4gICAgICAgICAgICAgICAgaWR4ID0gTC5VdGlsLmluZGV4T2YocGFyZW50LCB2ZXJ0ZXgubGF0bG5ncyk7XG4gICAgICAgICAgICBpZiAoaWR4ID4gMCkgcmV0dXJuIHRydWU7ICAvLyBIb2xlcyBjYW4gYmUgdG90YWxseSBkZWxldGVkIHdpdGhvdXQgcmVtb3ZpbmcgdGhlIGxheWVyIGl0c2VsZi5cbiAgICAgICAgICAgIHJldHVybiBMLkVkaXRhYmxlLlBhdGhFZGl0b3IucHJvdG90eXBlLnZlcnRleENhbkJlRGVsZXRlZC5jYWxsKHRoaXMsIHZlcnRleCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0RGVmYXVsdExhdExuZ3M6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5mZWF0dXJlLl9sYXRsbmdzLmxlbmd0aCkgdGhpcy5mZWF0dXJlLl9sYXRsbmdzLnB1c2goW10pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmVhdHVyZS5fbGF0bG5nc1swXTtcbiAgICAgICAgfSxcblxuICAgICAgICBmb3JtYXRTaGFwZTogZnVuY3Rpb24gKHNoYXBlKSB7XG4gICAgICAgICAgICAvLyBbWzEsIDJdLCBbMywgNF1dID0+IG11c3QgYmUgbmVzdGVkXG4gICAgICAgICAgICAvLyBbXSA9PiBtdXN0IGJlIG5lc3RlZFxuICAgICAgICAgICAgLy8gW1tdXSA9PiBpcyBhbHJlYWR5IG5lc3RlZFxuICAgICAgICAgICAgaWYgKGlzRmxhdChzaGFwZSkgJiYgKCFzaGFwZVswXSB8fCBzaGFwZVswXS5sZW5ndGggIT09IDApKSByZXR1cm4gW3NoYXBlXTtcbiAgICAgICAgICAgIGVsc2UgcmV0dXJuIHNoYXBlO1xuICAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIC8vIPCfjYJuYW1lc3BhY2UgRWRpdGFibGU7IPCfjYJjbGFzcyBSZWN0YW5nbGVFZGl0b3I7IPCfjYJha2EgTC5FZGl0YWJsZS5SZWN0YW5nbGVFZGl0b3JcbiAgICAvLyDwn42CaW5oZXJpdHMgUGF0aEVkaXRvclxuICAgIEwuRWRpdGFibGUuUmVjdGFuZ2xlRWRpdG9yID0gTC5FZGl0YWJsZS5QYXRoRWRpdG9yLmV4dGVuZCh7XG5cbiAgICAgICAgQ0xPU0VEOiB0cnVlLFxuICAgICAgICBNSU5fVkVSVEVYOiA0LFxuXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIHNraXBNaWRkbGVNYXJrZXJzOiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgZXh0ZW5kQm91bmRzOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gZS52ZXJ0ZXguZ2V0SW5kZXgoKSxcbiAgICAgICAgICAgICAgICBuZXh0ID0gZS52ZXJ0ZXguZ2V0TmV4dCgpLFxuICAgICAgICAgICAgICAgIHByZXZpb3VzID0gZS52ZXJ0ZXguZ2V0UHJldmlvdXMoKSxcbiAgICAgICAgICAgICAgICBvcHBvc2l0ZUluZGV4ID0gKGluZGV4ICsgMikgJSA0LFxuICAgICAgICAgICAgICAgIG9wcG9zaXRlID0gZS52ZXJ0ZXgubGF0bG5nc1tvcHBvc2l0ZUluZGV4XSxcbiAgICAgICAgICAgICAgICBib3VuZHMgPSBuZXcgTC5MYXRMbmdCb3VuZHMoZS5sYXRsbmcsIG9wcG9zaXRlKTtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBsYXRsbmdzIGJ5IGhhbmQgdG8gcHJlc2VydmUgb3JkZXIuXG4gICAgICAgICAgICBwcmV2aW91cy5sYXRsbmcudXBkYXRlKFtlLmxhdGxuZy5sYXQsIG9wcG9zaXRlLmxuZ10pO1xuICAgICAgICAgICAgbmV4dC5sYXRsbmcudXBkYXRlKFtvcHBvc2l0ZS5sYXQsIGUubGF0bG5nLmxuZ10pO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVCb3VuZHMoYm91bmRzKTtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaFZlcnRleE1hcmtlcnMoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvbkRyYXdpbmdNb3VzZURvd246IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBMLkVkaXRhYmxlLlBhdGhFZGl0b3IucHJvdG90eXBlLm9uRHJhd2luZ01vdXNlRG93bi5jYWxsKHRoaXMsIGUpO1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0KCk7XG4gICAgICAgICAgICB2YXIgbGF0bG5ncyA9IHRoaXMuZ2V0RGVmYXVsdExhdExuZ3MoKTtcbiAgICAgICAgICAgIC8vIEwuUG9seWdvbi5fY29udmVydExhdExuZ3MgcmVtb3ZlcyBsYXN0IGxhdGxuZyBpZiBpdCBlcXVhbHMgZmlyc3QgcG9pbnQsXG4gICAgICAgICAgICAvLyB3aGljaCBpcyB0aGUgY2FzZSBoZXJlIGFzIGFsbCBsYXRsbmdzIGFyZSBbMCwgMF1cbiAgICAgICAgICAgIGlmIChsYXRsbmdzLmxlbmd0aCA9PT0gMykgbGF0bG5ncy5wdXNoKGUubGF0bG5nKTtcbiAgICAgICAgICAgIHZhciBib3VuZHMgPSBuZXcgTC5MYXRMbmdCb3VuZHMoZS5sYXRsbmcsIGUubGF0bG5nKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQm91bmRzKGJvdW5kcyk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUxhdExuZ3MoYm91bmRzKTtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaCgpO1xuICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICAgICAgLy8gU3RvcCBkcmFnZ2luZyBtYXAuXG4gICAgICAgICAgICAvLyBMLkRyYWdnYWJsZSBoYXMgdHdvIHdvcmtmbG93czpcbiAgICAgICAgICAgIC8vIC0gbW91c2Vkb3duID0+IG1vdXNlbW92ZSA9PiBtb3VzZXVwXG4gICAgICAgICAgICAvLyAtIHRvdWNoc3RhcnQgPT4gdG91Y2htb3ZlID0+IHRvdWNoZW5kXG4gICAgICAgICAgICAvLyBQcm9ibGVtOiBMLk1hcC5UYXAgZG9lcyBub3QgYWxsb3cgdXMgdG8gbGlzdGVuIHRvIHRvdWNoc3RhcnQsIHNvIHdlIG9ubHlcbiAgICAgICAgICAgIC8vIGNhbiBkZWFsIHdpdGggbW91c2Vkb3duLCBidXQgdGhlbiB3aGVuIGluIGEgdG91Y2ggZGV2aWNlLCB3ZSBhcmUgZGVhbGluZyB3aXRoXG4gICAgICAgICAgICAvLyBzaW11bGF0ZWQgZXZlbnRzIChhY3R1YWxseSBzaW11bGF0ZWQgYnkgTC5NYXAuVGFwKSwgd2hpY2ggYXJlIG5vIG1vcmUgdGFrZW5cbiAgICAgICAgICAgIC8vIGludG8gYWNjb3VudCBieSBMLkRyYWdnYWJsZS5cbiAgICAgICAgICAgIC8vIFJlZi46IGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQuRWRpdGFibGUvaXNzdWVzLzEwM1xuICAgICAgICAgICAgZS5vcmlnaW5hbEV2ZW50Ll9zaW11bGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMubWFwLmRyYWdnaW5nLl9kcmFnZ2FibGUuX29uVXAoZS5vcmlnaW5hbEV2ZW50KTtcbiAgICAgICAgICAgIC8vIE5vdyB0cmFuc2ZlciBvbmdvaW5nIGRyYWcgYWN0aW9uIHRvIHRoZSBib3R0b20gcmlnaHQgY29ybmVyLlxuICAgICAgICAgICAgLy8gU2hvdWxkIHdlIHJlZmluZSB3aGljaCBjb3JuZXIgd2lsbCBoYW5kbGUgdGhlIGRyYWcgYWNjb3JkaW5nIHRvXG4gICAgICAgICAgICAvLyBkcmFnIGRpcmVjdGlvbj9cbiAgICAgICAgICAgIGxhdGxuZ3NbM10uX192ZXJ0ZXguZHJhZ2dpbmcuX2RyYWdnYWJsZS5fb25Eb3duKGUub3JpZ2luYWxFdmVudCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25EcmF3aW5nTW91c2VVcDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHRoaXMuY29tbWl0RHJhd2luZyhlKTtcbiAgICAgICAgICAgIGUub3JpZ2luYWxFdmVudC5fc2ltdWxhdGVkID0gZmFsc2U7XG4gICAgICAgICAgICBMLkVkaXRhYmxlLlBhdGhFZGl0b3IucHJvdG90eXBlLm9uRHJhd2luZ01vdXNlVXAuY2FsbCh0aGlzLCBlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvbkRyYXdpbmdNb3VzZU1vdmU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLm9yaWdpbmFsRXZlbnQuX3NpbXVsYXRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgTC5FZGl0YWJsZS5QYXRoRWRpdG9yLnByb3RvdHlwZS5vbkRyYXdpbmdNb3VzZU1vdmUuY2FsbCh0aGlzLCBlKTtcbiAgICAgICAgfSxcblxuXG4gICAgICAgIGdldERlZmF1bHRMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuICAgICAgICAgICAgcmV0dXJuIGxhdGxuZ3MgfHwgdGhpcy5mZWF0dXJlLl9sYXRsbmdzWzBdO1xuICAgICAgICB9LFxuXG4gICAgICAgIHVwZGF0ZUJvdW5kczogZnVuY3Rpb24gKGJvdW5kcykge1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlLl9ib3VuZHMgPSBib3VuZHM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdXBkYXRlTGF0TG5nczogZnVuY3Rpb24gKGJvdW5kcykge1xuICAgICAgICAgICAgdmFyIGxhdGxuZ3MgPSB0aGlzLmdldERlZmF1bHRMYXRMbmdzKCksXG4gICAgICAgICAgICAgICAgbmV3TGF0bG5ncyA9IHRoaXMuZmVhdHVyZS5fYm91bmRzVG9MYXRMbmdzKGJvdW5kcyk7XG4gICAgICAgICAgICAvLyBLZWVwIHJlZmVyZW5jZXMuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhdGxuZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsYXRsbmdzW2ldLnVwZGF0ZShuZXdMYXRsbmdzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICAvLyDwn42CbmFtZXNwYWNlIEVkaXRhYmxlOyDwn42CY2xhc3MgQ2lyY2xlRWRpdG9yOyDwn42CYWthIEwuRWRpdGFibGUuQ2lyY2xlRWRpdG9yXG4gICAgLy8g8J+NgmluaGVyaXRzIFBhdGhFZGl0b3JcbiAgICBMLkVkaXRhYmxlLkNpcmNsZUVkaXRvciA9IEwuRWRpdGFibGUuUGF0aEVkaXRvci5leHRlbmQoe1xuXG4gICAgICAgIE1JTl9WRVJURVg6IDIsXG5cbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgc2tpcE1pZGRsZU1hcmtlcnM6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICBpbml0aWFsaXplOiBmdW5jdGlvbiAobWFwLCBmZWF0dXJlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBMLkVkaXRhYmxlLlBhdGhFZGl0b3IucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCBtYXAsIGZlYXR1cmUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5fcmVzaXplTGF0TG5nID0gdGhpcy5jb21wdXRlUmVzaXplTGF0TG5nKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY29tcHV0ZVJlc2l6ZUxhdExuZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gV2hpbGUgY2lyY2xlIGlzIG5vdCBhZGRlZCB0byB0aGUgbWFwLCBfcmFkaXVzIGlzIG5vdCBzZXQuXG4gICAgICAgICAgICB2YXIgZGVsdGEgPSAodGhpcy5mZWF0dXJlLl9yYWRpdXMgfHwgdGhpcy5mZWF0dXJlLl9tUmFkaXVzKSAqIE1hdGguY29zKE1hdGguUEkgLyA0KSxcbiAgICAgICAgICAgICAgICBwb2ludCA9IHRoaXMubWFwLnByb2plY3QodGhpcy5mZWF0dXJlLl9sYXRsbmcpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFwLnVucHJvamVjdChbcG9pbnQueCArIGRlbHRhLCBwb2ludC55IC0gZGVsdGFdKTtcbiAgICAgICAgfSxcblxuICAgICAgICB1cGRhdGVSZXNpemVMYXRMbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2l6ZUxhdExuZy51cGRhdGUodGhpcy5jb21wdXRlUmVzaXplTGF0TG5nKCkpO1xuICAgICAgICAgICAgdGhpcy5fcmVzaXplTGF0TG5nLl9fdmVydGV4LnVwZGF0ZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldExhdExuZ3M6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBbdGhpcy5mZWF0dXJlLl9sYXRsbmcsIHRoaXMuX3Jlc2l6ZUxhdExuZ107XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0RGVmYXVsdExhdExuZ3M6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldExhdExuZ3MoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvblZlcnRleE1hcmtlckRyYWc6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAoZS52ZXJ0ZXguZ2V0SW5kZXgoKSA9PT0gMSkgdGhpcy5yZXNpemUoZSk7XG4gICAgICAgICAgICBlbHNlIHRoaXMudXBkYXRlUmVzaXplTGF0TG5nKGUpO1xuICAgICAgICAgICAgTC5FZGl0YWJsZS5QYXRoRWRpdG9yLnByb3RvdHlwZS5vblZlcnRleE1hcmtlckRyYWcuY2FsbCh0aGlzLCBlKTtcbiAgICAgICAgfSxcblxuICAgICAgICByZXNpemU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgcmFkaXVzID0gdGhpcy5mZWF0dXJlLl9sYXRsbmcuZGlzdGFuY2VUbyhlLmxhdGxuZyk7XG4gICAgICAgICAgICB0aGlzLmZlYXR1cmUuc2V0UmFkaXVzKHJhZGl1cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25EcmF3aW5nTW91c2VEb3duOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgTC5FZGl0YWJsZS5QYXRoRWRpdG9yLnByb3RvdHlwZS5vbkRyYXdpbmdNb3VzZURvd24uY2FsbCh0aGlzLCBlKTtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2l6ZUxhdExuZy51cGRhdGUoZS5sYXRsbmcpO1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlLl9sYXRsbmcudXBkYXRlKGUubGF0bG5nKTtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdCgpO1xuICAgICAgICAgICAgLy8gU3RvcCBkcmFnZ2luZyBtYXAuXG4gICAgICAgICAgICBlLm9yaWdpbmFsRXZlbnQuX3NpbXVsYXRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5tYXAuZHJhZ2dpbmcuX2RyYWdnYWJsZS5fb25VcChlLm9yaWdpbmFsRXZlbnQpO1xuICAgICAgICAgICAgLy8gTm93IHRyYW5zZmVyIG9uZ29pbmcgZHJhZyBhY3Rpb24gdG8gdGhlIHJhZGl1cyBoYW5kbGVyLlxuICAgICAgICAgICAgdGhpcy5fcmVzaXplTGF0TG5nLl9fdmVydGV4LmRyYWdnaW5nLl9kcmFnZ2FibGUuX29uRG93bihlLm9yaWdpbmFsRXZlbnQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uRHJhd2luZ01vdXNlVXA6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB0aGlzLmNvbW1pdERyYXdpbmcoZSk7XG4gICAgICAgICAgICBlLm9yaWdpbmFsRXZlbnQuX3NpbXVsYXRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgTC5FZGl0YWJsZS5QYXRoRWRpdG9yLnByb3RvdHlwZS5vbkRyYXdpbmdNb3VzZVVwLmNhbGwodGhpcywgZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25EcmF3aW5nTW91c2VNb3ZlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS5vcmlnaW5hbEV2ZW50Ll9zaW11bGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIEwuRWRpdGFibGUuUGF0aEVkaXRvci5wcm90b3R5cGUub25EcmF3aW5nTW91c2VNb3ZlLmNhbGwodGhpcywgZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25EcmFnOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgTC5FZGl0YWJsZS5QYXRoRWRpdG9yLnByb3RvdHlwZS5vbkRyYWcuY2FsbCh0aGlzLCBlKTtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZS5kcmFnZ2luZy51cGRhdGVMYXRMbmcodGhpcy5fcmVzaXplTGF0TG5nKTtcbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICAvLyDwn42CbmFtZXNwYWNlIEVkaXRhYmxlOyDwn42CY2xhc3MgRWRpdGFibGVNaXhpblxuICAgIC8vIGBFZGl0YWJsZU1peGluYCBpcyBpbmNsdWRlZCB0byBgTC5Qb2x5bGluZWAsIGBMLlBvbHlnb25gLCBgTC5SZWN0YW5nbGVgLCBgTC5DaXJjbGVgXG4gICAgLy/CoGFuZCBgTC5NYXJrZXJgLiBJdCBhZGRzIHNvbWUgbWV0aG9kcyB0byB0aGVtLlxuICAgIC8vICpXaGVuIGVkaXRpbmcgaXMgZW5hYmxlZCwgdGhlIGVkaXRvciBpcyBhY2Nlc3NpYmxlIG9uIHRoZSBpbnN0YW5jZSB3aXRoIHRoZVxuICAgIC8vIGBlZGl0b3JgIHByb3BlcnR5LipcbiAgICB2YXIgRWRpdGFibGVNaXhpbiA9IHtcblxuICAgICAgICBjcmVhdGVFZGl0b3I6IGZ1bmN0aW9uIChtYXApIHtcbiAgICAgICAgICAgIG1hcCA9IG1hcCB8fCB0aGlzLl9tYXA7XG4gICAgICAgICAgICB2YXIgdG9vbHMgPSAodGhpcy5vcHRpb25zLmVkaXRPcHRpb25zIHx8IHt9KS5lZGl0VG9vbHMgfHwgbWFwLmVkaXRUb29scztcbiAgICAgICAgICAgIGlmICghdG9vbHMpIHRocm93IEVycm9yKCdVbmFibGUgdG8gZGV0ZWN0IEVkaXRhYmxlIGluc3RhbmNlLicpO1xuICAgICAgICAgICAgdmFyIEtsYXNzID0gdGhpcy5vcHRpb25zLmVkaXRvckNsYXNzIHx8IHRoaXMuZ2V0RWRpdG9yQ2xhc3ModG9vbHMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBLbGFzcyhtYXAsIHRoaXMsIHRoaXMub3B0aW9ucy5lZGl0T3B0aW9ucyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8g8J+Ngm1ldGhvZCBlbmFibGVFZGl0KG1hcD86IEwuTWFwKTogdGhpcy5lZGl0b3JcbiAgICAgICAgLy8gRW5hYmxlIGVkaXRpbmcsIGJ5IGNyZWF0aW5nIGFuIGVkaXRvciBpZiBub3QgZXhpc3RpbmcsIGFuZCB0aGVuIGNhbGxpbmcgYGVuYWJsZWAgb24gaXQuXG4gICAgICAgIGVuYWJsZUVkaXQ6IGZ1bmN0aW9uIChtYXApIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5lZGl0b3IpIHRoaXMuY3JlYXRlRWRpdG9yKG1hcCk7XG4gICAgICAgICAgICB0aGlzLmVkaXRvci5lbmFibGUoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVkaXRvcjtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyDwn42CbWV0aG9kIGVkaXRFbmFibGVkKCk6IGJvb2xlYW5cbiAgICAgICAgLy8gUmV0dXJuIHRydWUgaWYgY3VycmVudCBpbnN0YW5jZSBoYXMgYW4gZWRpdG9yIGF0dGFjaGVkLCBhbmQgdGhpcyBlZGl0b3IgaXMgZW5hYmxlZC5cbiAgICAgICAgZWRpdEVuYWJsZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVkaXRvciAmJiB0aGlzLmVkaXRvci5lbmFibGVkKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8g8J+Ngm1ldGhvZCBkaXNhYmxlRWRpdCgpXG4gICAgICAgIC8vIERpc2FibGUgZWRpdGluZywgYWxzbyByZW1vdmUgdGhlIGVkaXRvciBwcm9wZXJ0eSByZWZlcmVuY2UuXG4gICAgICAgIGRpc2FibGVFZGl0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5lZGl0b3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVkaXRvci5kaXNhYmxlKCk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuZWRpdG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIPCfjYJtZXRob2QgdG9nZ2xlRWRpdCgpXG4gICAgICAgIC8vIEVuYWJsZSBvciBkaXNhYmxlIGVkaXRpbmcsIGFjY29yZGluZyB0byBjdXJyZW50IHN0YXR1cy5cbiAgICAgICAgdG9nZ2xlRWRpdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZWRpdEVuYWJsZWQoKSkgdGhpcy5kaXNhYmxlRWRpdCgpO1xuICAgICAgICAgICAgZWxzZSB0aGlzLmVuYWJsZUVkaXQoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfb25FZGl0YWJsZUFkZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZWRpdG9yKSB0aGlzLmVuYWJsZUVkaXQoKTtcbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIHZhciBQb2x5bGluZU1peGluID0ge1xuXG4gICAgICAgIGdldEVkaXRvckNsYXNzOiBmdW5jdGlvbiAodG9vbHMpIHtcbiAgICAgICAgICAgIHJldHVybiAodG9vbHMgJiYgdG9vbHMub3B0aW9ucy5wb2x5bGluZUVkaXRvckNsYXNzKSA/IHRvb2xzLm9wdGlvbnMucG9seWxpbmVFZGl0b3JDbGFzcyA6IEwuRWRpdGFibGUuUG9seWxpbmVFZGl0b3I7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2hhcGVBdDogZnVuY3Rpb24gKGxhdGxuZywgbGF0bG5ncykge1xuICAgICAgICAgICAgLy8gV2UgY2FuIGhhdmUgdGhvc2UgY2FzZXM6XG4gICAgICAgICAgICAvLyAtIGxhdGxuZ3MgYXJlIGp1c3QgYSBmbGF0IGFycmF5IG9mIGxhdGxuZ3MsIHVzZSB0aGlzXG4gICAgICAgICAgICAvLyAtIGxhdGxuZ3MgaXMgYW4gYXJyYXkgb2YgYXJyYXlzIG9mIGxhdGxuZ3MsIGxvb3Agb3ZlclxuICAgICAgICAgICAgdmFyIHNoYXBlID0gbnVsbDtcbiAgICAgICAgICAgIGxhdGxuZ3MgPSBsYXRsbmdzIHx8IHRoaXMuX2xhdGxuZ3M7XG4gICAgICAgICAgICBpZiAoIWxhdGxuZ3MubGVuZ3RoKSByZXR1cm4gc2hhcGU7XG4gICAgICAgICAgICBlbHNlIGlmIChpc0ZsYXQobGF0bG5ncykgJiYgdGhpcy5pc0luTGF0TG5ncyhsYXRsbmcsIGxhdGxuZ3MpKSBzaGFwZSA9IGxhdGxuZ3M7XG4gICAgICAgICAgICBlbHNlIGZvciAodmFyIGkgPSAwOyBpIDwgbGF0bG5ncy5sZW5ndGg7IGkrKykgaWYgKHRoaXMuaXNJbkxhdExuZ3MobGF0bG5nLCBsYXRsbmdzW2ldKSkgcmV0dXJuIGxhdGxuZ3NbaV07XG4gICAgICAgICAgICByZXR1cm4gc2hhcGU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNJbkxhdExuZ3M6IGZ1bmN0aW9uIChsLCBsYXRsbmdzKSB7XG4gICAgICAgICAgICBpZiAoIWxhdGxuZ3MpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHZhciBpLCBrLCBsZW4sIHBhcnQgPSBbXSwgcCxcbiAgICAgICAgICAgICAgICB3ID0gdGhpcy5fY2xpY2tUb2xlcmFuY2UoKTtcbiAgICAgICAgICAgIHRoaXMuX3Byb2plY3RMYXRsbmdzKGxhdGxuZ3MsIHBhcnQsIHRoaXMuX3B4Qm91bmRzKTtcbiAgICAgICAgICAgIHBhcnQgPSBwYXJ0WzBdO1xuICAgICAgICAgICAgcCA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQobCk7XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5fcHhCb3VuZHMuY29udGFpbnMocCkpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICAgICAgICBmb3IgKGkgPSAxLCBsZW4gPSBwYXJ0Lmxlbmd0aCwgayA9IDA7IGkgPCBsZW47IGsgPSBpKyspIHtcblxuICAgICAgICAgICAgICAgIGlmIChMLkxpbmVVdGlsLnBvaW50VG9TZWdtZW50RGlzdGFuY2UocCwgcGFydFtrXSwgcGFydFtpXSkgPD0gdykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICB2YXIgUG9seWdvbk1peGluID0ge1xuXG4gICAgICAgIGdldEVkaXRvckNsYXNzOiBmdW5jdGlvbiAodG9vbHMpIHtcbiAgICAgICAgICAgIHJldHVybiAodG9vbHMgJiYgdG9vbHMub3B0aW9ucy5wb2x5Z29uRWRpdG9yQ2xhc3MpID8gdG9vbHMub3B0aW9ucy5wb2x5Z29uRWRpdG9yQ2xhc3MgOiBMLkVkaXRhYmxlLlBvbHlnb25FZGl0b3I7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2hhcGVBdDogZnVuY3Rpb24gKGxhdGxuZywgbGF0bG5ncykge1xuICAgICAgICAgICAgLy8gV2UgY2FuIGhhdmUgdGhvc2UgY2FzZXM6XG4gICAgICAgICAgICAvLyAtIGxhdGxuZ3MgYXJlIGp1c3QgYSBmbGF0IGFycmF5IG9mIGxhdGxuZ3MsIHVzZSB0aGlzXG4gICAgICAgICAgICAvLyAtIGxhdGxuZ3MgaXMgYW4gYXJyYXkgb2YgYXJyYXlzIG9mIGxhdGxuZ3MsIHRoaXMgaXMgYSBzaW1wbGUgcG9seWdvbiAobWF5YmUgd2l0aCBob2xlcyksIHVzZSB0aGUgZmlyc3RcbiAgICAgICAgICAgIC8vIC0gbGF0bG5ncyBpcyBhbiBhcnJheSBvZiBhcnJheXMgb2YgYXJyYXlzLCB0aGlzIGlzIGEgbXVsdGksIGxvb3Agb3ZlclxuICAgICAgICAgICAgdmFyIHNoYXBlID0gbnVsbDtcbiAgICAgICAgICAgIGxhdGxuZ3MgPSBsYXRsbmdzIHx8IHRoaXMuX2xhdGxuZ3M7XG4gICAgICAgICAgICBpZiAoIWxhdGxuZ3MubGVuZ3RoKSByZXR1cm4gc2hhcGU7XG4gICAgICAgICAgICBlbHNlIGlmIChpc0ZsYXQobGF0bG5ncykgJiYgdGhpcy5pc0luTGF0TG5ncyhsYXRsbmcsIGxhdGxuZ3MpKSBzaGFwZSA9IGxhdGxuZ3M7XG4gICAgICAgICAgICBlbHNlIGlmIChpc0ZsYXQobGF0bG5nc1swXSkgJiYgdGhpcy5pc0luTGF0TG5ncyhsYXRsbmcsIGxhdGxuZ3NbMF0pKSBzaGFwZSA9IGxhdGxuZ3M7XG4gICAgICAgICAgICBlbHNlIGZvciAodmFyIGkgPSAwOyBpIDwgbGF0bG5ncy5sZW5ndGg7IGkrKykgaWYgKHRoaXMuaXNJbkxhdExuZ3MobGF0bG5nLCBsYXRsbmdzW2ldWzBdKSkgcmV0dXJuIGxhdGxuZ3NbaV07XG4gICAgICAgICAgICByZXR1cm4gc2hhcGU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNJbkxhdExuZ3M6IGZ1bmN0aW9uIChsLCBsYXRsbmdzKSB7XG4gICAgICAgICAgICB2YXIgaW5zaWRlID0gZmFsc2UsIGwxLCBsMiwgaiwgaywgbGVuMjtcblxuICAgICAgICAgICAgZm9yIChqID0gMCwgbGVuMiA9IGxhdGxuZ3MubGVuZ3RoLCBrID0gbGVuMiAtIDE7IGogPCBsZW4yOyBrID0gaisrKSB7XG4gICAgICAgICAgICAgICAgbDEgPSBsYXRsbmdzW2pdO1xuICAgICAgICAgICAgICAgIGwyID0gbGF0bG5nc1trXTtcblxuICAgICAgICAgICAgICAgIGlmICgoKGwxLmxhdCA+IGwubGF0KSAhPT0gKGwyLmxhdCA+IGwubGF0KSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIChsLmxuZyA8IChsMi5sbmcgLSBsMS5sbmcpICogKGwubGF0IC0gbDEubGF0KSAvIChsMi5sYXQgLSBsMS5sYXQpICsgbDEubG5nKSkge1xuICAgICAgICAgICAgICAgICAgICBpbnNpZGUgPSAhaW5zaWRlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGluc2lkZTtcbiAgICAgICAgfSxcblxuICAgICAgICBwYXJlbnRTaGFwZTogZnVuY3Rpb24gKHNoYXBlLCBsYXRsbmdzKSB7XG4gICAgICAgICAgICBsYXRsbmdzID0gbGF0bG5ncyB8fCB0aGlzLl9sYXRsbmdzO1xuICAgICAgICAgICAgaWYgKCFsYXRsbmdzKSByZXR1cm47XG4gICAgICAgICAgICB2YXIgaWR4ID0gTC5VdGlsLmluZGV4T2YobGF0bG5ncywgc2hhcGUpO1xuICAgICAgICAgICAgaWYgKGlkeCAhPT0gLTEpIHJldHVybiBsYXRsbmdzO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXRsbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWR4ID0gTC5VdGlsLmluZGV4T2YobGF0bG5nc1tpXSwgc2hhcGUpO1xuICAgICAgICAgICAgICAgIGlmIChpZHggIT09IC0xKSByZXR1cm4gbGF0bG5nc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfTtcblxuXG4gICAgdmFyIE1hcmtlck1peGluID0ge1xuXG4gICAgICAgIGdldEVkaXRvckNsYXNzOiBmdW5jdGlvbiAodG9vbHMpIHtcbiAgICAgICAgICAgIHJldHVybiAodG9vbHMgJiYgdG9vbHMub3B0aW9ucy5tYXJrZXJFZGl0b3JDbGFzcykgPyB0b29scy5vcHRpb25zLm1hcmtlckVkaXRvckNsYXNzIDogTC5FZGl0YWJsZS5NYXJrZXJFZGl0b3I7XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICB2YXIgUmVjdGFuZ2xlTWl4aW4gPSB7XG5cbiAgICAgICAgZ2V0RWRpdG9yQ2xhc3M6IGZ1bmN0aW9uICh0b29scykge1xuICAgICAgICAgICAgcmV0dXJuICh0b29scyAmJiB0b29scy5vcHRpb25zLnJlY3RhbmdsZUVkaXRvckNsYXNzKSA/IHRvb2xzLm9wdGlvbnMucmVjdGFuZ2xlRWRpdG9yQ2xhc3MgOiBMLkVkaXRhYmxlLlJlY3RhbmdsZUVkaXRvcjtcbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIHZhciBDaXJjbGVNaXhpbiA9IHtcblxuICAgICAgICBnZXRFZGl0b3JDbGFzczogZnVuY3Rpb24gKHRvb2xzKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRvb2xzICYmIHRvb2xzLm9wdGlvbnMuY2lyY2xlRWRpdG9yQ2xhc3MpID8gdG9vbHMub3B0aW9ucy5jaXJjbGVFZGl0b3JDbGFzcyA6IEwuRWRpdGFibGUuQ2lyY2xlRWRpdG9yO1xuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgdmFyIGtlZXBFZGl0YWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHlvdSBjYW4gcmVtb3ZlL3JlYWRkIGFuIGVkaXRhYmxlIGxheWVyLlxuICAgICAgICB0aGlzLm9uKCdhZGQnLCB0aGlzLl9vbkVkaXRhYmxlQWRkKTtcbiAgICB9O1xuXG4gICAgdmFyIGlzRmxhdCA9IEwuTGluZVV0aWwuaXNGbGF0IHx8IEwuTGluZVV0aWwuX2ZsYXQgfHwgTC5Qb2x5bGluZS5fZmxhdDsgIC8vIDw9PiAxLjEgY29tcGF0LlxuXG5cbiAgICBpZiAoTC5Qb2x5bGluZSkge1xuICAgICAgICBMLlBvbHlsaW5lLmluY2x1ZGUoRWRpdGFibGVNaXhpbik7XG4gICAgICAgIEwuUG9seWxpbmUuaW5jbHVkZShQb2x5bGluZU1peGluKTtcbiAgICAgICAgTC5Qb2x5bGluZS5hZGRJbml0SG9vayhrZWVwRWRpdGFibGUpO1xuICAgIH1cbiAgICBpZiAoTC5Qb2x5Z29uKSB7XG4gICAgICAgIEwuUG9seWdvbi5pbmNsdWRlKEVkaXRhYmxlTWl4aW4pO1xuICAgICAgICBMLlBvbHlnb24uaW5jbHVkZShQb2x5Z29uTWl4aW4pO1xuICAgIH1cbiAgICBpZiAoTC5NYXJrZXIpIHtcbiAgICAgICAgTC5NYXJrZXIuaW5jbHVkZShFZGl0YWJsZU1peGluKTtcbiAgICAgICAgTC5NYXJrZXIuaW5jbHVkZShNYXJrZXJNaXhpbik7XG4gICAgICAgIEwuTWFya2VyLmFkZEluaXRIb29rKGtlZXBFZGl0YWJsZSk7XG4gICAgfVxuICAgIGlmIChMLlJlY3RhbmdsZSkge1xuICAgICAgICBMLlJlY3RhbmdsZS5pbmNsdWRlKEVkaXRhYmxlTWl4aW4pO1xuICAgICAgICBMLlJlY3RhbmdsZS5pbmNsdWRlKFJlY3RhbmdsZU1peGluKTtcbiAgICB9XG4gICAgaWYgKEwuQ2lyY2xlKSB7XG4gICAgICAgIEwuQ2lyY2xlLmluY2x1ZGUoRWRpdGFibGVNaXhpbik7XG4gICAgICAgIEwuQ2lyY2xlLmluY2x1ZGUoQ2lyY2xlTWl4aW4pO1xuICAgIH1cblxuICAgIEwuTGF0TG5nLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAobGF0bG5nKSB7XG4gICAgICAgIGxhdGxuZyA9IEwubGF0TG5nKGxhdGxuZyk7XG4gICAgICAgIHRoaXMubGF0ID0gbGF0bG5nLmxhdDtcbiAgICAgICAgdGhpcy5sbmcgPSBsYXRsbmcubG5nO1xuICAgIH1cblxufSwgd2luZG93KSk7XG4iXX0=\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\nmodule.exports = require(\"leaflet\");\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(0);\n\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// Vue2LeafletEditable.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap ab1e40ceaf21c8c66859","'use strict';\n(function (factory, window) {\n    /*globals define, module, require*/\n\n    // define an AMD module that relies on 'leaflet'\n    if (typeof define === 'function' && define.amd) {\n        define(['leaflet'], factory);\n\n\n    // define a Common JS module that relies on 'leaflet'\n    } else if (typeof exports === 'object') {\n        module.exports = factory(require('leaflet'));\n    }\n\n    // attach your plugin to the global 'L' variable\n    if(typeof window !== 'undefined' && window.L){\n        factory(window.L);\n    }\n\n}(function (L) {\n    // 🍂miniclass CancelableEvent (Event objects)\n    // 🍂method cancel()\n    // Cancel any subsequent action.\n\n    // 🍂miniclass VertexEvent (Event objects)\n    // 🍂property vertex: VertexMarker\n    // The vertex that fires the event.\n\n    // 🍂miniclass ShapeEvent (Event objects)\n    // 🍂property shape: Array\n    // The shape (LatLngs array) subject of the action.\n\n    // 🍂miniclass CancelableVertexEvent (Event objects)\n    // 🍂inherits VertexEvent\n    // 🍂inherits CancelableEvent\n\n    // 🍂miniclass CancelableShapeEvent (Event objects)\n    // 🍂inherits ShapeEvent\n    // 🍂inherits CancelableEvent\n\n    // 🍂miniclass LayerEvent (Event objects)\n    // 🍂property layer: object\n    // The Layer (Marker, Polyline…) subject of the action.\n\n    // 🍂namespace Editable; 🍂class Editable; 🍂aka L.Editable\n    // Main edition handler. By default, it is attached to the map\n    // as `map.editTools` property.\n    // Leaflet.Editable is made to be fully extendable. You have three ways to customize\n    // the behaviour: using options, listening to events, or extending.\n    L.Editable = L.Evented.extend({\n\n        statics: {\n            FORWARD: 1,\n            BACKWARD: -1\n        },\n\n        options: {\n\n            // You can pass them when creating a map using the `editOptions` key.\n            // 🍂option zIndex: int = 1000\n            // The default zIndex of the editing tools.\n            zIndex: 1000,\n\n            // 🍂option polygonClass: class = L.Polygon\n            // Class to be used when creating a new Polygon.\n            polygonClass: L.Polygon,\n\n            // 🍂option polylineClass: class = L.Polyline\n            // Class to be used when creating a new Polyline.\n            polylineClass: L.Polyline,\n\n            // 🍂option markerClass: class = L.Marker\n            // Class to be used when creating a new Marker.\n            markerClass: L.Marker,\n\n            // 🍂option rectangleClass: class = L.Rectangle\n            // Class to be used when creating a new Rectangle.\n            rectangleClass: L.Rectangle,\n\n            // 🍂option circleClass: class = L.Circle\n            // Class to be used when creating a new Circle.\n            circleClass: L.Circle,\n\n            // 🍂option drawingCSSClass: string = 'leaflet-editable-drawing'\n            // CSS class to be added to the map container while drawing.\n            drawingCSSClass: 'leaflet-editable-drawing',\n\n            // 🍂option drawingCursor: const = 'crosshair'\n            // Cursor mode set to the map while drawing.\n            drawingCursor: 'crosshair',\n\n            // 🍂option editLayer: Layer = new L.LayerGroup()\n            // Layer used to store edit tools (vertex, line guide…).\n            editLayer: undefined,\n\n            // 🍂option featuresLayer: Layer = new L.LayerGroup()\n            // Default layer used to store drawn features (Marker, Polyline…).\n            featuresLayer: undefined,\n\n            // 🍂option polylineEditorClass: class = PolylineEditor\n            // Class to be used as Polyline editor.\n            polylineEditorClass: undefined,\n\n            // 🍂option polygonEditorClass: class = PolygonEditor\n            // Class to be used as Polygon editor.\n            polygonEditorClass: undefined,\n\n            // 🍂option markerEditorClass: class = MarkerEditor\n            // Class to be used as Marker editor.\n            markerEditorClass: undefined,\n\n            // 🍂option rectangleEditorClass: class = RectangleEditor\n            // Class to be used as Rectangle editor.\n            rectangleEditorClass: undefined,\n\n            // 🍂option circleEditorClass: class = CircleEditor\n            // Class to be used as Circle editor.\n            circleEditorClass: undefined,\n\n            // 🍂option lineGuideOptions: hash = {}\n            // Options to be passed to the line guides.\n            lineGuideOptions: {},\n\n            // 🍂option skipMiddleMarkers: boolean = false\n            // Set this to true if you don't want middle markers.\n            skipMiddleMarkers: false\n\n        },\n\n        initialize: function (map, options) {\n            L.setOptions(this, options);\n            this._lastZIndex = this.options.zIndex;\n            this.map = map;\n            this.editLayer = this.createEditLayer();\n            this.featuresLayer = this.createFeaturesLayer();\n            this.forwardLineGuide = this.createLineGuide();\n            this.backwardLineGuide = this.createLineGuide();\n        },\n\n        fireAndForward: function (type, e) {\n            e = e || {};\n            e.editTools = this;\n            this.fire(type, e);\n            this.map.fire(type, e);\n        },\n\n        createLineGuide: function () {\n            var options = L.extend({dashArray: '5,10', weight: 1, interactive: false}, this.options.lineGuideOptions);\n            return L.polyline([], options);\n        },\n\n        createVertexIcon: function (options) {\n            return L.Browser.mobile && L.Browser.touch ? new L.Editable.TouchVertexIcon(options) : new L.Editable.VertexIcon(options);\n        },\n\n        createEditLayer: function () {\n            return this.options.editLayer || new L.LayerGroup().addTo(this.map);\n        },\n\n        createFeaturesLayer: function () {\n            return this.options.featuresLayer || new L.LayerGroup().addTo(this.map);\n        },\n\n        moveForwardLineGuide: function (latlng) {\n            if (this.forwardLineGuide._latlngs.length) {\n                this.forwardLineGuide._latlngs[1] = latlng;\n                this.forwardLineGuide._bounds.extend(latlng);\n                this.forwardLineGuide.redraw();\n            }\n        },\n\n        moveBackwardLineGuide: function (latlng) {\n            if (this.backwardLineGuide._latlngs.length) {\n                this.backwardLineGuide._latlngs[1] = latlng;\n                this.backwardLineGuide._bounds.extend(latlng);\n                this.backwardLineGuide.redraw();\n            }\n        },\n\n        anchorForwardLineGuide: function (latlng) {\n            this.forwardLineGuide._latlngs[0] = latlng;\n            this.forwardLineGuide._bounds.extend(latlng);\n            this.forwardLineGuide.redraw();\n        },\n\n        anchorBackwardLineGuide: function (latlng) {\n            this.backwardLineGuide._latlngs[0] = latlng;\n            this.backwardLineGuide._bounds.extend(latlng);\n            this.backwardLineGuide.redraw();\n        },\n\n        attachForwardLineGuide: function () {\n            this.editLayer.addLayer(this.forwardLineGuide);\n        },\n\n        attachBackwardLineGuide: function () {\n            this.editLayer.addLayer(this.backwardLineGuide);\n        },\n\n        detachForwardLineGuide: function () {\n            this.forwardLineGuide.setLatLngs([]);\n            this.editLayer.removeLayer(this.forwardLineGuide);\n        },\n\n        detachBackwardLineGuide: function () {\n            this.backwardLineGuide.setLatLngs([]);\n            this.editLayer.removeLayer(this.backwardLineGuide);\n        },\n\n        blockEvents: function () {\n            // Hack: force map not to listen to other layers events while drawing.\n            if (!this._oldTargets) {\n                this._oldTargets = this.map._targets;\n                this.map._targets = {};\n            }\n        },\n\n        unblockEvents: function () {\n            if (this._oldTargets) {\n                // Reset, but keep targets created while drawing.\n                this.map._targets = L.extend(this.map._targets, this._oldTargets);\n                delete this._oldTargets;\n            }\n        },\n\n        registerForDrawing: function (editor) {\n            if (this._drawingEditor) this.unregisterForDrawing(this._drawingEditor);\n            this.blockEvents();\n            editor.reset();  // Make sure editor tools still receive events.\n            this._drawingEditor = editor;\n            this.map.on('mousemove touchmove', editor.onDrawingMouseMove, editor);\n            this.map.on('mousedown', this.onMousedown, this);\n            this.map.on('mouseup', this.onMouseup, this);\n            L.DomUtil.addClass(this.map._container, this.options.drawingCSSClass);\n            this.defaultMapCursor = this.map._container.style.cursor;\n            this.map._container.style.cursor = this.options.drawingCursor;\n        },\n\n        unregisterForDrawing: function (editor) {\n            this.unblockEvents();\n            L.DomUtil.removeClass(this.map._container, this.options.drawingCSSClass);\n            this.map._container.style.cursor = this.defaultMapCursor;\n            editor = editor || this._drawingEditor;\n            if (!editor) return;\n            this.map.off('mousemove touchmove', editor.onDrawingMouseMove, editor);\n            this.map.off('mousedown', this.onMousedown, this);\n            this.map.off('mouseup', this.onMouseup, this);\n            if (editor !== this._drawingEditor) return;\n            delete this._drawingEditor;\n            if (editor._drawing) editor.cancelDrawing();\n        },\n\n        onMousedown: function (e) {\n            if (e.originalEvent.which != 1) return;\n            this._mouseDown = e;\n            this._drawingEditor.onDrawingMouseDown(e);\n        },\n\n        onMouseup: function (e) {\n            if (this._mouseDown) {\n                var editor = this._drawingEditor,\n                    mouseDown = this._mouseDown;\n                this._mouseDown = null;\n                editor.onDrawingMouseUp(e);\n                if (this._drawingEditor !== editor) return;  // onDrawingMouseUp may call unregisterFromDrawing.\n                var origin = L.point(mouseDown.originalEvent.clientX, mouseDown.originalEvent.clientY);\n                var distance = L.point(e.originalEvent.clientX, e.originalEvent.clientY).distanceTo(origin);\n                if (Math.abs(distance) < 9 * (window.devicePixelRatio || 1)) this._drawingEditor.onDrawingClick(e);\n            }\n        },\n\n        // 🍂section Public methods\n        // You will generally access them by the `map.editTools`\n        // instance:\n        //\n        // `map.editTools.startPolyline();`\n\n        // 🍂method drawing(): boolean\n        // Return true if any drawing action is ongoing.\n        drawing: function () {\n            return this._drawingEditor && this._drawingEditor.drawing();\n        },\n\n        // 🍂method stopDrawing()\n        // When you need to stop any ongoing drawing, without needing to know which editor is active.\n        stopDrawing: function () {\n            this.unregisterForDrawing();\n        },\n\n        // 🍂method commitDrawing()\n        // When you need to commit any ongoing drawing, without needing to know which editor is active.\n        commitDrawing: function (e) {\n            if (!this._drawingEditor) return;\n            this._drawingEditor.commitDrawing(e);\n        },\n\n        connectCreatedToMap: function (layer) {\n            return this.featuresLayer.addLayer(layer);\n        },\n\n        // 🍂method startPolyline(latlng: L.LatLng, options: hash): L.Polyline\n        // Start drawing a Polyline. If `latlng` is given, a first point will be added. In any case, continuing on user click.\n        // If `options` is given, it will be passed to the Polyline class constructor.\n        startPolyline: function (latlng, options) {\n            var line = this.createPolyline([], options);\n            line.enableEdit(this.map).newShape(latlng);\n            return line;\n        },\n\n        // 🍂method startPolygon(latlng: L.LatLng, options: hash): L.Polygon\n        // Start drawing a Polygon. If `latlng` is given, a first point will be added. In any case, continuing on user click.\n        // If `options` is given, it will be passed to the Polygon class constructor.\n        startPolygon: function (latlng, options) {\n            var polygon = this.createPolygon([], options);\n            polygon.enableEdit(this.map).newShape(latlng);\n            return polygon;\n        },\n\n        // 🍂method startMarker(latlng: L.LatLng, options: hash): L.Marker\n        // Start adding a Marker. If `latlng` is given, the Marker will be shown first at this point.\n        // In any case, it will follow the user mouse, and will have a final `latlng` on next click (or touch).\n        // If `options` is given, it will be passed to the Marker class constructor.\n        startMarker: function (latlng, options) {\n            latlng = latlng || this.map.getCenter().clone();\n            var marker = this.createMarker(latlng, options);\n            marker.enableEdit(this.map).startDrawing();\n            return marker;\n        },\n\n        // 🍂method startRectangle(latlng: L.LatLng, options: hash): L.Rectangle\n        // Start drawing a Rectangle. If `latlng` is given, the Rectangle anchor will be added. In any case, continuing on user drag.\n        // If `options` is given, it will be passed to the Rectangle class constructor.\n        startRectangle: function(latlng, options) {\n            var corner = latlng || L.latLng([0, 0]);\n            var bounds = new L.LatLngBounds(corner, corner);\n            var rectangle = this.createRectangle(bounds, options);\n            rectangle.enableEdit(this.map).startDrawing();\n            return rectangle;\n        },\n\n        // 🍂method startCircle(latlng: L.LatLng, options: hash): L.Circle\n        // Start drawing a Circle. If `latlng` is given, the Circle anchor will be added. In any case, continuing on user drag.\n        // If `options` is given, it will be passed to the Circle class constructor.\n        startCircle: function (latlng, options) {\n            latlng = latlng || this.map.getCenter().clone();\n            var circle = this.createCircle(latlng, options);\n            circle.enableEdit(this.map).startDrawing();\n            return circle;\n        },\n\n        startHole: function (editor, latlng) {\n            editor.newHole(latlng);\n        },\n\n        createLayer: function (klass, latlngs, options) {\n            options = L.Util.extend({editOptions: {editTools: this}}, options);\n            var layer = new klass(latlngs, options);\n            // 🍂namespace Editable\n            // 🍂event editable:created: LayerEvent\n            // Fired when a new feature (Marker, Polyline…) is created.\n            this.fireAndForward('editable:created', {layer: layer});\n            return layer;\n        },\n\n        createPolyline: function (latlngs, options) {\n            return this.createLayer(options && options.polylineClass || this.options.polylineClass, latlngs, options);\n        },\n\n        createPolygon: function (latlngs, options) {\n            return this.createLayer(options && options.polygonClass || this.options.polygonClass, latlngs, options);\n        },\n\n        createMarker: function (latlng, options) {\n            return this.createLayer(options && options.markerClass || this.options.markerClass, latlng, options);\n        },\n\n        createRectangle: function (bounds, options) {\n            return this.createLayer(options && options.rectangleClass || this.options.rectangleClass, bounds, options);\n        },\n\n        createCircle: function (latlng, options) {\n            return this.createLayer(options && options.circleClass || this.options.circleClass, latlng, options);\n        }\n\n    });\n\n    L.extend(L.Editable, {\n\n        makeCancellable: function (e) {\n            e.cancel = function () {\n                e._cancelled = true;\n            };\n        }\n\n    });\n\n    // 🍂namespace Map; 🍂class Map\n    // Leaflet.Editable add options and events to the `L.Map` object.\n    // See `Editable` events for the list of events fired on the Map.\n    // 🍂example\n    //\n    // ```js\n    // var map = L.map('map', {\n    //  editable: true,\n    //  editOptions: {\n    //    …\n    // }\n    // });\n    // ```\n    // 🍂section Editable Map Options\n    L.Map.mergeOptions({\n\n        // 🍂namespace Map\n        // 🍂section Map Options\n        // 🍂option editToolsClass: class = L.Editable\n        // Class to be used as vertex, for path editing.\n        editToolsClass: L.Editable,\n\n        // 🍂option editable: boolean = false\n        // Whether to create a L.Editable instance at map init.\n        editable: false,\n\n        // 🍂option editOptions: hash = {}\n        // Options to pass to L.Editable when instantiating.\n        editOptions: {}\n\n    });\n\n    L.Map.addInitHook(function () {\n\n        this.whenReady(function () {\n            if (this.options.editable) {\n                this.editTools = new this.options.editToolsClass(this, this.options.editOptions);\n            }\n        });\n\n    });\n\n    L.Editable.VertexIcon = L.DivIcon.extend({\n\n        options: {\n            iconSize: new L.Point(8, 8)\n        }\n\n    });\n\n    L.Editable.TouchVertexIcon = L.Editable.VertexIcon.extend({\n\n        options: {\n            iconSize: new L.Point(20, 20)\n        }\n\n    });\n\n\n    // 🍂namespace Editable; 🍂class VertexMarker; Handler for dragging path vertices.\n    L.Editable.VertexMarker = L.Marker.extend({\n\n        options: {\n            draggable: true,\n            className: 'leaflet-div-icon leaflet-vertex-icon'\n        },\n\n\n        // 🍂section Public methods\n        // The marker used to handle path vertex. You will usually interact with a `VertexMarker`\n        // instance when listening for events like `editable:vertex:ctrlclick`.\n\n        initialize: function (latlng, latlngs, editor, options) {\n            // We don't use this._latlng, because on drag Leaflet replace it while\n            // we want to keep reference.\n            this.latlng = latlng;\n            this.latlngs = latlngs;\n            this.editor = editor;\n            L.Marker.prototype.initialize.call(this, latlng, options);\n            this.options.icon = this.editor.tools.createVertexIcon({className: this.options.className});\n            this.latlng.__vertex = this;\n            this.editor.editLayer.addLayer(this);\n            this.setZIndexOffset(editor.tools._lastZIndex + 1);\n        },\n\n        onAdd: function (map) {\n            L.Marker.prototype.onAdd.call(this, map);\n            this.on('drag', this.onDrag);\n            this.on('dragstart', this.onDragStart);\n            this.on('dragend', this.onDragEnd);\n            this.on('mouseup', this.onMouseup);\n            this.on('click', this.onClick);\n            this.on('contextmenu', this.onContextMenu);\n            this.on('mousedown touchstart', this.onMouseDown);\n            this.on('mouseover', this.onMouseOver);\n            this.on('mouseout', this.onMouseOut);\n            this.addMiddleMarkers();\n        },\n\n        onRemove: function (map) {\n            if (this.middleMarker) this.middleMarker.delete();\n            delete this.latlng.__vertex;\n            this.off('drag', this.onDrag);\n            this.off('dragstart', this.onDragStart);\n            this.off('dragend', this.onDragEnd);\n            this.off('mouseup', this.onMouseup);\n            this.off('click', this.onClick);\n            this.off('contextmenu', this.onContextMenu);\n            this.off('mousedown touchstart', this.onMouseDown);\n            this.off('mouseover', this.onMouseOver);\n            this.off('mouseout', this.onMouseOut);\n            L.Marker.prototype.onRemove.call(this, map);\n        },\n\n        onDrag: function (e) {\n            e.vertex = this;\n            this.editor.onVertexMarkerDrag(e);\n            var iconPos = L.DomUtil.getPosition(this._icon),\n                latlng = this._map.layerPointToLatLng(iconPos);\n            this.latlng.update(latlng);\n            this._latlng = this.latlng;  // Push back to Leaflet our reference.\n            this.editor.refresh();\n            if (this.middleMarker) this.middleMarker.updateLatLng();\n            var next = this.getNext();\n            if (next && next.middleMarker) next.middleMarker.updateLatLng();\n        },\n\n        onDragStart: function (e) {\n            e.vertex = this;\n            this.editor.onVertexMarkerDragStart(e);\n        },\n\n        onDragEnd: function (e) {\n            e.vertex = this;\n            this.editor.onVertexMarkerDragEnd(e);\n        },\n\n        onClick: function (e) {\n            e.vertex = this;\n            this.editor.onVertexMarkerClick(e);\n        },\n\n        onMouseup: function (e) {\n            L.DomEvent.stop(e);\n            e.vertex = this;\n            this.editor.map.fire('mouseup', e);\n        },\n\n        onContextMenu: function (e) {\n            e.vertex = this;\n            this.editor.onVertexMarkerContextMenu(e);\n        },\n\n        onMouseDown: function (e) {\n            e.vertex = this;\n            this.editor.onVertexMarkerMouseDown(e);\n        },\n\n        onMouseOver: function (e) {\n            e.vertex = this;\n            this.editor.onVertexMarkerMouseOver(e);\n        },\n\n        onMouseOut: function (e) {\n            e.vertex = this;\n            this.editor.onVertexMarkerMouseOut(e);\n        },\n\n        // 🍂method delete()\n        // Delete a vertex and the related LatLng.\n        delete: function () {\n            var next = this.getNext();  // Compute before changing latlng\n            this.latlngs.splice(this.getIndex(), 1);\n            this.editor.editLayer.removeLayer(this);\n            this.editor.onVertexDeleted({latlng: this.latlng, vertex: this});\n            if (!this.latlngs.length) this.editor.deleteShape(this.latlngs);\n            if (next) next.resetMiddleMarker();\n            this.editor.refresh();\n        },\n\n        // 🍂method getIndex(): int\n        // Get the index of the current vertex among others of the same LatLngs group.\n        getIndex: function () {\n            return this.latlngs.indexOf(this.latlng);\n        },\n\n        // 🍂method getLastIndex(): int\n        // Get last vertex index of the LatLngs group of the current vertex.\n        getLastIndex: function () {\n            return this.latlngs.length - 1;\n        },\n\n        // 🍂method getPrevious(): VertexMarker\n        // Get the previous VertexMarker in the same LatLngs group.\n        getPrevious: function () {\n            if (this.latlngs.length < 2) return;\n            var index = this.getIndex(),\n                previousIndex = index - 1;\n            if (index === 0 && this.editor.CLOSED) previousIndex = this.getLastIndex();\n            var previous = this.latlngs[previousIndex];\n            if (previous) return previous.__vertex;\n        },\n\n        // 🍂method getNext(): VertexMarker\n        // Get the next VertexMarker in the same LatLngs group.\n        getNext: function () {\n            if (this.latlngs.length < 2) return;\n            var index = this.getIndex(),\n                nextIndex = index + 1;\n            if (index === this.getLastIndex() && this.editor.CLOSED) nextIndex = 0;\n            var next = this.latlngs[nextIndex];\n            if (next) return next.__vertex;\n        },\n\n        addMiddleMarker: function (previous) {\n            if (!this.editor.hasMiddleMarkers()) return;\n            previous = previous || this.getPrevious();\n            if (previous && !this.middleMarker) this.middleMarker = this.editor.addMiddleMarker(previous, this, this.latlngs, this.editor);\n        },\n\n        addMiddleMarkers: function () {\n            if (!this.editor.hasMiddleMarkers()) return;\n            var previous = this.getPrevious();\n            if (previous) this.addMiddleMarker(previous);\n            var next = this.getNext();\n            if (next) next.resetMiddleMarker();\n        },\n\n        resetMiddleMarker: function () {\n            if (this.middleMarker) this.middleMarker.delete();\n            this.addMiddleMarker();\n        },\n\n        // 🍂method split()\n        // Split the vertex LatLngs group at its index, if possible.\n        split: function () {\n            if (!this.editor.splitShape) return;  // Only for PolylineEditor\n            this.editor.splitShape(this.latlngs, this.getIndex());\n        },\n\n        // 🍂method continue()\n        // Continue the vertex LatLngs from this vertex. Only active for first and last vertices of a Polyline.\n        continue: function () {\n            if (!this.editor.continueBackward) return;  // Only for PolylineEditor\n            var index = this.getIndex();\n            if (index === 0) this.editor.continueBackward(this.latlngs);\n            else if (index === this.getLastIndex()) this.editor.continueForward(this.latlngs);\n        }\n\n    });\n\n    L.Editable.mergeOptions({\n\n        // 🍂namespace Editable\n        // 🍂option vertexMarkerClass: class = VertexMarker\n        // Class to be used as vertex, for path editing.\n        vertexMarkerClass: L.Editable.VertexMarker\n\n    });\n\n    L.Editable.MiddleMarker = L.Marker.extend({\n\n        options: {\n            opacity: 0.5,\n            className: 'leaflet-div-icon leaflet-middle-icon',\n            draggable: true\n        },\n\n        initialize: function (left, right, latlngs, editor, options) {\n            this.left = left;\n            this.right = right;\n            this.editor = editor;\n            this.latlngs = latlngs;\n            L.Marker.prototype.initialize.call(this, this.computeLatLng(), options);\n            this._opacity = this.options.opacity;\n            this.options.icon = this.editor.tools.createVertexIcon({className: this.options.className});\n            this.editor.editLayer.addLayer(this);\n            this.setVisibility();\n        },\n\n        setVisibility: function () {\n            var leftPoint = this._map.latLngToContainerPoint(this.left.latlng),\n                rightPoint = this._map.latLngToContainerPoint(this.right.latlng),\n                size = L.point(this.options.icon.options.iconSize);\n            if (leftPoint.distanceTo(rightPoint) < size.x * 3) this.hide();\n            else this.show();\n        },\n\n        show: function () {\n            this.setOpacity(this._opacity);\n        },\n\n        hide: function () {\n            this.setOpacity(0);\n        },\n\n        updateLatLng: function () {\n            this.setLatLng(this.computeLatLng());\n            this.setVisibility();\n        },\n\n        computeLatLng: function () {\n            var leftPoint = this.editor.map.latLngToContainerPoint(this.left.latlng),\n                rightPoint = this.editor.map.latLngToContainerPoint(this.right.latlng),\n                y = (leftPoint.y + rightPoint.y) / 2,\n                x = (leftPoint.x + rightPoint.x) / 2;\n            return this.editor.map.containerPointToLatLng([x, y]);\n        },\n\n        onAdd: function (map) {\n            L.Marker.prototype.onAdd.call(this, map);\n            L.DomEvent.on(this._icon, 'mousedown touchstart', this.onMouseDown, this);\n            map.on('zoomend', this.setVisibility, this);\n        },\n\n        onRemove: function (map) {\n            delete this.right.middleMarker;\n            L.DomEvent.off(this._icon, 'mousedown touchstart', this.onMouseDown, this);\n            map.off('zoomend', this.setVisibility, this);\n            L.Marker.prototype.onRemove.call(this, map);\n        },\n\n        onMouseDown: function (e) {\n            var iconPos = L.DomUtil.getPosition(this._icon),\n                latlng = this.editor.map.layerPointToLatLng(iconPos);\n            e = {\n                originalEvent: e,\n                latlng: latlng\n            };\n            if (this.options.opacity === 0) return;\n            L.Editable.makeCancellable(e);\n            this.editor.onMiddleMarkerMouseDown(e);\n            if (e._cancelled) return;\n            this.latlngs.splice(this.index(), 0, e.latlng);\n            this.editor.refresh();\n            var icon = this._icon;\n            var marker = this.editor.addVertexMarker(e.latlng, this.latlngs);\n            this.editor.onNewVertex(marker);\n            /* Hack to workaround browser not firing touchend when element is no more on DOM */\n            var parent = marker._icon.parentNode;\n            parent.removeChild(marker._icon);\n            marker._icon = icon;\n            parent.appendChild(marker._icon);\n            marker._initIcon();\n            marker._initInteraction();\n            marker.setOpacity(1);\n            /* End hack */\n            // Transfer ongoing dragging to real marker\n            L.Draggable._dragging = false;\n            marker.dragging._draggable._onDown(e.originalEvent);\n            this.delete();\n        },\n\n        delete: function () {\n            this.editor.editLayer.removeLayer(this);\n        },\n\n        index: function () {\n            return this.latlngs.indexOf(this.right.latlng);\n        }\n\n    });\n\n    L.Editable.mergeOptions({\n\n        // 🍂namespace Editable\n        // 🍂option middleMarkerClass: class = VertexMarker\n        // Class to be used as middle vertex, pulled by the user to create a new point in the middle of a path.\n        middleMarkerClass: L.Editable.MiddleMarker\n\n    });\n\n    // 🍂namespace Editable; 🍂class BaseEditor; 🍂aka L.Editable.BaseEditor\n    // When editing a feature (Marker, Polyline…), an editor is attached to it. This\n    // editor basically knows how to handle the edition.\n    L.Editable.BaseEditor = L.Handler.extend({\n\n        initialize: function (map, feature, options) {\n            L.setOptions(this, options);\n            this.map = map;\n            this.feature = feature;\n            this.feature.editor = this;\n            this.editLayer = new L.LayerGroup();\n            this.tools = this.options.editTools || map.editTools;\n        },\n\n        // 🍂method enable(): this\n        // Set up the drawing tools for the feature to be editable.\n        addHooks: function () {\n            if (this.isConnected()) this.onFeatureAdd();\n            else this.feature.once('add', this.onFeatureAdd, this);\n            this.onEnable();\n            this.feature.on(this._getEvents(), this);\n        },\n\n        // 🍂method disable(): this\n        // Remove the drawing tools for the feature.\n        removeHooks: function () {\n            this.feature.off(this._getEvents(), this);\n            if (this.feature.dragging) this.feature.dragging.disable();\n            this.editLayer.clearLayers();\n            this.tools.editLayer.removeLayer(this.editLayer);\n            this.onDisable();\n            if (this._drawing) this.cancelDrawing();\n        },\n\n        // 🍂method drawing(): boolean\n        // Return true if any drawing action is ongoing with this editor.\n        drawing: function () {\n            return !!this._drawing;\n        },\n\n        reset: function () {},\n\n        onFeatureAdd: function () {\n            this.tools.editLayer.addLayer(this.editLayer);\n            if (this.feature.dragging) this.feature.dragging.enable();\n        },\n\n        hasMiddleMarkers: function () {\n            return !this.options.skipMiddleMarkers && !this.tools.options.skipMiddleMarkers;\n        },\n\n        fireAndForward: function (type, e) {\n            e = e || {};\n            e.layer = this.feature;\n            this.feature.fire(type, e);\n            this.tools.fireAndForward(type, e);\n        },\n\n        onEnable: function () {\n            // 🍂namespace Editable\n            // 🍂event editable:enable: Event\n            // Fired when an existing feature is ready to be edited.\n            this.fireAndForward('editable:enable');\n        },\n\n        onDisable: function () {\n            // 🍂namespace Editable\n            // 🍂event editable:disable: Event\n            // Fired when an existing feature is not ready anymore to be edited.\n            this.fireAndForward('editable:disable');\n        },\n\n        onEditing: function () {\n            // 🍂namespace Editable\n            // 🍂event editable:editing: Event\n            // Fired as soon as any change is made to the feature geometry.\n            this.fireAndForward('editable:editing');\n        },\n\n        onStartDrawing: function () {\n            // 🍂namespace Editable\n            // 🍂section Drawing events\n            // 🍂event editable:drawing:start: Event\n            // Fired when a feature is to be drawn.\n            this.fireAndForward('editable:drawing:start');\n        },\n\n        onEndDrawing: function () {\n            // 🍂namespace Editable\n            // 🍂section Drawing events\n            // 🍂event editable:drawing:end: Event\n            // Fired when a feature is not drawn anymore.\n            this.fireAndForward('editable:drawing:end');\n        },\n\n        onCancelDrawing: function () {\n            // 🍂namespace Editable\n            // 🍂section Drawing events\n            // 🍂event editable:drawing:cancel: Event\n            // Fired when user cancel drawing while a feature is being drawn.\n            this.fireAndForward('editable:drawing:cancel');\n        },\n\n        onCommitDrawing: function (e) {\n            // 🍂namespace Editable\n            // 🍂section Drawing events\n            // 🍂event editable:drawing:commit: Event\n            // Fired when user finish drawing a feature.\n            this.fireAndForward('editable:drawing:commit', e);\n        },\n\n        onDrawingMouseDown: function (e) {\n            // 🍂namespace Editable\n            // 🍂section Drawing events\n            // 🍂event editable:drawing:mousedown: Event\n            // Fired when user `mousedown` while drawing.\n            this.fireAndForward('editable:drawing:mousedown', e);\n        },\n\n        onDrawingMouseUp: function (e) {\n            // 🍂namespace Editable\n            // 🍂section Drawing events\n            // 🍂event editable:drawing:mouseup: Event\n            // Fired when user `mouseup` while drawing.\n            this.fireAndForward('editable:drawing:mouseup', e);\n        },\n\n        startDrawing: function () {\n            if (!this._drawing) this._drawing = L.Editable.FORWARD;\n            this.tools.registerForDrawing(this);\n            this.onStartDrawing();\n        },\n\n        commitDrawing: function (e) {\n            this.onCommitDrawing(e);\n            this.endDrawing();\n        },\n\n        cancelDrawing: function () {\n            // If called during a vertex drag, the vertex will be removed before\n            // the mouseup fires on it. This is a workaround. Maybe better fix is\n            // To have L.Draggable reset it's status on disable (Leaflet side).\n            L.Draggable._dragging = false;\n            this.onCancelDrawing();\n            this.endDrawing();\n        },\n\n        endDrawing: function () {\n            this._drawing = false;\n            this.tools.unregisterForDrawing(this);\n            this.onEndDrawing();\n        },\n\n        onDrawingClick: function (e) {\n            if (!this.drawing()) return;\n            L.Editable.makeCancellable(e);\n            // 🍂namespace Editable\n            // 🍂section Drawing events\n            // 🍂event editable:drawing:click: CancelableEvent\n            // Fired when user `click` while drawing, before any internal action is being processed.\n            this.fireAndForward('editable:drawing:click', e);\n            if (e._cancelled) return;\n            if (!this.isConnected()) this.connect(e);\n            this.processDrawingClick(e);\n        },\n\n        isConnected: function () {\n            return this.map.hasLayer(this.feature);\n        },\n\n        connect: function () {\n            this.tools.connectCreatedToMap(this.feature);\n            this.tools.editLayer.addLayer(this.editLayer);\n        },\n\n        onMove: function (e) {\n            // 🍂namespace Editable\n            // 🍂section Drawing events\n            // 🍂event editable:drawing:move: Event\n            // Fired when `move` mouse while drawing, while dragging a marker, and while dragging a vertex.\n            this.fireAndForward('editable:drawing:move', e);\n        },\n\n        onDrawingMouseMove: function (e) {\n            this.onMove(e);\n        },\n\n        _getEvents: function () {\n            return {\n                dragstart: this.onDragStart,\n                drag: this.onDrag,\n                dragend: this.onDragEnd,\n                remove: this.disable\n            };\n        },\n\n        onDragStart: function (e) {\n            this.onEditing();\n            // 🍂namespace Editable\n            // 🍂event editable:dragstart: Event\n            // Fired before a path feature is dragged.\n            this.fireAndForward('editable:dragstart', e);\n        },\n\n        onDrag: function (e) {\n            this.onMove(e);\n            // 🍂namespace Editable\n            // 🍂event editable:drag: Event\n            // Fired when a path feature is being dragged.\n            this.fireAndForward('editable:drag', e);\n        },\n\n        onDragEnd: function (e) {\n            // 🍂namespace Editable\n            // 🍂event editable:dragend: Event\n            // Fired after a path feature has been dragged.\n            this.fireAndForward('editable:dragend', e);\n        }\n\n    });\n\n    // 🍂namespace Editable; 🍂class MarkerEditor; 🍂aka L.Editable.MarkerEditor\n    // 🍂inherits BaseEditor\n    // Editor for Marker.\n    L.Editable.MarkerEditor = L.Editable.BaseEditor.extend({\n\n        onDrawingMouseMove: function (e) {\n            L.Editable.BaseEditor.prototype.onDrawingMouseMove.call(this, e);\n            if (this._drawing) this.feature.setLatLng(e.latlng);\n        },\n\n        processDrawingClick: function (e) {\n            // 🍂namespace Editable\n            // 🍂section Drawing events\n            // 🍂event editable:drawing:clicked: Event\n            // Fired when user `click` while drawing, after all internal actions.\n            this.fireAndForward('editable:drawing:clicked', e);\n            this.commitDrawing(e);\n        },\n\n        connect: function (e) {\n            // On touch, the latlng has not been updated because there is\n            // no mousemove.\n            if (e) this.feature._latlng = e.latlng;\n            L.Editable.BaseEditor.prototype.connect.call(this, e);\n        }\n\n    });\n\n    // 🍂namespace Editable; 🍂class PathEditor; 🍂aka L.Editable.PathEditor\n    // 🍂inherits BaseEditor\n    // Base class for all path editors.\n    L.Editable.PathEditor = L.Editable.BaseEditor.extend({\n\n        CLOSED: false,\n        MIN_VERTEX: 2,\n\n        addHooks: function () {\n            L.Editable.BaseEditor.prototype.addHooks.call(this);\n            if (this.feature) this.initVertexMarkers();\n            return this;\n        },\n\n        initVertexMarkers: function (latlngs) {\n            if (!this.enabled()) return;\n            latlngs = latlngs || this.getLatLngs();\n            if (isFlat(latlngs)) this.addVertexMarkers(latlngs);\n            else for (var i = 0; i < latlngs.length; i++) this.initVertexMarkers(latlngs[i]);\n        },\n\n        getLatLngs: function () {\n            return this.feature.getLatLngs();\n        },\n\n        // 🍂method reset()\n        // Rebuild edit elements (Vertex, MiddleMarker, etc.).\n        reset: function () {\n            this.editLayer.clearLayers();\n            this.initVertexMarkers();\n        },\n\n        addVertexMarker: function (latlng, latlngs) {\n            return new this.tools.options.vertexMarkerClass(latlng, latlngs, this);\n        },\n\n        onNewVertex: function (vertex) {\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:new: VertexEvent\n            // Fired when a new vertex is created.\n            this.fireAndForward('editable:vertex:new', {latlng: vertex.latlng, vertex: vertex});\n        },\n\n        addVertexMarkers: function (latlngs) {\n            for (var i = 0; i < latlngs.length; i++) {\n                this.addVertexMarker(latlngs[i], latlngs);\n            }\n        },\n\n        refreshVertexMarkers: function (latlngs) {\n            latlngs = latlngs || this.getDefaultLatLngs();\n            for (var i = 0; i < latlngs.length; i++) {\n                latlngs[i].__vertex.update();\n            }\n        },\n\n        addMiddleMarker: function (left, right, latlngs) {\n            return new this.tools.options.middleMarkerClass(left, right, latlngs, this);\n        },\n\n        onVertexMarkerClick: function (e) {\n            L.Editable.makeCancellable(e);\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:click: CancelableVertexEvent\n            // Fired when a `click` is issued on a vertex, before any internal action is being processed.\n            this.fireAndForward('editable:vertex:click', e);\n            if (e._cancelled) return;\n            if (this.tools.drawing() && this.tools._drawingEditor !== this) return;\n            var index = e.vertex.getIndex(), commit;\n            if (e.originalEvent.ctrlKey) {\n                this.onVertexMarkerCtrlClick(e);\n            } else if (e.originalEvent.altKey) {\n                this.onVertexMarkerAltClick(e);\n            } else if (e.originalEvent.shiftKey) {\n                this.onVertexMarkerShiftClick(e);\n            } else if (e.originalEvent.metaKey) {\n                this.onVertexMarkerMetaKeyClick(e);\n            } else if (index === e.vertex.getLastIndex() && this._drawing === L.Editable.FORWARD) {\n                if (index >= this.MIN_VERTEX - 1) commit = true;\n            } else if (index === 0 && this._drawing === L.Editable.BACKWARD && this._drawnLatLngs.length >= this.MIN_VERTEX) {\n                commit = true;\n            } else if (index === 0 && this._drawing === L.Editable.FORWARD && this._drawnLatLngs.length >= this.MIN_VERTEX && this.CLOSED) {\n                commit = true;  // Allow to close on first point also for polygons\n            } else {\n                this.onVertexRawMarkerClick(e);\n            }\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:clicked: VertexEvent\n            // Fired when a `click` is issued on a vertex, after all internal actions.\n            this.fireAndForward('editable:vertex:clicked', e);\n            if (commit) this.commitDrawing(e);\n        },\n\n        onVertexRawMarkerClick: function (e) {\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:rawclick: CancelableVertexEvent\n            // Fired when a `click` is issued on a vertex without any special key and without being in drawing mode.\n            this.fireAndForward('editable:vertex:rawclick', e);\n            if (e._cancelled) return;\n            if (!this.vertexCanBeDeleted(e.vertex)) return;\n            e.vertex.delete();\n        },\n\n        vertexCanBeDeleted: function (vertex) {\n            return vertex.latlngs.length > this.MIN_VERTEX;\n        },\n\n        onVertexDeleted: function (e) {\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:deleted: VertexEvent\n            // Fired after a vertex has been deleted by user.\n            this.fireAndForward('editable:vertex:deleted', e);\n        },\n\n        onVertexMarkerCtrlClick: function (e) {\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:ctrlclick: VertexEvent\n            // Fired when a `click` with `ctrlKey` is issued on a vertex.\n            this.fireAndForward('editable:vertex:ctrlclick', e);\n        },\n\n        onVertexMarkerShiftClick: function (e) {\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:shiftclick: VertexEvent\n            // Fired when a `click` with `shiftKey` is issued on a vertex.\n            this.fireAndForward('editable:vertex:shiftclick', e);\n        },\n\n        onVertexMarkerMetaKeyClick: function (e) {\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:metakeyclick: VertexEvent\n            // Fired when a `click` with `metaKey` is issued on a vertex.\n            this.fireAndForward('editable:vertex:metakeyclick', e);\n        },\n\n        onVertexMarkerAltClick: function (e) {\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:altclick: VertexEvent\n            // Fired when a `click` with `altKey` is issued on a vertex.\n            this.fireAndForward('editable:vertex:altclick', e);\n        },\n\n        onVertexMarkerContextMenu: function (e) {\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:contextmenu: VertexEvent\n            // Fired when a `contextmenu` is issued on a vertex.\n            this.fireAndForward('editable:vertex:contextmenu', e);\n        },\n\n        onVertexMarkerMouseDown: function (e) {\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:mousedown: VertexEvent\n            // Fired when user `mousedown` a vertex.\n            this.fireAndForward('editable:vertex:mousedown', e);\n        },\n\n        onVertexMarkerMouseOver: function (e) {\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:mouseover: VertexEvent\n            // Fired when a user's mouse enters the vertex\n            this.fireAndForward('editable:vertex:mouseover', e);\n        },\n\n        onVertexMarkerMouseOut: function (e) {\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:mouseout: VertexEvent\n            // Fired when a user's mouse leaves the vertex\n            this.fireAndForward('editable:vertex:mouseout', e);\n        },\n\n        onMiddleMarkerMouseDown: function (e) {\n            // 🍂namespace Editable\n            // 🍂section MiddleMarker events\n            // 🍂event editable:middlemarker:mousedown: VertexEvent\n            // Fired when user `mousedown` a middle marker.\n            this.fireAndForward('editable:middlemarker:mousedown', e);\n        },\n\n        onVertexMarkerDrag: function (e) {\n            this.onMove(e);\n            if (this.feature._bounds) this.extendBounds(e);\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:drag: VertexEvent\n            // Fired when a vertex is dragged by user.\n            this.fireAndForward('editable:vertex:drag', e);\n        },\n\n        onVertexMarkerDragStart: function (e) {\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:dragstart: VertexEvent\n            // Fired before a vertex is dragged by user.\n            this.fireAndForward('editable:vertex:dragstart', e);\n        },\n\n        onVertexMarkerDragEnd: function (e) {\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:dragend: VertexEvent\n            // Fired after a vertex is dragged by user.\n            this.fireAndForward('editable:vertex:dragend', e);\n        },\n\n        setDrawnLatLngs: function (latlngs) {\n            this._drawnLatLngs = latlngs || this.getDefaultLatLngs();\n        },\n\n        startDrawing: function () {\n            if (!this._drawnLatLngs) this.setDrawnLatLngs();\n            L.Editable.BaseEditor.prototype.startDrawing.call(this);\n        },\n\n        startDrawingForward: function () {\n            this.startDrawing();\n        },\n\n        endDrawing: function () {\n            this.tools.detachForwardLineGuide();\n            this.tools.detachBackwardLineGuide();\n            if (this._drawnLatLngs && this._drawnLatLngs.length < this.MIN_VERTEX) this.deleteShape(this._drawnLatLngs);\n            L.Editable.BaseEditor.prototype.endDrawing.call(this);\n            delete this._drawnLatLngs;\n        },\n\n        addLatLng: function (latlng) {\n            if (this._drawing === L.Editable.FORWARD) this._drawnLatLngs.push(latlng);\n            else this._drawnLatLngs.unshift(latlng);\n            this.feature._bounds.extend(latlng);\n            var vertex = this.addVertexMarker(latlng, this._drawnLatLngs);\n            this.onNewVertex(vertex);\n            this.refresh();\n        },\n\n        newPointForward: function (latlng) {\n            this.addLatLng(latlng);\n            this.tools.attachForwardLineGuide();\n            this.tools.anchorForwardLineGuide(latlng);\n        },\n\n        newPointBackward: function (latlng) {\n            this.addLatLng(latlng);\n            this.tools.anchorBackwardLineGuide(latlng);\n        },\n\n        // 🍂namespace PathEditor\n        // 🍂method push()\n        // Programmatically add a point while drawing.\n        push: function (latlng) {\n            if (!latlng) return console.error('L.Editable.PathEditor.push expect a valid latlng as parameter');\n            if (this._drawing === L.Editable.FORWARD) this.newPointForward(latlng);\n            else this.newPointBackward(latlng);\n        },\n\n        removeLatLng: function (latlng) {\n            latlng.__vertex.delete();\n            this.refresh();\n        },\n\n        // 🍂method pop(): L.LatLng or null\n        // Programmatically remove last point (if any) while drawing.\n        pop: function () {\n            if (this._drawnLatLngs.length <= 1) return;\n            var latlng;\n            if (this._drawing === L.Editable.FORWARD) latlng = this._drawnLatLngs[this._drawnLatLngs.length - 1];\n            else latlng = this._drawnLatLngs[0];\n            this.removeLatLng(latlng);\n            if (this._drawing === L.Editable.FORWARD) this.tools.anchorForwardLineGuide(this._drawnLatLngs[this._drawnLatLngs.length - 1]);\n            else this.tools.anchorForwardLineGuide(this._drawnLatLngs[0]);\n            return latlng;\n        },\n\n        processDrawingClick: function (e) {\n            if (e.vertex && e.vertex.editor === this) return;\n            if (this._drawing === L.Editable.FORWARD) this.newPointForward(e.latlng);\n            else this.newPointBackward(e.latlng);\n            this.fireAndForward('editable:drawing:clicked', e);\n        },\n\n        onDrawingMouseMove: function (e) {\n            L.Editable.BaseEditor.prototype.onDrawingMouseMove.call(this, e);\n            if (this._drawing) {\n                this.tools.moveForwardLineGuide(e.latlng);\n                this.tools.moveBackwardLineGuide(e.latlng);\n            }\n        },\n\n        refresh: function () {\n            this.feature.redraw();\n            this.onEditing();\n        },\n\n        // 🍂namespace PathEditor\n        // 🍂method newShape(latlng?: L.LatLng)\n        // Add a new shape (Polyline, Polygon) in a multi, and setup up drawing tools to draw it;\n        // if optional `latlng` is given, start a path at this point.\n        newShape: function (latlng) {\n            var shape = this.addNewEmptyShape();\n            if (!shape) return;\n            this.setDrawnLatLngs(shape[0] || shape);  // Polygon or polyline\n            this.startDrawingForward();\n            // 🍂namespace Editable\n            // 🍂section Shape events\n            // 🍂event editable:shape:new: ShapeEvent\n            // Fired when a new shape is created in a multi (Polygon or Polyline).\n            this.fireAndForward('editable:shape:new', {shape: shape});\n            if (latlng) this.newPointForward(latlng);\n        },\n\n        deleteShape: function (shape, latlngs) {\n            var e = {shape: shape};\n            L.Editable.makeCancellable(e);\n            // 🍂namespace Editable\n            // 🍂section Shape events\n            // 🍂event editable:shape:delete: CancelableShapeEvent\n            // Fired before a new shape is deleted in a multi (Polygon or Polyline).\n            this.fireAndForward('editable:shape:delete', e);\n            if (e._cancelled) return;\n            shape = this._deleteShape(shape, latlngs);\n            if (this.ensureNotFlat) this.ensureNotFlat();  // Polygon.\n            this.feature.setLatLngs(this.getLatLngs());  // Force bounds reset.\n            this.refresh();\n            this.reset();\n            // 🍂namespace Editable\n            // 🍂section Shape events\n            // 🍂event editable:shape:deleted: ShapeEvent\n            // Fired after a new shape is deleted in a multi (Polygon or Polyline).\n            this.fireAndForward('editable:shape:deleted', {shape: shape});\n            return shape;\n        },\n\n        _deleteShape: function (shape, latlngs) {\n            latlngs = latlngs || this.getLatLngs();\n            if (!latlngs.length) return;\n            var self = this,\n                inplaceDelete = function (latlngs, shape) {\n                    // Called when deleting a flat latlngs\n                    shape = latlngs.splice(0, Number.MAX_VALUE);\n                    return shape;\n                },\n                spliceDelete = function (latlngs, shape) {\n                    // Called when removing a latlngs inside an array\n                    latlngs.splice(latlngs.indexOf(shape), 1);\n                    if (!latlngs.length) self._deleteShape(latlngs);\n                    return shape;\n                };\n            if (latlngs === shape) return inplaceDelete(latlngs, shape);\n            for (var i = 0; i < latlngs.length; i++) {\n                if (latlngs[i] === shape) return spliceDelete(latlngs, shape);\n                else if (latlngs[i].indexOf(shape) !== -1) return spliceDelete(latlngs[i], shape);\n            }\n        },\n\n        // 🍂namespace PathEditor\n        // 🍂method deleteShapeAt(latlng: L.LatLng): Array\n        // Remove a path shape at the given `latlng`.\n        deleteShapeAt: function (latlng) {\n            var shape = this.feature.shapeAt(latlng);\n            if (shape) return this.deleteShape(shape);\n        },\n\n        // 🍂method appendShape(shape: Array)\n        // Append a new shape to the Polygon or Polyline.\n        appendShape: function (shape) {\n            this.insertShape(shape);\n        },\n\n        // 🍂method prependShape(shape: Array)\n        // Prepend a new shape to the Polygon or Polyline.\n        prependShape: function (shape) {\n            this.insertShape(shape, 0);\n        },\n\n        // 🍂method insertShape(shape: Array, index: int)\n        // Insert a new shape to the Polygon or Polyline at given index (default is to append).\n        insertShape: function (shape, index) {\n            this.ensureMulti();\n            shape = this.formatShape(shape);\n            if (typeof index === 'undefined') index = this.feature._latlngs.length;\n            this.feature._latlngs.splice(index, 0, shape);\n            this.feature.redraw();\n            if (this._enabled) this.reset();\n        },\n\n        extendBounds: function (e) {\n            this.feature._bounds.extend(e.vertex.latlng);\n        },\n\n        onDragStart: function (e) {\n            this.editLayer.clearLayers();\n            L.Editable.BaseEditor.prototype.onDragStart.call(this, e);\n        },\n\n        onDragEnd: function (e) {\n            this.initVertexMarkers();\n            L.Editable.BaseEditor.prototype.onDragEnd.call(this, e);\n        }\n\n    });\n\n    // 🍂namespace Editable; 🍂class PolylineEditor; 🍂aka L.Editable.PolylineEditor\n    // 🍂inherits PathEditor\n    L.Editable.PolylineEditor = L.Editable.PathEditor.extend({\n\n        startDrawingBackward: function () {\n            this._drawing = L.Editable.BACKWARD;\n            this.startDrawing();\n        },\n\n        // 🍂method continueBackward(latlngs?: Array)\n        // Set up drawing tools to continue the line backward.\n        continueBackward: function (latlngs) {\n            if (this.drawing()) return;\n            latlngs = latlngs || this.getDefaultLatLngs();\n            this.setDrawnLatLngs(latlngs);\n            if (latlngs.length > 0) {\n                this.tools.attachBackwardLineGuide();\n                this.tools.anchorBackwardLineGuide(latlngs[0]);\n            }\n            this.startDrawingBackward();\n        },\n\n        // 🍂method continueForward(latlngs?: Array)\n        // Set up drawing tools to continue the line forward.\n        continueForward: function (latlngs) {\n            if (this.drawing()) return;\n            latlngs = latlngs || this.getDefaultLatLngs();\n            this.setDrawnLatLngs(latlngs);\n            if (latlngs.length > 0) {\n                this.tools.attachForwardLineGuide();\n                this.tools.anchorForwardLineGuide(latlngs[latlngs.length - 1]);\n            }\n            this.startDrawingForward();\n        },\n\n        getDefaultLatLngs: function (latlngs) {\n            latlngs = latlngs || this.feature._latlngs;\n            if (!latlngs.length || latlngs[0] instanceof L.LatLng) return latlngs;\n            else return this.getDefaultLatLngs(latlngs[0]);\n        },\n\n        ensureMulti: function () {\n            if (this.feature._latlngs.length && isFlat(this.feature._latlngs)) {\n                this.feature._latlngs = [this.feature._latlngs];\n            }\n        },\n\n        addNewEmptyShape: function () {\n            if (this.feature._latlngs.length) {\n                var shape = [];\n                this.appendShape(shape);\n                return shape;\n            } else {\n                return this.feature._latlngs;\n            }\n        },\n\n        formatShape: function (shape) {\n            if (isFlat(shape)) return shape;\n            else if (shape[0]) return this.formatShape(shape[0]);\n        },\n\n        // 🍂method splitShape(latlngs?: Array, index: int)\n        // Split the given `latlngs` shape at index `index` and integrate new shape in instance `latlngs`.\n        splitShape: function (shape, index) {\n            if (!index || index >= shape.length - 1) return;\n            this.ensureMulti();\n            var shapeIndex = this.feature._latlngs.indexOf(shape);\n            if (shapeIndex === -1) return;\n            var first = shape.slice(0, index + 1),\n                second = shape.slice(index);\n            // We deal with reference, we don't want twice the same latlng around.\n            second[0] = L.latLng(second[0].lat, second[0].lng, second[0].alt);\n            this.feature._latlngs.splice(shapeIndex, 1, first, second);\n            this.refresh();\n            this.reset();\n        }\n\n    });\n\n    // 🍂namespace Editable; 🍂class PolygonEditor; 🍂aka L.Editable.PolygonEditor\n    // 🍂inherits PathEditor\n    L.Editable.PolygonEditor = L.Editable.PathEditor.extend({\n\n        CLOSED: true,\n        MIN_VERTEX: 3,\n\n        newPointForward: function (latlng) {\n            L.Editable.PathEditor.prototype.newPointForward.call(this, latlng);\n            if (!this.tools.backwardLineGuide._latlngs.length) this.tools.anchorBackwardLineGuide(latlng);\n            if (this._drawnLatLngs.length === 2) this.tools.attachBackwardLineGuide();\n        },\n\n        addNewEmptyHole: function (latlng) {\n            this.ensureNotFlat();\n            var latlngs = this.feature.shapeAt(latlng);\n            if (!latlngs) return;\n            var holes = [];\n            latlngs.push(holes);\n            return holes;\n        },\n\n        // 🍂method newHole(latlng?: L.LatLng, index: int)\n        // Set up drawing tools for creating a new hole on the Polygon. If the `latlng` param is given, a first point is created.\n        newHole: function (latlng) {\n            var holes = this.addNewEmptyHole(latlng);\n            if (!holes) return;\n            this.setDrawnLatLngs(holes);\n            this.startDrawingForward();\n            if (latlng) this.newPointForward(latlng);\n        },\n\n        addNewEmptyShape: function () {\n            if (this.feature._latlngs.length && this.feature._latlngs[0].length) {\n                var shape = [];\n                this.appendShape(shape);\n                return shape;\n            } else {\n                return this.feature._latlngs;\n            }\n        },\n\n        ensureMulti: function () {\n            if (this.feature._latlngs.length && isFlat(this.feature._latlngs[0])) {\n                this.feature._latlngs = [this.feature._latlngs];\n            }\n        },\n\n        ensureNotFlat: function () {\n            if (!this.feature._latlngs.length || isFlat(this.feature._latlngs)) this.feature._latlngs = [this.feature._latlngs];\n        },\n\n        vertexCanBeDeleted: function (vertex) {\n            var parent = this.feature.parentShape(vertex.latlngs),\n                idx = L.Util.indexOf(parent, vertex.latlngs);\n            if (idx > 0) return true;  // Holes can be totally deleted without removing the layer itself.\n            return L.Editable.PathEditor.prototype.vertexCanBeDeleted.call(this, vertex);\n        },\n\n        getDefaultLatLngs: function () {\n            if (!this.feature._latlngs.length) this.feature._latlngs.push([]);\n            return this.feature._latlngs[0];\n        },\n\n        formatShape: function (shape) {\n            // [[1, 2], [3, 4]] => must be nested\n            // [] => must be nested\n            // [[]] => is already nested\n            if (isFlat(shape) && (!shape[0] || shape[0].length !== 0)) return [shape];\n            else return shape;\n        }\n\n    });\n\n    // 🍂namespace Editable; 🍂class RectangleEditor; 🍂aka L.Editable.RectangleEditor\n    // 🍂inherits PathEditor\n    L.Editable.RectangleEditor = L.Editable.PathEditor.extend({\n\n        CLOSED: true,\n        MIN_VERTEX: 4,\n\n        options: {\n            skipMiddleMarkers: true\n        },\n\n        extendBounds: function (e) {\n            var index = e.vertex.getIndex(),\n                next = e.vertex.getNext(),\n                previous = e.vertex.getPrevious(),\n                oppositeIndex = (index + 2) % 4,\n                opposite = e.vertex.latlngs[oppositeIndex],\n                bounds = new L.LatLngBounds(e.latlng, opposite);\n            // Update latlngs by hand to preserve order.\n            previous.latlng.update([e.latlng.lat, opposite.lng]);\n            next.latlng.update([opposite.lat, e.latlng.lng]);\n            this.updateBounds(bounds);\n            this.refreshVertexMarkers();\n        },\n\n        onDrawingMouseDown: function (e) {\n            L.Editable.PathEditor.prototype.onDrawingMouseDown.call(this, e);\n            this.connect();\n            var latlngs = this.getDefaultLatLngs();\n            // L.Polygon._convertLatLngs removes last latlng if it equals first point,\n            // which is the case here as all latlngs are [0, 0]\n            if (latlngs.length === 3) latlngs.push(e.latlng);\n            var bounds = new L.LatLngBounds(e.latlng, e.latlng);\n            this.updateBounds(bounds);\n            this.updateLatLngs(bounds);\n            this.refresh();\n            this.reset();\n            // Stop dragging map.\n            // L.Draggable has two workflows:\n            // - mousedown => mousemove => mouseup\n            // - touchstart => touchmove => touchend\n            // Problem: L.Map.Tap does not allow us to listen to touchstart, so we only\n            // can deal with mousedown, but then when in a touch device, we are dealing with\n            // simulated events (actually simulated by L.Map.Tap), which are no more taken\n            // into account by L.Draggable.\n            // Ref.: https://github.com/Leaflet/Leaflet.Editable/issues/103\n            e.originalEvent._simulated = false;\n            this.map.dragging._draggable._onUp(e.originalEvent);\n            // Now transfer ongoing drag action to the bottom right corner.\n            // Should we refine which corner will handle the drag according to\n            // drag direction?\n            latlngs[3].__vertex.dragging._draggable._onDown(e.originalEvent);\n        },\n\n        onDrawingMouseUp: function (e) {\n            this.commitDrawing(e);\n            e.originalEvent._simulated = false;\n            L.Editable.PathEditor.prototype.onDrawingMouseUp.call(this, e);\n        },\n\n        onDrawingMouseMove: function (e) {\n            e.originalEvent._simulated = false;\n            L.Editable.PathEditor.prototype.onDrawingMouseMove.call(this, e);\n        },\n\n\n        getDefaultLatLngs: function (latlngs) {\n            return latlngs || this.feature._latlngs[0];\n        },\n\n        updateBounds: function (bounds) {\n            this.feature._bounds = bounds;\n        },\n\n        updateLatLngs: function (bounds) {\n            var latlngs = this.getDefaultLatLngs(),\n                newLatlngs = this.feature._boundsToLatLngs(bounds);\n            // Keep references.\n            for (var i = 0; i < latlngs.length; i++) {\n                latlngs[i].update(newLatlngs[i]);\n            }\n        }\n\n    });\n\n    // 🍂namespace Editable; 🍂class CircleEditor; 🍂aka L.Editable.CircleEditor\n    // 🍂inherits PathEditor\n    L.Editable.CircleEditor = L.Editable.PathEditor.extend({\n\n        MIN_VERTEX: 2,\n\n        options: {\n            skipMiddleMarkers: true\n        },\n\n        initialize: function (map, feature, options) {\n            L.Editable.PathEditor.prototype.initialize.call(this, map, feature, options);\n            this._resizeLatLng = this.computeResizeLatLng();\n        },\n\n        computeResizeLatLng: function () {\n            // While circle is not added to the map, _radius is not set.\n            var delta = (this.feature._radius || this.feature._mRadius) * Math.cos(Math.PI / 4),\n                point = this.map.project(this.feature._latlng);\n            return this.map.unproject([point.x + delta, point.y - delta]);\n        },\n\n        updateResizeLatLng: function () {\n            this._resizeLatLng.update(this.computeResizeLatLng());\n            this._resizeLatLng.__vertex.update();\n        },\n\n        getLatLngs: function () {\n            return [this.feature._latlng, this._resizeLatLng];\n        },\n\n        getDefaultLatLngs: function () {\n            return this.getLatLngs();\n        },\n\n        onVertexMarkerDrag: function (e) {\n            if (e.vertex.getIndex() === 1) this.resize(e);\n            else this.updateResizeLatLng(e);\n            L.Editable.PathEditor.prototype.onVertexMarkerDrag.call(this, e);\n        },\n\n        resize: function (e) {\n            var radius = this.feature._latlng.distanceTo(e.latlng);\n            this.feature.setRadius(radius);\n        },\n\n        onDrawingMouseDown: function (e) {\n            L.Editable.PathEditor.prototype.onDrawingMouseDown.call(this, e);\n            this._resizeLatLng.update(e.latlng);\n            this.feature._latlng.update(e.latlng);\n            this.connect();\n            // Stop dragging map.\n            e.originalEvent._simulated = false;\n            this.map.dragging._draggable._onUp(e.originalEvent);\n            // Now transfer ongoing drag action to the radius handler.\n            this._resizeLatLng.__vertex.dragging._draggable._onDown(e.originalEvent);\n        },\n\n        onDrawingMouseUp: function (e) {\n            this.commitDrawing(e);\n            e.originalEvent._simulated = false;\n            L.Editable.PathEditor.prototype.onDrawingMouseUp.call(this, e);\n        },\n\n        onDrawingMouseMove: function (e) {\n            e.originalEvent._simulated = false;\n            L.Editable.PathEditor.prototype.onDrawingMouseMove.call(this, e);\n        },\n\n        onDrag: function (e) {\n            L.Editable.PathEditor.prototype.onDrag.call(this, e);\n            this.feature.dragging.updateLatLng(this._resizeLatLng);\n        }\n\n    });\n\n    // 🍂namespace Editable; 🍂class EditableMixin\n    // `EditableMixin` is included to `L.Polyline`, `L.Polygon`, `L.Rectangle`, `L.Circle`\n    // and `L.Marker`. It adds some methods to them.\n    // *When editing is enabled, the editor is accessible on the instance with the\n    // `editor` property.*\n    var EditableMixin = {\n\n        createEditor: function (map) {\n            map = map || this._map;\n            var tools = (this.options.editOptions || {}).editTools || map.editTools;\n            if (!tools) throw Error('Unable to detect Editable instance.');\n            var Klass = this.options.editorClass || this.getEditorClass(tools);\n            return new Klass(map, this, this.options.editOptions);\n        },\n\n        // 🍂method enableEdit(map?: L.Map): this.editor\n        // Enable editing, by creating an editor if not existing, and then calling `enable` on it.\n        enableEdit: function (map) {\n            if (!this.editor) this.createEditor(map);\n            this.editor.enable();\n            return this.editor;\n        },\n\n        // 🍂method editEnabled(): boolean\n        // Return true if current instance has an editor attached, and this editor is enabled.\n        editEnabled: function () {\n            return this.editor && this.editor.enabled();\n        },\n\n        // 🍂method disableEdit()\n        // Disable editing, also remove the editor property reference.\n        disableEdit: function () {\n            if (this.editor) {\n                this.editor.disable();\n                delete this.editor;\n            }\n        },\n\n        // 🍂method toggleEdit()\n        // Enable or disable editing, according to current status.\n        toggleEdit: function () {\n            if (this.editEnabled()) this.disableEdit();\n            else this.enableEdit();\n        },\n\n        _onEditableAdd: function () {\n            if (this.editor) this.enableEdit();\n        }\n\n    };\n\n    var PolylineMixin = {\n\n        getEditorClass: function (tools) {\n            return (tools && tools.options.polylineEditorClass) ? tools.options.polylineEditorClass : L.Editable.PolylineEditor;\n        },\n\n        shapeAt: function (latlng, latlngs) {\n            // We can have those cases:\n            // - latlngs are just a flat array of latlngs, use this\n            // - latlngs is an array of arrays of latlngs, loop over\n            var shape = null;\n            latlngs = latlngs || this._latlngs;\n            if (!latlngs.length) return shape;\n            else if (isFlat(latlngs) && this.isInLatLngs(latlng, latlngs)) shape = latlngs;\n            else for (var i = 0; i < latlngs.length; i++) if (this.isInLatLngs(latlng, latlngs[i])) return latlngs[i];\n            return shape;\n        },\n\n        isInLatLngs: function (l, latlngs) {\n            if (!latlngs) return false;\n            var i, k, len, part = [], p,\n                w = this._clickTolerance();\n            this._projectLatlngs(latlngs, part, this._pxBounds);\n            part = part[0];\n            p = this._map.latLngToLayerPoint(l);\n\n            if (!this._pxBounds.contains(p)) { return false; }\n            for (i = 1, len = part.length, k = 0; i < len; k = i++) {\n\n                if (L.LineUtil.pointToSegmentDistance(p, part[k], part[i]) <= w) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n    };\n\n    var PolygonMixin = {\n\n        getEditorClass: function (tools) {\n            return (tools && tools.options.polygonEditorClass) ? tools.options.polygonEditorClass : L.Editable.PolygonEditor;\n        },\n\n        shapeAt: function (latlng, latlngs) {\n            // We can have those cases:\n            // - latlngs are just a flat array of latlngs, use this\n            // - latlngs is an array of arrays of latlngs, this is a simple polygon (maybe with holes), use the first\n            // - latlngs is an array of arrays of arrays, this is a multi, loop over\n            var shape = null;\n            latlngs = latlngs || this._latlngs;\n            if (!latlngs.length) return shape;\n            else if (isFlat(latlngs) && this.isInLatLngs(latlng, latlngs)) shape = latlngs;\n            else if (isFlat(latlngs[0]) && this.isInLatLngs(latlng, latlngs[0])) shape = latlngs;\n            else for (var i = 0; i < latlngs.length; i++) if (this.isInLatLngs(latlng, latlngs[i][0])) return latlngs[i];\n            return shape;\n        },\n\n        isInLatLngs: function (l, latlngs) {\n            var inside = false, l1, l2, j, k, len2;\n\n            for (j = 0, len2 = latlngs.length, k = len2 - 1; j < len2; k = j++) {\n                l1 = latlngs[j];\n                l2 = latlngs[k];\n\n                if (((l1.lat > l.lat) !== (l2.lat > l.lat)) &&\n                        (l.lng < (l2.lng - l1.lng) * (l.lat - l1.lat) / (l2.lat - l1.lat) + l1.lng)) {\n                    inside = !inside;\n                }\n            }\n\n            return inside;\n        },\n\n        parentShape: function (shape, latlngs) {\n            latlngs = latlngs || this._latlngs;\n            if (!latlngs) return;\n            var idx = L.Util.indexOf(latlngs, shape);\n            if (idx !== -1) return latlngs;\n            for (var i = 0; i < latlngs.length; i++) {\n                idx = L.Util.indexOf(latlngs[i], shape);\n                if (idx !== -1) return latlngs[i];\n            }\n        }\n\n    };\n\n\n    var MarkerMixin = {\n\n        getEditorClass: function (tools) {\n            return (tools && tools.options.markerEditorClass) ? tools.options.markerEditorClass : L.Editable.MarkerEditor;\n        }\n\n    };\n\n    var RectangleMixin = {\n\n        getEditorClass: function (tools) {\n            return (tools && tools.options.rectangleEditorClass) ? tools.options.rectangleEditorClass : L.Editable.RectangleEditor;\n        }\n\n    };\n\n    var CircleMixin = {\n\n        getEditorClass: function (tools) {\n            return (tools && tools.options.circleEditorClass) ? tools.options.circleEditorClass : L.Editable.CircleEditor;\n        }\n\n    };\n\n    var keepEditable = function () {\n        // Make sure you can remove/readd an editable layer.\n        this.on('add', this._onEditableAdd);\n    };\n\n    var isFlat = L.LineUtil.isFlat || L.LineUtil._flat || L.Polyline._flat;  // <=> 1.1 compat.\n\n\n    if (L.Polyline) {\n        L.Polyline.include(EditableMixin);\n        L.Polyline.include(PolylineMixin);\n        L.Polyline.addInitHook(keepEditable);\n    }\n    if (L.Polygon) {\n        L.Polygon.include(EditableMixin);\n        L.Polygon.include(PolygonMixin);\n    }\n    if (L.Marker) {\n        L.Marker.include(EditableMixin);\n        L.Marker.include(MarkerMixin);\n        L.Marker.addInitHook(keepEditable);\n    }\n    if (L.Rectangle) {\n        L.Rectangle.include(EditableMixin);\n        L.Rectangle.include(RectangleMixin);\n    }\n    if (L.Circle) {\n        L.Circle.include(EditableMixin);\n        L.Circle.include(CircleMixin);\n    }\n\n    L.LatLng.prototype.update = function (latlng) {\n        latlng = L.latLng(latlng);\n        this.lat = latlng.lat;\n        this.lng = latlng.lng;\n    }\n\n}, window));\n\n\n\n// WEBPACK FOOTER //\n// ./Vue2LeafletEditable.js","module.exports = require(\"leaflet\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"leaflet\"\n// module id = 1\n// module chunks = 0"],"sourceRoot":""}