{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///Vue2LeafletEditablePlugin.js","webpack:///webpack/bootstrap b31ff26b210a6292af03","webpack:///./Vue2LeafletEditablePlugin.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","install","init","window","L","Editable","Evented","extend","statics","FORWARD","BACKWARD","options","zIndex","polygonClass","Polygon","polylineClass","Polyline","markerClass","Marker","rectangleClass","Rectangle","circleClass","Circle","drawingCSSClass","drawingCursor","editLayer","undefined","featuresLayer","polylineEditorClass","polygonEditorClass","markerEditorClass","rectangleEditorClass","circleEditorClass","lineGuideOptions","skipMiddleMarkers","initialize","map","setOptions","_lastZIndex","createEditLayer","createFeaturesLayer","forwardLineGuide","createLineGuide","backwardLineGuide","fireAndForward","type","e","editTools","fire","dashArray","weight","interactive","polyline","createVertexIcon","Browser","mobile","touch","TouchVertexIcon","VertexIcon","LayerGroup","addTo","moveForwardLineGuide","latlng","_latlngs","length","_bounds","redraw","moveBackwardLineGuide","anchorForwardLineGuide","anchorBackwardLineGuide","attachForwardLineGuide","addLayer","attachBackwardLineGuide","detachForwardLineGuide","setLatLngs","removeLayer","detachBackwardLineGuide","blockEvents","_oldTargets","_targets","unblockEvents","registerForDrawing","editor","_drawingEditor","unregisterForDrawing","reset","on","onDrawingMouseMove","onMousedown","onMouseup","DomUtil","addClass","_container","defaultMapCursor","style","cursor","removeClass","off","_drawing","cancelDrawing","originalEvent","which","_mouseDown","onDrawingMouseDown","mouseDown","onDrawingMouseUp","origin","point","clientX","clientY","distance","distanceTo","Math","abs","devicePixelRatio","onDrawingClick","drawing","stopDrawing","commitDrawing","connectCreatedToMap","layer","startPolyline","line","createPolyline","enableEdit","newShape","startPolygon","polygon","createPolygon","startMarker","getCenter","clone","marker","createMarker","startDrawing","startRectangle","corner","latLng","bounds","LatLngBounds","rectangle","createRectangle","startCircle","circle","createCircle","startHole","newHole","createLayer","klass","latlngs","Util","editOptions","makeCancellable","cancel","_cancelled","Map","mergeOptions","editToolsClass","editable","addInitHook","whenReady","DivIcon","iconSize","Point","VertexMarker","draggable","className","icon","tools","__vertex","setZIndexOffset","onAdd","onDrag","onDragStart","onDragEnd","onClick","onContextMenu","onMouseDown","onMouseOver","onMouseOut","addMiddleMarkers","onRemove","middleMarker","delete","vertex","onVertexMarkerDrag","iconPos","getPosition","_icon","_map","layerPointToLatLng","update","_latlng","refresh","updateLatLng","next","getNext","onVertexMarkerDragStart","onVertexMarkerDragEnd","onVertexMarkerClick","DomEvent","stop","onVertexMarkerContextMenu","onVertexMarkerMouseDown","onVertexMarkerMouseOver","onVertexMarkerMouseOut","splice","getIndex","onVertexDeleted","deleteShape","resetMiddleMarker","indexOf","getLastIndex","getPrevious","index","previousIndex","CLOSED","previous","nextIndex","addMiddleMarker","hasMiddleMarkers","split","splitShape","continue","continueBackward","continueForward","vertexMarkerClass","MiddleMarker","opacity","left","right","computeLatLng","_opacity","setVisibility","leftPoint","latLngToContainerPoint","rightPoint","size","x","hide","show","setOpacity","setLatLng","y","containerPointToLatLng","onMiddleMarkerMouseDown","addVertexMarker","onNewVertex","parent","parentNode","removeChild","appendChild","_initIcon","_initInteraction","Draggable","_dragging","dragging","_draggable","_onDown","middleMarkerClass","BaseEditor","Handler","feature","addHooks","isConnected","onFeatureAdd","once","onEnable","_getEvents","removeHooks","disable","clearLayers","onDisable","enable","onEditing","onStartDrawing","onEndDrawing","onCancelDrawing","onCommitDrawing","endDrawing","connect","processDrawingClick","hasLayer","onMove","dragstart","drag","dragend","remove","MarkerEditor","PathEditor","MIN_VERTEX","initVertexMarkers","enabled","getLatLngs","isFlat","addVertexMarkers","refreshVertexMarkers","getDefaultLatLngs","commit","ctrlKey","onVertexMarkerCtrlClick","altKey","onVertexMarkerAltClick","shiftKey","onVertexMarkerShiftClick","metaKey","onVertexMarkerMetaKeyClick","_drawnLatLngs","onVertexRawMarkerClick","vertexCanBeDeleted","extendBounds","setDrawnLatLngs","startDrawingForward","addLatLng","push","unshift","newPointForward","newPointBackward","console","error","removeLatLng","pop","shape","addNewEmptyShape","_deleteShape","ensureNotFlat","self","spliceDelete","Number","MAX_VALUE","deleteShapeAt","shapeAt","appendShape","insertShape","prependShape","ensureMulti","formatShape","_enabled","PolylineEditor","startDrawingBackward","LatLng","shapeIndex","first","slice","second","lat","lng","alt","PolygonEditor","addNewEmptyHole","holes","parentShape","RectangleEditor","oppositeIndex","opposite","updateBounds","updateLatLngs","_simulated","_onUp","newLatlngs","_boundsToLatLngs","CircleEditor","_resizeLatLng","computeResizeLatLng","delta","_radius","_mRadius","cos","PI","project","unproject","updateResizeLatLng","resize","radius","setRadius","EditableMixin","createEditor","Error","editorClass","getEditorClass","editEnabled","disableEdit","toggleEdit","_onEditableAdd","PolylineMixin","isInLatLngs","k","len","part","w","_clickTolerance","_projectLatlngs","_pxBounds","latLngToLayerPoint","contains","LineUtil","pointToSegmentDistance","PolygonMixin","l1","l2","j","len2","inside","idx","MarkerMixin","RectangleMixin","CircleMixin","keepEditable","_flat","include"],"mappings":"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","file":"Vue2LeafletEditablePlugin.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Vue2LeafletEditablePlugin\"] = factory();\n\telse\n\t\troot[\"Vue2LeafletEditablePlugin\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Vue2LeafletEditablePlugin\"] = factory();\n\telse\n\t\troot[\"Vue2LeafletEditablePlugin\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 1);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n    install: function install() {\n        this.init(window.L);\n    },\n    init: function init(L) {\n        // 🍂miniclass CancelableEvent (Event objects)\n        // 🍂method cancel()\n        // Cancel any subsequent action.\n\n        // 🍂miniclass VertexEvent (Event objects)\n        // 🍂property vertex: VertexMarker\n        // The vertex that fires the event.\n\n        // 🍂miniclass ShapeEvent (Event objects)\n        // 🍂property shape: Array\n        // The shape (LatLngs array) subject of the action.\n\n        // 🍂miniclass CancelableVertexEvent (Event objects)\n        // 🍂inherits VertexEvent\n        // 🍂inherits CancelableEvent\n\n        // 🍂miniclass CancelableShapeEvent (Event objects)\n        // 🍂inherits ShapeEvent\n        // 🍂inherits CancelableEvent\n\n        // 🍂miniclass LayerEvent (Event objects)\n        // 🍂property layer: object\n        // The Layer (Marker, Polyline…) subject of the action.\n\n        // 🍂namespace Editable; 🍂class Editable; 🍂aka L.Editable\n        // Main edition handler. By default, it is attached to the map\n        // as `map.editTools` property.\n        // Leaflet.Editable is made to be fully extendable. You have three ways to customize\n        // the behaviour: using options, listening to events, or extending.\n        L.Editable = L.Evented.extend({\n\n            statics: {\n                FORWARD: 1,\n                BACKWARD: -1\n            },\n\n            options: {\n\n                // You can pass them when creating a map using the `editOptions` key.\n                // 🍂option zIndex: int = 1000\n                // The default zIndex of the editing tools.\n                zIndex: 1000,\n\n                // 🍂option polygonClass: class = L.Polygon\n                // Class to be used when creating a new Polygon.\n                polygonClass: L.Polygon,\n\n                // 🍂option polylineClass: class = L.Polyline\n                // Class to be used when creating a new Polyline.\n                polylineClass: L.Polyline,\n\n                // 🍂option markerClass: class = L.Marker\n                // Class to be used when creating a new Marker.\n                markerClass: L.Marker,\n\n                // 🍂option rectangleClass: class = L.Rectangle\n                // Class to be used when creating a new Rectangle.\n                rectangleClass: L.Rectangle,\n\n                // 🍂option circleClass: class = L.Circle\n                // Class to be used when creating a new Circle.\n                circleClass: L.Circle,\n\n                // 🍂option drawingCSSClass: string = 'leaflet-editable-drawing'\n                // CSS class to be added to the map container while drawing.\n                drawingCSSClass: 'leaflet-editable-drawing',\n\n                // 🍂option drawingCursor: const = 'crosshair'\n                // Cursor mode set to the map while drawing.\n                drawingCursor: 'crosshair',\n\n                // 🍂option editLayer: Layer = new L.LayerGroup()\n                // Layer used to store edit tools (vertex, line guide…).\n                editLayer: undefined,\n\n                // 🍂option featuresLayer: Layer = new L.LayerGroup()\n                // Default layer used to store drawn features (Marker, Polyline…).\n                featuresLayer: undefined,\n\n                // 🍂option polylineEditorClass: class = PolylineEditor\n                // Class to be used as Polyline editor.\n                polylineEditorClass: undefined,\n\n                // 🍂option polygonEditorClass: class = PolygonEditor\n                // Class to be used as Polygon editor.\n                polygonEditorClass: undefined,\n\n                // 🍂option markerEditorClass: class = MarkerEditor\n                // Class to be used as Marker editor.\n                markerEditorClass: undefined,\n\n                // 🍂option rectangleEditorClass: class = RectangleEditor\n                // Class to be used as Rectangle editor.\n                rectangleEditorClass: undefined,\n\n                // 🍂option circleEditorClass: class = CircleEditor\n                // Class to be used as Circle editor.\n                circleEditorClass: undefined,\n\n                // 🍂option lineGuideOptions: hash = {}\n                // Options to be passed to the line guides.\n                lineGuideOptions: {},\n\n                // 🍂option skipMiddleMarkers: boolean = false\n                // Set this to true if you don't want middle markers.\n                skipMiddleMarkers: false\n\n            },\n\n            initialize: function initialize(map, options) {\n                L.setOptions(this, options);\n                this._lastZIndex = this.options.zIndex;\n                this.map = map;\n                this.editLayer = this.createEditLayer();\n                this.featuresLayer = this.createFeaturesLayer();\n                this.forwardLineGuide = this.createLineGuide();\n                this.backwardLineGuide = this.createLineGuide();\n            },\n\n            fireAndForward: function fireAndForward(type, e) {\n                e = e || {};\n                e.editTools = this;\n                this.fire(type, e);\n                this.map.fire(type, e);\n            },\n\n            createLineGuide: function createLineGuide() {\n                var options = L.extend({ dashArray: '5,10', weight: 1, interactive: false }, this.options.lineGuideOptions);\n                return L.polyline([], options);\n            },\n\n            createVertexIcon: function createVertexIcon(options) {\n                return L.Browser.mobile && L.Browser.touch ? new L.Editable.TouchVertexIcon(options) : new L.Editable.VertexIcon(options);\n            },\n\n            createEditLayer: function createEditLayer() {\n                return this.options.editLayer || new L.LayerGroup().addTo(this.map);\n            },\n\n            createFeaturesLayer: function createFeaturesLayer() {\n                return this.options.featuresLayer || new L.LayerGroup().addTo(this.map);\n            },\n\n            moveForwardLineGuide: function moveForwardLineGuide(latlng) {\n                if (this.forwardLineGuide._latlngs.length) {\n                    this.forwardLineGuide._latlngs[1] = latlng;\n                    this.forwardLineGuide._bounds.extend(latlng);\n                    this.forwardLineGuide.redraw();\n                }\n            },\n\n            moveBackwardLineGuide: function moveBackwardLineGuide(latlng) {\n                if (this.backwardLineGuide._latlngs.length) {\n                    this.backwardLineGuide._latlngs[1] = latlng;\n                    this.backwardLineGuide._bounds.extend(latlng);\n                    this.backwardLineGuide.redraw();\n                }\n            },\n\n            anchorForwardLineGuide: function anchorForwardLineGuide(latlng) {\n                this.forwardLineGuide._latlngs[0] = latlng;\n                this.forwardLineGuide._bounds.extend(latlng);\n                this.forwardLineGuide.redraw();\n            },\n\n            anchorBackwardLineGuide: function anchorBackwardLineGuide(latlng) {\n                this.backwardLineGuide._latlngs[0] = latlng;\n                this.backwardLineGuide._bounds.extend(latlng);\n                this.backwardLineGuide.redraw();\n            },\n\n            attachForwardLineGuide: function attachForwardLineGuide() {\n                this.editLayer.addLayer(this.forwardLineGuide);\n            },\n\n            attachBackwardLineGuide: function attachBackwardLineGuide() {\n                this.editLayer.addLayer(this.backwardLineGuide);\n            },\n\n            detachForwardLineGuide: function detachForwardLineGuide() {\n                this.forwardLineGuide.setLatLngs([]);\n                this.editLayer.removeLayer(this.forwardLineGuide);\n            },\n\n            detachBackwardLineGuide: function detachBackwardLineGuide() {\n                this.backwardLineGuide.setLatLngs([]);\n                this.editLayer.removeLayer(this.backwardLineGuide);\n            },\n\n            blockEvents: function blockEvents() {\n                // Hack: force map not to listen to other layers events while drawing.\n                if (!this._oldTargets) {\n                    this._oldTargets = this.map._targets;\n                    this.map._targets = {};\n                }\n            },\n\n            unblockEvents: function unblockEvents() {\n                if (this._oldTargets) {\n                    // Reset, but keep targets created while drawing.\n                    this.map._targets = L.extend(this.map._targets, this._oldTargets);\n                    delete this._oldTargets;\n                }\n            },\n\n            registerForDrawing: function registerForDrawing(editor) {\n                if (this._drawingEditor) this.unregisterForDrawing(this._drawingEditor);\n                this.blockEvents();\n                editor.reset(); // Make sure editor tools still receive events.\n                this._drawingEditor = editor;\n                this.map.on('mousemove touchmove', editor.onDrawingMouseMove, editor);\n                this.map.on('mousedown', this.onMousedown, this);\n                this.map.on('mouseup', this.onMouseup, this);\n                L.DomUtil.addClass(this.map._container, this.options.drawingCSSClass);\n                this.defaultMapCursor = this.map._container.style.cursor;\n                this.map._container.style.cursor = this.options.drawingCursor;\n            },\n\n            unregisterForDrawing: function unregisterForDrawing(editor) {\n                this.unblockEvents();\n                L.DomUtil.removeClass(this.map._container, this.options.drawingCSSClass);\n                this.map._container.style.cursor = this.defaultMapCursor;\n                editor = editor || this._drawingEditor;\n                if (!editor) return;\n                this.map.off('mousemove touchmove', editor.onDrawingMouseMove, editor);\n                this.map.off('mousedown', this.onMousedown, this);\n                this.map.off('mouseup', this.onMouseup, this);\n                if (editor !== this._drawingEditor) return;\n                delete this._drawingEditor;\n                if (editor._drawing) editor.cancelDrawing();\n            },\n\n            onMousedown: function onMousedown(e) {\n                if (e.originalEvent.which != 1) return;\n                this._mouseDown = e;\n                this._drawingEditor.onDrawingMouseDown(e);\n            },\n\n            onMouseup: function onMouseup(e) {\n                if (this._mouseDown) {\n                    var editor = this._drawingEditor,\n                        mouseDown = this._mouseDown;\n                    this._mouseDown = null;\n                    editor.onDrawingMouseUp(e);\n                    if (this._drawingEditor !== editor) return; // onDrawingMouseUp may call unregisterFromDrawing.\n                    var origin = L.point(mouseDown.originalEvent.clientX, mouseDown.originalEvent.clientY);\n                    var distance = L.point(e.originalEvent.clientX, e.originalEvent.clientY).distanceTo(origin);\n                    if (Math.abs(distance) < 9 * (window.devicePixelRatio || 1)) this._drawingEditor.onDrawingClick(e);\n                }\n            },\n\n            // 🍂section Public methods\n            // You will generally access them by the `map.editTools`\n            // instance:\n            //\n            // `map.editTools.startPolyline();`\n\n            // 🍂method drawing(): boolean\n            // Return true if any drawing action is ongoing.\n            drawing: function drawing() {\n                return this._drawingEditor && this._drawingEditor.drawing();\n            },\n\n            // 🍂method stopDrawing()\n            // When you need to stop any ongoing drawing, without needing to know which editor is active.\n            stopDrawing: function stopDrawing() {\n                this.unregisterForDrawing();\n            },\n\n            // 🍂method commitDrawing()\n            // When you need to commit any ongoing drawing, without needing to know which editor is active.\n            commitDrawing: function commitDrawing(e) {\n                if (!this._drawingEditor) return;\n                this._drawingEditor.commitDrawing(e);\n            },\n\n            connectCreatedToMap: function connectCreatedToMap(layer) {\n                return this.featuresLayer.addLayer(layer);\n            },\n\n            // 🍂method startPolyline(latlng: L.LatLng, options: hash): L.Polyline\n            // Start drawing a Polyline. If `latlng` is given, a first point will be added. In any case, continuing on user click.\n            // If `options` is given, it will be passed to the Polyline class constructor.\n            startPolyline: function startPolyline(latlng, options) {\n                var line = this.createPolyline([], options);\n                line.enableEdit(this.map).newShape(latlng);\n                return line;\n            },\n\n            // 🍂method startPolygon(latlng: L.LatLng, options: hash): L.Polygon\n            // Start drawing a Polygon. If `latlng` is given, a first point will be added. In any case, continuing on user click.\n            // If `options` is given, it will be passed to the Polygon class constructor.\n            startPolygon: function startPolygon(latlng, options) {\n                var polygon = this.createPolygon([], options);\n                polygon.enableEdit(this.map).newShape(latlng);\n                return polygon;\n            },\n\n            // 🍂method startMarker(latlng: L.LatLng, options: hash): L.Marker\n            // Start adding a Marker. If `latlng` is given, the Marker will be shown first at this point.\n            // In any case, it will follow the user mouse, and will have a final `latlng` on next click (or touch).\n            // If `options` is given, it will be passed to the Marker class constructor.\n            startMarker: function startMarker(latlng, options) {\n                latlng = latlng || this.map.getCenter().clone();\n                var marker = this.createMarker(latlng, options);\n                marker.enableEdit(this.map).startDrawing();\n                return marker;\n            },\n\n            // 🍂method startRectangle(latlng: L.LatLng, options: hash): L.Rectangle\n            // Start drawing a Rectangle. If `latlng` is given, the Rectangle anchor will be added. In any case, continuing on user drag.\n            // If `options` is given, it will be passed to the Rectangle class constructor.\n            startRectangle: function startRectangle(latlng, options) {\n                var corner = latlng || L.latLng([0, 0]);\n                var bounds = new L.LatLngBounds(corner, corner);\n                var rectangle = this.createRectangle(bounds, options);\n                rectangle.enableEdit(this.map).startDrawing();\n                return rectangle;\n            },\n\n            // 🍂method startCircle(latlng: L.LatLng, options: hash): L.Circle\n            // Start drawing a Circle. If `latlng` is given, the Circle anchor will be added. In any case, continuing on user drag.\n            // If `options` is given, it will be passed to the Circle class constructor.\n            startCircle: function startCircle(latlng, options) {\n                latlng = latlng || this.map.getCenter().clone();\n                var circle = this.createCircle(latlng, options);\n                circle.enableEdit(this.map).startDrawing();\n                return circle;\n            },\n\n            startHole: function startHole(editor, latlng) {\n                editor.newHole(latlng);\n            },\n\n            createLayer: function createLayer(klass, latlngs, options) {\n                options = L.Util.extend({ editOptions: { editTools: this } }, options);\n                var layer = new klass(latlngs, options);\n                // 🍂namespace Editable\n                // 🍂event editable:created: LayerEvent\n                // Fired when a new feature (Marker, Polyline…) is created.\n                this.fireAndForward('editable:created', { layer: layer });\n                return layer;\n            },\n\n            createPolyline: function createPolyline(latlngs, options) {\n                return this.createLayer(options && options.polylineClass || this.options.polylineClass, latlngs, options);\n            },\n\n            createPolygon: function createPolygon(latlngs, options) {\n                return this.createLayer(options && options.polygonClass || this.options.polygonClass, latlngs, options);\n            },\n\n            createMarker: function createMarker(latlng, options) {\n                return this.createLayer(options && options.markerClass || this.options.markerClass, latlng, options);\n            },\n\n            createRectangle: function createRectangle(bounds, options) {\n                return this.createLayer(options && options.rectangleClass || this.options.rectangleClass, bounds, options);\n            },\n\n            createCircle: function createCircle(latlng, options) {\n                return this.createLayer(options && options.circleClass || this.options.circleClass, latlng, options);\n            }\n\n        });\n\n        L.extend(L.Editable, {\n\n            makeCancellable: function makeCancellable(e) {\n                e.cancel = function () {\n                    e._cancelled = true;\n                };\n            }\n\n        });\n\n        // 🍂namespace Map; 🍂class Map\n        // Leaflet.Editable add options and events to the `L.Map` object.\n        // See `Editable` events for the list of events fired on the Map.\n        // 🍂example\n        //\n        // ```js\n        // var map = L.map('map', {\n        //  editable: true,\n        //  editOptions: {\n        //    …\n        // }\n        // });\n        // ```\n        // 🍂section Editable Map Options\n        L.Map.mergeOptions({\n\n            // 🍂namespace Map\n            // 🍂section Map Options\n            // 🍂option editToolsClass: class = L.Editable\n            // Class to be used as vertex, for path editing.\n            editToolsClass: L.Editable,\n\n            // 🍂option editable: boolean = false\n            // Whether to create a L.Editable instance at map init.\n            editable: false,\n\n            // 🍂option editOptions: hash = {}\n            // Options to pass to L.Editable when instantiating.\n            editOptions: {}\n\n        });\n\n        L.Map.addInitHook(function () {\n\n            this.whenReady(function () {\n                if (this.options.editable) {\n                    this.editTools = new this.options.editToolsClass(this, this.options.editOptions);\n                }\n            });\n        });\n\n        L.Editable.VertexIcon = L.DivIcon.extend({\n\n            options: {\n                iconSize: new L.Point(8, 8)\n            }\n\n        });\n\n        L.Editable.TouchVertexIcon = L.Editable.VertexIcon.extend({\n\n            options: {\n                iconSize: new L.Point(20, 20)\n            }\n\n        });\n\n        // 🍂namespace Editable; 🍂class VertexMarker; Handler for dragging path vertices.\n        L.Editable.VertexMarker = L.Marker.extend({\n\n            options: {\n                draggable: true,\n                className: 'leaflet-div-icon leaflet-vertex-icon'\n            },\n\n            // 🍂section Public methods\n            // The marker used to handle path vertex. You will usually interact with a `VertexMarker`\n            // instance when listening for events like `editable:vertex:ctrlclick`.\n\n            initialize: function initialize(latlng, latlngs, editor, options) {\n                // We don't use this._latlng, because on drag Leaflet replace it while\n                // we want to keep reference.\n                this.latlng = latlng;\n                this.latlngs = latlngs;\n                this.editor = editor;\n                L.Marker.prototype.initialize.call(this, latlng, options);\n                this.options.icon = this.editor.tools.createVertexIcon({ className: this.options.className });\n                this.latlng.__vertex = this;\n                this.editor.editLayer.addLayer(this);\n                this.setZIndexOffset(editor.tools._lastZIndex + 1);\n            },\n\n            onAdd: function onAdd(map) {\n                L.Marker.prototype.onAdd.call(this, map);\n                this.on('drag', this.onDrag);\n                this.on('dragstart', this.onDragStart);\n                this.on('dragend', this.onDragEnd);\n                this.on('mouseup', this.onMouseup);\n                this.on('click', this.onClick);\n                this.on('contextmenu', this.onContextMenu);\n                this.on('mousedown touchstart', this.onMouseDown);\n                this.on('mouseover', this.onMouseOver);\n                this.on('mouseout', this.onMouseOut);\n                this.addMiddleMarkers();\n            },\n\n            onRemove: function onRemove(map) {\n                if (this.middleMarker) this.middleMarker.delete();\n                delete this.latlng.__vertex;\n                this.off('drag', this.onDrag);\n                this.off('dragstart', this.onDragStart);\n                this.off('dragend', this.onDragEnd);\n                this.off('mouseup', this.onMouseup);\n                this.off('click', this.onClick);\n                this.off('contextmenu', this.onContextMenu);\n                this.off('mousedown touchstart', this.onMouseDown);\n                this.off('mouseover', this.onMouseOver);\n                this.off('mouseout', this.onMouseOut);\n                L.Marker.prototype.onRemove.call(this, map);\n            },\n\n            onDrag: function onDrag(e) {\n                e.vertex = this;\n                this.editor.onVertexMarkerDrag(e);\n                var iconPos = L.DomUtil.getPosition(this._icon),\n                    latlng = this._map.layerPointToLatLng(iconPos);\n                this.latlng.update(latlng);\n                this._latlng = this.latlng; // Push back to Leaflet our reference.\n                this.editor.refresh();\n                if (this.middleMarker) this.middleMarker.updateLatLng();\n                var next = this.getNext();\n                if (next && next.middleMarker) next.middleMarker.updateLatLng();\n            },\n\n            onDragStart: function onDragStart(e) {\n                e.vertex = this;\n                this.editor.onVertexMarkerDragStart(e);\n            },\n\n            onDragEnd: function onDragEnd(e) {\n                e.vertex = this;\n                this.editor.onVertexMarkerDragEnd(e);\n            },\n\n            onClick: function onClick(e) {\n                e.vertex = this;\n                this.editor.onVertexMarkerClick(e);\n            },\n\n            onMouseup: function onMouseup(e) {\n                L.DomEvent.stop(e);\n                e.vertex = this;\n                this.editor.map.fire('mouseup', e);\n            },\n\n            onContextMenu: function onContextMenu(e) {\n                e.vertex = this;\n                this.editor.onVertexMarkerContextMenu(e);\n            },\n\n            onMouseDown: function onMouseDown(e) {\n                e.vertex = this;\n                this.editor.onVertexMarkerMouseDown(e);\n            },\n\n            onMouseOver: function onMouseOver(e) {\n                e.vertex = this;\n                this.editor.onVertexMarkerMouseOver(e);\n            },\n\n            onMouseOut: function onMouseOut(e) {\n                e.vertex = this;\n                this.editor.onVertexMarkerMouseOut(e);\n            },\n\n            // 🍂method delete()\n            // Delete a vertex and the related LatLng.\n            delete: function _delete() {\n                var next = this.getNext(); // Compute before changing latlng\n                this.latlngs.splice(this.getIndex(), 1);\n                this.editor.editLayer.removeLayer(this);\n                this.editor.onVertexDeleted({ latlng: this.latlng, vertex: this });\n                if (!this.latlngs.length) this.editor.deleteShape(this.latlngs);\n                if (next) next.resetMiddleMarker();\n                this.editor.refresh();\n            },\n\n            // 🍂method getIndex(): int\n            // Get the index of the current vertex among others of the same LatLngs group.\n            getIndex: function getIndex() {\n                return this.latlngs.indexOf(this.latlng);\n            },\n\n            // 🍂method getLastIndex(): int\n            // Get last vertex index of the LatLngs group of the current vertex.\n            getLastIndex: function getLastIndex() {\n                return this.latlngs.length - 1;\n            },\n\n            // 🍂method getPrevious(): VertexMarker\n            // Get the previous VertexMarker in the same LatLngs group.\n            getPrevious: function getPrevious() {\n                if (this.latlngs.length < 2) return;\n                var index = this.getIndex(),\n                    previousIndex = index - 1;\n                if (index === 0 && this.editor.CLOSED) previousIndex = this.getLastIndex();\n                var previous = this.latlngs[previousIndex];\n                if (previous) return previous.__vertex;\n            },\n\n            // 🍂method getNext(): VertexMarker\n            // Get the next VertexMarker in the same LatLngs group.\n            getNext: function getNext() {\n                if (this.latlngs.length < 2) return;\n                var index = this.getIndex(),\n                    nextIndex = index + 1;\n                if (index === this.getLastIndex() && this.editor.CLOSED) nextIndex = 0;\n                var next = this.latlngs[nextIndex];\n                if (next) return next.__vertex;\n            },\n\n            addMiddleMarker: function addMiddleMarker(previous) {\n                if (!this.editor.hasMiddleMarkers()) return;\n                previous = previous || this.getPrevious();\n                if (previous && !this.middleMarker) this.middleMarker = this.editor.addMiddleMarker(previous, this, this.latlngs, this.editor);\n            },\n\n            addMiddleMarkers: function addMiddleMarkers() {\n                if (!this.editor.hasMiddleMarkers()) return;\n                var previous = this.getPrevious();\n                if (previous) this.addMiddleMarker(previous);\n                var next = this.getNext();\n                if (next) next.resetMiddleMarker();\n            },\n\n            resetMiddleMarker: function resetMiddleMarker() {\n                if (this.middleMarker) this.middleMarker.delete();\n                this.addMiddleMarker();\n            },\n\n            // 🍂method split()\n            // Split the vertex LatLngs group at its index, if possible.\n            split: function split() {\n                if (!this.editor.splitShape) return; // Only for PolylineEditor\n                this.editor.splitShape(this.latlngs, this.getIndex());\n            },\n\n            // 🍂method continue()\n            // Continue the vertex LatLngs from this vertex. Only active for first and last vertices of a Polyline.\n            continue: function _continue() {\n                if (!this.editor.continueBackward) return; // Only for PolylineEditor\n                var index = this.getIndex();\n                if (index === 0) this.editor.continueBackward(this.latlngs);else if (index === this.getLastIndex()) this.editor.continueForward(this.latlngs);\n            }\n\n        });\n\n        L.Editable.mergeOptions({\n\n            // 🍂namespace Editable\n            // 🍂option vertexMarkerClass: class = VertexMarker\n            // Class to be used as vertex, for path editing.\n            vertexMarkerClass: L.Editable.VertexMarker\n\n        });\n\n        L.Editable.MiddleMarker = L.Marker.extend({\n\n            options: {\n                opacity: 0.5,\n                className: 'leaflet-div-icon leaflet-middle-icon',\n                draggable: true\n            },\n\n            initialize: function initialize(left, right, latlngs, editor, options) {\n                this.left = left;\n                this.right = right;\n                this.editor = editor;\n                this.latlngs = latlngs;\n                L.Marker.prototype.initialize.call(this, this.computeLatLng(), options);\n                this._opacity = this.options.opacity;\n                this.options.icon = this.editor.tools.createVertexIcon({ className: this.options.className });\n                this.editor.editLayer.addLayer(this);\n                this.setVisibility();\n            },\n\n            setVisibility: function setVisibility() {\n                var leftPoint = this._map.latLngToContainerPoint(this.left.latlng),\n                    rightPoint = this._map.latLngToContainerPoint(this.right.latlng),\n                    size = L.point(this.options.icon.options.iconSize);\n                if (leftPoint.distanceTo(rightPoint) < size.x * 3) this.hide();else this.show();\n            },\n\n            show: function show() {\n                this.setOpacity(this._opacity);\n            },\n\n            hide: function hide() {\n                this.setOpacity(0);\n            },\n\n            updateLatLng: function updateLatLng() {\n                this.setLatLng(this.computeLatLng());\n                this.setVisibility();\n            },\n\n            computeLatLng: function computeLatLng() {\n                var leftPoint = this.editor.map.latLngToContainerPoint(this.left.latlng),\n                    rightPoint = this.editor.map.latLngToContainerPoint(this.right.latlng),\n                    y = (leftPoint.y + rightPoint.y) / 2,\n                    x = (leftPoint.x + rightPoint.x) / 2;\n                return this.editor.map.containerPointToLatLng([x, y]);\n            },\n\n            onAdd: function onAdd(map) {\n                L.Marker.prototype.onAdd.call(this, map);\n                L.DomEvent.on(this._icon, 'mousedown touchstart', this.onMouseDown, this);\n                map.on('zoomend', this.setVisibility, this);\n            },\n\n            onRemove: function onRemove(map) {\n                delete this.right.middleMarker;\n                L.DomEvent.off(this._icon, 'mousedown touchstart', this.onMouseDown, this);\n                map.off('zoomend', this.setVisibility, this);\n                L.Marker.prototype.onRemove.call(this, map);\n            },\n\n            onMouseDown: function onMouseDown(e) {\n                var iconPos = L.DomUtil.getPosition(this._icon),\n                    latlng = this.editor.map.layerPointToLatLng(iconPos);\n                e = {\n                    originalEvent: e,\n                    latlng: latlng\n                };\n                if (this.options.opacity === 0) return;\n                L.Editable.makeCancellable(e);\n                this.editor.onMiddleMarkerMouseDown(e);\n                if (e._cancelled) return;\n                this.latlngs.splice(this.index(), 0, e.latlng);\n                this.editor.refresh();\n                var icon = this._icon;\n                var marker = this.editor.addVertexMarker(e.latlng, this.latlngs);\n                this.editor.onNewVertex(marker);\n                /* Hack to workaround browser not firing touchend when element is no more on DOM */\n                var parent = marker._icon.parentNode;\n                parent.removeChild(marker._icon);\n                marker._icon = icon;\n                parent.appendChild(marker._icon);\n                marker._initIcon();\n                marker._initInteraction();\n                marker.setOpacity(1);\n                /* End hack */\n                // Transfer ongoing dragging to real marker\n                L.Draggable._dragging = false;\n                marker.dragging._draggable._onDown(e.originalEvent);\n                this.delete();\n            },\n\n            delete: function _delete() {\n                this.editor.editLayer.removeLayer(this);\n            },\n\n            index: function index() {\n                return this.latlngs.indexOf(this.right.latlng);\n            }\n\n        });\n\n        L.Editable.mergeOptions({\n\n            // 🍂namespace Editable\n            // 🍂option middleMarkerClass: class = VertexMarker\n            // Class to be used as middle vertex, pulled by the user to create a new point in the middle of a path.\n            middleMarkerClass: L.Editable.MiddleMarker\n\n        });\n\n        // 🍂namespace Editable; 🍂class BaseEditor; 🍂aka L.Editable.BaseEditor\n        // When editing a feature (Marker, Polyline…), an editor is attached to it. This\n        // editor basically knows how to handle the edition.\n        L.Editable.BaseEditor = L.Handler.extend({\n\n            initialize: function initialize(map, feature, options) {\n                L.setOptions(this, options);\n                this.map = map;\n                this.feature = feature;\n                this.feature.editor = this;\n                this.editLayer = new L.LayerGroup();\n                this.tools = this.options.editTools || map.editTools;\n            },\n\n            // 🍂method enable(): this\n            // Set up the drawing tools for the feature to be editable.\n            addHooks: function addHooks() {\n                if (this.isConnected()) this.onFeatureAdd();else this.feature.once('add', this.onFeatureAdd, this);\n                this.onEnable();\n                this.feature.on(this._getEvents(), this);\n            },\n\n            // 🍂method disable(): this\n            // Remove the drawing tools for the feature.\n            removeHooks: function removeHooks() {\n                this.feature.off(this._getEvents(), this);\n                if (this.feature.dragging) this.feature.dragging.disable();\n                this.editLayer.clearLayers();\n                this.tools.editLayer.removeLayer(this.editLayer);\n                this.onDisable();\n                if (this._drawing) this.cancelDrawing();\n            },\n\n            // 🍂method drawing(): boolean\n            // Return true if any drawing action is ongoing with this editor.\n            drawing: function drawing() {\n                return !!this._drawing;\n            },\n\n            reset: function reset() {},\n\n            onFeatureAdd: function onFeatureAdd() {\n                this.tools.editLayer.addLayer(this.editLayer);\n                if (this.feature.dragging) this.feature.dragging.enable();\n            },\n\n            hasMiddleMarkers: function hasMiddleMarkers() {\n                return !this.options.skipMiddleMarkers && !this.tools.options.skipMiddleMarkers;\n            },\n\n            fireAndForward: function fireAndForward(type, e) {\n                e = e || {};\n                e.layer = this.feature;\n                this.feature.fire(type, e);\n                this.tools.fireAndForward(type, e);\n            },\n\n            onEnable: function onEnable() {\n                // 🍂namespace Editable\n                // 🍂event editable:enable: Event\n                // Fired when an existing feature is ready to be edited.\n                this.fireAndForward('editable:enable');\n            },\n\n            onDisable: function onDisable() {\n                // 🍂namespace Editable\n                // 🍂event editable:disable: Event\n                // Fired when an existing feature is not ready anymore to be edited.\n                this.fireAndForward('editable:disable');\n            },\n\n            onEditing: function onEditing() {\n                // 🍂namespace Editable\n                // 🍂event editable:editing: Event\n                // Fired as soon as any change is made to the feature geometry.\n                this.fireAndForward('editable:editing');\n            },\n\n            onStartDrawing: function onStartDrawing() {\n                // 🍂namespace Editable\n                // 🍂section Drawing events\n                // 🍂event editable:drawing:start: Event\n                // Fired when a feature is to be drawn.\n                this.fireAndForward('editable:drawing:start');\n            },\n\n            onEndDrawing: function onEndDrawing() {\n                // 🍂namespace Editable\n                // 🍂section Drawing events\n                // 🍂event editable:drawing:end: Event\n                // Fired when a feature is not drawn anymore.\n                this.fireAndForward('editable:drawing:end');\n            },\n\n            onCancelDrawing: function onCancelDrawing() {\n                // 🍂namespace Editable\n                // 🍂section Drawing events\n                // 🍂event editable:drawing:cancel: Event\n                // Fired when user cancel drawing while a feature is being drawn.\n                this.fireAndForward('editable:drawing:cancel');\n            },\n\n            onCommitDrawing: function onCommitDrawing(e) {\n                // 🍂namespace Editable\n                // 🍂section Drawing events\n                // 🍂event editable:drawing:commit: Event\n                // Fired when user finish drawing a feature.\n                this.fireAndForward('editable:drawing:commit', e);\n            },\n\n            onDrawingMouseDown: function onDrawingMouseDown(e) {\n                // 🍂namespace Editable\n                // 🍂section Drawing events\n                // 🍂event editable:drawing:mousedown: Event\n                // Fired when user `mousedown` while drawing.\n                this.fireAndForward('editable:drawing:mousedown', e);\n            },\n\n            onDrawingMouseUp: function onDrawingMouseUp(e) {\n                // 🍂namespace Editable\n                // 🍂section Drawing events\n                // 🍂event editable:drawing:mouseup: Event\n                // Fired when user `mouseup` while drawing.\n                this.fireAndForward('editable:drawing:mouseup', e);\n            },\n\n            startDrawing: function startDrawing() {\n                if (!this._drawing) this._drawing = L.Editable.FORWARD;\n                this.tools.registerForDrawing(this);\n                this.onStartDrawing();\n            },\n\n            commitDrawing: function commitDrawing(e) {\n                this.onCommitDrawing(e);\n                this.endDrawing();\n            },\n\n            cancelDrawing: function cancelDrawing() {\n                // If called during a vertex drag, the vertex will be removed before\n                // the mouseup fires on it. This is a workaround. Maybe better fix is\n                // To have L.Draggable reset it's status on disable (Leaflet side).\n                L.Draggable._dragging = false;\n                this.onCancelDrawing();\n                this.endDrawing();\n            },\n\n            endDrawing: function endDrawing() {\n                this._drawing = false;\n                this.tools.unregisterForDrawing(this);\n                this.onEndDrawing();\n            },\n\n            onDrawingClick: function onDrawingClick(e) {\n                if (!this.drawing()) return;\n                L.Editable.makeCancellable(e);\n                // 🍂namespace Editable\n                // 🍂section Drawing events\n                // 🍂event editable:drawing:click: CancelableEvent\n                // Fired when user `click` while drawing, before any internal action is being processed.\n                this.fireAndForward('editable:drawing:click', e);\n                if (e._cancelled) return;\n                if (!this.isConnected()) this.connect(e);\n                this.processDrawingClick(e);\n            },\n\n            isConnected: function isConnected() {\n                return this.map.hasLayer(this.feature);\n            },\n\n            connect: function connect() {\n                this.tools.connectCreatedToMap(this.feature);\n                this.tools.editLayer.addLayer(this.editLayer);\n            },\n\n            onMove: function onMove(e) {\n                // 🍂namespace Editable\n                // 🍂section Drawing events\n                // 🍂event editable:drawing:move: Event\n                // Fired when `move` mouse while drawing, while dragging a marker, and while dragging a vertex.\n                this.fireAndForward('editable:drawing:move', e);\n            },\n\n            onDrawingMouseMove: function onDrawingMouseMove(e) {\n                this.onMove(e);\n            },\n\n            _getEvents: function _getEvents() {\n                return {\n                    dragstart: this.onDragStart,\n                    drag: this.onDrag,\n                    dragend: this.onDragEnd,\n                    remove: this.disable\n                };\n            },\n\n            onDragStart: function onDragStart(e) {\n                this.onEditing();\n                // 🍂namespace Editable\n                // 🍂event editable:dragstart: Event\n                // Fired before a path feature is dragged.\n                this.fireAndForward('editable:dragstart', e);\n            },\n\n            onDrag: function onDrag(e) {\n                this.onMove(e);\n                // 🍂namespace Editable\n                // 🍂event editable:drag: Event\n                // Fired when a path feature is being dragged.\n                this.fireAndForward('editable:drag', e);\n            },\n\n            onDragEnd: function onDragEnd(e) {\n                // 🍂namespace Editable\n                // 🍂event editable:dragend: Event\n                // Fired after a path feature has been dragged.\n                this.fireAndForward('editable:dragend', e);\n            }\n\n        });\n\n        // 🍂namespace Editable; 🍂class MarkerEditor; 🍂aka L.Editable.MarkerEditor\n        // 🍂inherits BaseEditor\n        // Editor for Marker.\n        L.Editable.MarkerEditor = L.Editable.BaseEditor.extend({\n\n            onDrawingMouseMove: function onDrawingMouseMove(e) {\n                L.Editable.BaseEditor.prototype.onDrawingMouseMove.call(this, e);\n                if (this._drawing) this.feature.setLatLng(e.latlng);\n            },\n\n            processDrawingClick: function processDrawingClick(e) {\n                // 🍂namespace Editable\n                // 🍂section Drawing events\n                // 🍂event editable:drawing:clicked: Event\n                // Fired when user `click` while drawing, after all internal actions.\n                this.fireAndForward('editable:drawing:clicked', e);\n                this.commitDrawing(e);\n            },\n\n            connect: function connect(e) {\n                // On touch, the latlng has not been updated because there is\n                // no mousemove.\n                if (e) this.feature._latlng = e.latlng;\n                L.Editable.BaseEditor.prototype.connect.call(this, e);\n            }\n\n        });\n\n        // 🍂namespace Editable; 🍂class PathEditor; 🍂aka L.Editable.PathEditor\n        // 🍂inherits BaseEditor\n        // Base class for all path editors.\n        L.Editable.PathEditor = L.Editable.BaseEditor.extend({\n\n            CLOSED: false,\n            MIN_VERTEX: 2,\n\n            addHooks: function addHooks() {\n                L.Editable.BaseEditor.prototype.addHooks.call(this);\n                if (this.feature) this.initVertexMarkers();\n                return this;\n            },\n\n            initVertexMarkers: function initVertexMarkers(latlngs) {\n                if (!this.enabled()) return;\n                latlngs = latlngs || this.getLatLngs();\n                if (isFlat(latlngs)) this.addVertexMarkers(latlngs);else for (var i = 0; i < latlngs.length; i++) {\n                    this.initVertexMarkers(latlngs[i]);\n                }\n            },\n\n            getLatLngs: function getLatLngs() {\n                return this.feature.getLatLngs();\n            },\n\n            // 🍂method reset()\n            // Rebuild edit elements (Vertex, MiddleMarker, etc.).\n            reset: function reset() {\n                this.editLayer.clearLayers();\n                this.initVertexMarkers();\n            },\n\n            addVertexMarker: function addVertexMarker(latlng, latlngs) {\n                return new this.tools.options.vertexMarkerClass(latlng, latlngs, this);\n            },\n\n            onNewVertex: function onNewVertex(vertex) {\n                // 🍂namespace Editable\n                // 🍂section Vertex events\n                // 🍂event editable:vertex:new: VertexEvent\n                // Fired when a new vertex is created.\n                this.fireAndForward('editable:vertex:new', { latlng: vertex.latlng, vertex: vertex });\n            },\n\n            addVertexMarkers: function addVertexMarkers(latlngs) {\n                for (var i = 0; i < latlngs.length; i++) {\n                    this.addVertexMarker(latlngs[i], latlngs);\n                }\n            },\n\n            refreshVertexMarkers: function refreshVertexMarkers(latlngs) {\n                latlngs = latlngs || this.getDefaultLatLngs();\n                for (var i = 0; i < latlngs.length; i++) {\n                    latlngs[i].__vertex.update();\n                }\n            },\n\n            addMiddleMarker: function addMiddleMarker(left, right, latlngs) {\n                return new this.tools.options.middleMarkerClass(left, right, latlngs, this);\n            },\n\n            onVertexMarkerClick: function onVertexMarkerClick(e) {\n                L.Editable.makeCancellable(e);\n                // 🍂namespace Editable\n                // 🍂section Vertex events\n                // 🍂event editable:vertex:click: CancelableVertexEvent\n                // Fired when a `click` is issued on a vertex, before any internal action is being processed.\n                this.fireAndForward('editable:vertex:click', e);\n                if (e._cancelled) return;\n                if (this.tools.drawing() && this.tools._drawingEditor !== this) return;\n                var index = e.vertex.getIndex(),\n                    commit;\n                if (e.originalEvent.ctrlKey) {\n                    this.onVertexMarkerCtrlClick(e);\n                } else if (e.originalEvent.altKey) {\n                    this.onVertexMarkerAltClick(e);\n                } else if (e.originalEvent.shiftKey) {\n                    this.onVertexMarkerShiftClick(e);\n                } else if (e.originalEvent.metaKey) {\n                    this.onVertexMarkerMetaKeyClick(e);\n                } else if (index === e.vertex.getLastIndex() && this._drawing === L.Editable.FORWARD) {\n                    if (index >= this.MIN_VERTEX - 1) commit = true;\n                } else if (index === 0 && this._drawing === L.Editable.BACKWARD && this._drawnLatLngs.length >= this.MIN_VERTEX) {\n                    commit = true;\n                } else if (index === 0 && this._drawing === L.Editable.FORWARD && this._drawnLatLngs.length >= this.MIN_VERTEX && this.CLOSED) {\n                    commit = true; // Allow to close on first point also for polygons\n                } else {\n                    this.onVertexRawMarkerClick(e);\n                }\n                // 🍂namespace Editable\n                // 🍂section Vertex events\n                // 🍂event editable:vertex:clicked: VertexEvent\n                // Fired when a `click` is issued on a vertex, after all internal actions.\n                this.fireAndForward('editable:vertex:clicked', e);\n                if (commit) this.commitDrawing(e);\n            },\n\n            onVertexRawMarkerClick: function onVertexRawMarkerClick(e) {\n                // 🍂namespace Editable\n                // 🍂section Vertex events\n                // 🍂event editable:vertex:rawclick: CancelableVertexEvent\n                // Fired when a `click` is issued on a vertex without any special key and without being in drawing mode.\n                this.fireAndForward('editable:vertex:rawclick', e);\n                if (e._cancelled) return;\n                if (!this.vertexCanBeDeleted(e.vertex)) return;\n                e.vertex.delete();\n            },\n\n            vertexCanBeDeleted: function vertexCanBeDeleted(vertex) {\n                return vertex.latlngs.length > this.MIN_VERTEX;\n            },\n\n            onVertexDeleted: function onVertexDeleted(e) {\n                // 🍂namespace Editable\n                // 🍂section Vertex events\n                // 🍂event editable:vertex:deleted: VertexEvent\n                // Fired after a vertex has been deleted by user.\n                this.fireAndForward('editable:vertex:deleted', e);\n            },\n\n            onVertexMarkerCtrlClick: function onVertexMarkerCtrlClick(e) {\n                // 🍂namespace Editable\n                // 🍂section Vertex events\n                // 🍂event editable:vertex:ctrlclick: VertexEvent\n                // Fired when a `click` with `ctrlKey` is issued on a vertex.\n                this.fireAndForward('editable:vertex:ctrlclick', e);\n            },\n\n            onVertexMarkerShiftClick: function onVertexMarkerShiftClick(e) {\n                // 🍂namespace Editable\n                // 🍂section Vertex events\n                // 🍂event editable:vertex:shiftclick: VertexEvent\n                // Fired when a `click` with `shiftKey` is issued on a vertex.\n                this.fireAndForward('editable:vertex:shiftclick', e);\n            },\n\n            onVertexMarkerMetaKeyClick: function onVertexMarkerMetaKeyClick(e) {\n                // 🍂namespace Editable\n                // 🍂section Vertex events\n                // 🍂event editable:vertex:metakeyclick: VertexEvent\n                // Fired when a `click` with `metaKey` is issued on a vertex.\n                this.fireAndForward('editable:vertex:metakeyclick', e);\n            },\n\n            onVertexMarkerAltClick: function onVertexMarkerAltClick(e) {\n                // 🍂namespace Editable\n                // 🍂section Vertex events\n                // 🍂event editable:vertex:altclick: VertexEvent\n                // Fired when a `click` with `altKey` is issued on a vertex.\n                this.fireAndForward('editable:vertex:altclick', e);\n            },\n\n            onVertexMarkerContextMenu: function onVertexMarkerContextMenu(e) {\n                // 🍂namespace Editable\n                // 🍂section Vertex events\n                // 🍂event editable:vertex:contextmenu: VertexEvent\n                // Fired when a `contextmenu` is issued on a vertex.\n                this.fireAndForward('editable:vertex:contextmenu', e);\n            },\n\n            onVertexMarkerMouseDown: function onVertexMarkerMouseDown(e) {\n                // 🍂namespace Editable\n                // 🍂section Vertex events\n                // 🍂event editable:vertex:mousedown: VertexEvent\n                // Fired when user `mousedown` a vertex.\n                this.fireAndForward('editable:vertex:mousedown', e);\n            },\n\n            onVertexMarkerMouseOver: function onVertexMarkerMouseOver(e) {\n                // 🍂namespace Editable\n                // 🍂section Vertex events\n                // 🍂event editable:vertex:mouseover: VertexEvent\n                // Fired when a user's mouse enters the vertex\n                this.fireAndForward('editable:vertex:mouseover', e);\n            },\n\n            onVertexMarkerMouseOut: function onVertexMarkerMouseOut(e) {\n                // 🍂namespace Editable\n                // 🍂section Vertex events\n                // 🍂event editable:vertex:mouseout: VertexEvent\n                // Fired when a user's mouse leaves the vertex\n                this.fireAndForward('editable:vertex:mouseout', e);\n            },\n\n            onMiddleMarkerMouseDown: function onMiddleMarkerMouseDown(e) {\n                // 🍂namespace Editable\n                // 🍂section MiddleMarker events\n                // 🍂event editable:middlemarker:mousedown: VertexEvent\n                // Fired when user `mousedown` a middle marker.\n                this.fireAndForward('editable:middlemarker:mousedown', e);\n            },\n\n            onVertexMarkerDrag: function onVertexMarkerDrag(e) {\n                this.onMove(e);\n                if (this.feature._bounds) this.extendBounds(e);\n                // 🍂namespace Editable\n                // 🍂section Vertex events\n                // 🍂event editable:vertex:drag: VertexEvent\n                // Fired when a vertex is dragged by user.\n                this.fireAndForward('editable:vertex:drag', e);\n            },\n\n            onVertexMarkerDragStart: function onVertexMarkerDragStart(e) {\n                // 🍂namespace Editable\n                // 🍂section Vertex events\n                // 🍂event editable:vertex:dragstart: VertexEvent\n                // Fired before a vertex is dragged by user.\n                this.fireAndForward('editable:vertex:dragstart', e);\n            },\n\n            onVertexMarkerDragEnd: function onVertexMarkerDragEnd(e) {\n                // 🍂namespace Editable\n                // 🍂section Vertex events\n                // 🍂event editable:vertex:dragend: VertexEvent\n                // Fired after a vertex is dragged by user.\n                this.fireAndForward('editable:vertex:dragend', e);\n            },\n\n            setDrawnLatLngs: function setDrawnLatLngs(latlngs) {\n                this._drawnLatLngs = latlngs || this.getDefaultLatLngs();\n            },\n\n            startDrawing: function startDrawing() {\n                if (!this._drawnLatLngs) this.setDrawnLatLngs();\n                L.Editable.BaseEditor.prototype.startDrawing.call(this);\n            },\n\n            startDrawingForward: function startDrawingForward() {\n                this.startDrawing();\n            },\n\n            endDrawing: function endDrawing() {\n                this.tools.detachForwardLineGuide();\n                this.tools.detachBackwardLineGuide();\n                if (this._drawnLatLngs && this._drawnLatLngs.length < this.MIN_VERTEX) this.deleteShape(this._drawnLatLngs);\n                L.Editable.BaseEditor.prototype.endDrawing.call(this);\n                delete this._drawnLatLngs;\n            },\n\n            addLatLng: function addLatLng(latlng) {\n                if (this._drawing === L.Editable.FORWARD) this._drawnLatLngs.push(latlng);else this._drawnLatLngs.unshift(latlng);\n                this.feature._bounds.extend(latlng);\n                var vertex = this.addVertexMarker(latlng, this._drawnLatLngs);\n                this.onNewVertex(vertex);\n                this.refresh();\n            },\n\n            newPointForward: function newPointForward(latlng) {\n                this.addLatLng(latlng);\n                this.tools.attachForwardLineGuide();\n                this.tools.anchorForwardLineGuide(latlng);\n            },\n\n            newPointBackward: function newPointBackward(latlng) {\n                this.addLatLng(latlng);\n                this.tools.anchorBackwardLineGuide(latlng);\n            },\n\n            // 🍂namespace PathEditor\n            // 🍂method push()\n            // Programmatically add a point while drawing.\n            push: function push(latlng) {\n                if (!latlng) return console.error('L.Editable.PathEditor.push expect a valid latlng as parameter');\n                if (this._drawing === L.Editable.FORWARD) this.newPointForward(latlng);else this.newPointBackward(latlng);\n            },\n\n            removeLatLng: function removeLatLng(latlng) {\n                latlng.__vertex.delete();\n                this.refresh();\n            },\n\n            // 🍂method pop(): L.LatLng or null\n            // Programmatically remove last point (if any) while drawing.\n            pop: function pop() {\n                if (this._drawnLatLngs.length <= 1) return;\n                var latlng;\n                if (this._drawing === L.Editable.FORWARD) latlng = this._drawnLatLngs[this._drawnLatLngs.length - 1];else latlng = this._drawnLatLngs[0];\n                this.removeLatLng(latlng);\n                if (this._drawing === L.Editable.FORWARD) this.tools.anchorForwardLineGuide(this._drawnLatLngs[this._drawnLatLngs.length - 1]);else this.tools.anchorForwardLineGuide(this._drawnLatLngs[0]);\n                return latlng;\n            },\n\n            processDrawingClick: function processDrawingClick(e) {\n                if (e.vertex && e.vertex.editor === this) return;\n                if (this._drawing === L.Editable.FORWARD) this.newPointForward(e.latlng);else this.newPointBackward(e.latlng);\n                this.fireAndForward('editable:drawing:clicked', e);\n            },\n\n            onDrawingMouseMove: function onDrawingMouseMove(e) {\n                L.Editable.BaseEditor.prototype.onDrawingMouseMove.call(this, e);\n                if (this._drawing) {\n                    this.tools.moveForwardLineGuide(e.latlng);\n                    this.tools.moveBackwardLineGuide(e.latlng);\n                }\n            },\n\n            refresh: function refresh() {\n                this.feature.redraw();\n                this.onEditing();\n            },\n\n            // 🍂namespace PathEditor\n            // 🍂method newShape(latlng?: L.LatLng)\n            // Add a new shape (Polyline, Polygon) in a multi, and setup up drawing tools to draw it;\n            // if optional `latlng` is given, start a path at this point.\n            newShape: function newShape(latlng) {\n                var shape = this.addNewEmptyShape();\n                if (!shape) return;\n                this.setDrawnLatLngs(shape[0] || shape); // Polygon or polyline\n                this.startDrawingForward();\n                // 🍂namespace Editable\n                // 🍂section Shape events\n                // 🍂event editable:shape:new: ShapeEvent\n                // Fired when a new shape is created in a multi (Polygon or Polyline).\n                this.fireAndForward('editable:shape:new', { shape: shape });\n                if (latlng) this.newPointForward(latlng);\n            },\n\n            deleteShape: function deleteShape(shape, latlngs) {\n                var e = { shape: shape };\n                L.Editable.makeCancellable(e);\n                // 🍂namespace Editable\n                // 🍂section Shape events\n                // 🍂event editable:shape:delete: CancelableShapeEvent\n                // Fired before a new shape is deleted in a multi (Polygon or Polyline).\n                this.fireAndForward('editable:shape:delete', e);\n                if (e._cancelled) return;\n                shape = this._deleteShape(shape, latlngs);\n                if (this.ensureNotFlat) this.ensureNotFlat(); // Polygon.\n                this.feature.setLatLngs(this.getLatLngs()); // Force bounds reset.\n                this.refresh();\n                this.reset();\n                // 🍂namespace Editable\n                // 🍂section Shape events\n                // 🍂event editable:shape:deleted: ShapeEvent\n                // Fired after a new shape is deleted in a multi (Polygon or Polyline).\n                this.fireAndForward('editable:shape:deleted', { shape: shape });\n                return shape;\n            },\n\n            _deleteShape: function _deleteShape(shape, latlngs) {\n                latlngs = latlngs || this.getLatLngs();\n                if (!latlngs.length) return;\n                var self = this,\n                    inplaceDelete = function inplaceDelete(latlngs, shape) {\n                    // Called when deleting a flat latlngs\n                    shape = latlngs.splice(0, Number.MAX_VALUE);\n                    return shape;\n                },\n                    spliceDelete = function spliceDelete(latlngs, shape) {\n                    // Called when removing a latlngs inside an array\n                    latlngs.splice(latlngs.indexOf(shape), 1);\n                    if (!latlngs.length) self._deleteShape(latlngs);\n                    return shape;\n                };\n                if (latlngs === shape) return inplaceDelete(latlngs, shape);\n                for (var i = 0; i < latlngs.length; i++) {\n                    if (latlngs[i] === shape) return spliceDelete(latlngs, shape);else if (latlngs[i].indexOf(shape) !== -1) return spliceDelete(latlngs[i], shape);\n                }\n            },\n\n            // 🍂namespace PathEditor\n            // 🍂method deleteShapeAt(latlng: L.LatLng): Array\n            // Remove a path shape at the given `latlng`.\n            deleteShapeAt: function deleteShapeAt(latlng) {\n                var shape = this.feature.shapeAt(latlng);\n                if (shape) return this.deleteShape(shape);\n            },\n\n            // 🍂method appendShape(shape: Array)\n            // Append a new shape to the Polygon or Polyline.\n            appendShape: function appendShape(shape) {\n                this.insertShape(shape);\n            },\n\n            // 🍂method prependShape(shape: Array)\n            // Prepend a new shape to the Polygon or Polyline.\n            prependShape: function prependShape(shape) {\n                this.insertShape(shape, 0);\n            },\n\n            // 🍂method insertShape(shape: Array, index: int)\n            // Insert a new shape to the Polygon or Polyline at given index (default is to append).\n            insertShape: function insertShape(shape, index) {\n                this.ensureMulti();\n                shape = this.formatShape(shape);\n                if (typeof index === 'undefined') index = this.feature._latlngs.length;\n                this.feature._latlngs.splice(index, 0, shape);\n                this.feature.redraw();\n                if (this._enabled) this.reset();\n            },\n\n            extendBounds: function extendBounds(e) {\n                this.feature._bounds.extend(e.vertex.latlng);\n            },\n\n            onDragStart: function onDragStart(e) {\n                this.editLayer.clearLayers();\n                L.Editable.BaseEditor.prototype.onDragStart.call(this, e);\n            },\n\n            onDragEnd: function onDragEnd(e) {\n                this.initVertexMarkers();\n                L.Editable.BaseEditor.prototype.onDragEnd.call(this, e);\n            }\n\n        });\n\n        // 🍂namespace Editable; 🍂class PolylineEditor; 🍂aka L.Editable.PolylineEditor\n        // 🍂inherits PathEditor\n        L.Editable.PolylineEditor = L.Editable.PathEditor.extend({\n\n            startDrawingBackward: function startDrawingBackward() {\n                this._drawing = L.Editable.BACKWARD;\n                this.startDrawing();\n            },\n\n            // 🍂method continueBackward(latlngs?: Array)\n            // Set up drawing tools to continue the line backward.\n            continueBackward: function continueBackward(latlngs) {\n                if (this.drawing()) return;\n                latlngs = latlngs || this.getDefaultLatLngs();\n                this.setDrawnLatLngs(latlngs);\n                if (latlngs.length > 0) {\n                    this.tools.attachBackwardLineGuide();\n                    this.tools.anchorBackwardLineGuide(latlngs[0]);\n                }\n                this.startDrawingBackward();\n            },\n\n            // 🍂method continueForward(latlngs?: Array)\n            // Set up drawing tools to continue the line forward.\n            continueForward: function continueForward(latlngs) {\n                if (this.drawing()) return;\n                latlngs = latlngs || this.getDefaultLatLngs();\n                this.setDrawnLatLngs(latlngs);\n                if (latlngs.length > 0) {\n                    this.tools.attachForwardLineGuide();\n                    this.tools.anchorForwardLineGuide(latlngs[latlngs.length - 1]);\n                }\n                this.startDrawingForward();\n            },\n\n            getDefaultLatLngs: function getDefaultLatLngs(latlngs) {\n                latlngs = latlngs || this.feature._latlngs;\n                if (!latlngs.length || latlngs[0] instanceof L.LatLng) return latlngs;else return this.getDefaultLatLngs(latlngs[0]);\n            },\n\n            ensureMulti: function ensureMulti() {\n                if (this.feature._latlngs.length && isFlat(this.feature._latlngs)) {\n                    this.feature._latlngs = [this.feature._latlngs];\n                }\n            },\n\n            addNewEmptyShape: function addNewEmptyShape() {\n                if (this.feature._latlngs.length) {\n                    var shape = [];\n                    this.appendShape(shape);\n                    return shape;\n                } else {\n                    return this.feature._latlngs;\n                }\n            },\n\n            formatShape: function formatShape(shape) {\n                if (isFlat(shape)) return shape;else if (shape[0]) return this.formatShape(shape[0]);\n            },\n\n            // 🍂method splitShape(latlngs?: Array, index: int)\n            // Split the given `latlngs` shape at index `index` and integrate new shape in instance `latlngs`.\n            splitShape: function splitShape(shape, index) {\n                if (!index || index >= shape.length - 1) return;\n                this.ensureMulti();\n                var shapeIndex = this.feature._latlngs.indexOf(shape);\n                if (shapeIndex === -1) return;\n                var first = shape.slice(0, index + 1),\n                    second = shape.slice(index);\n                // We deal with reference, we don't want twice the same latlng around.\n                second[0] = L.latLng(second[0].lat, second[0].lng, second[0].alt);\n                this.feature._latlngs.splice(shapeIndex, 1, first, second);\n                this.refresh();\n                this.reset();\n            }\n\n        });\n\n        // 🍂namespace Editable; 🍂class PolygonEditor; 🍂aka L.Editable.PolygonEditor\n        // 🍂inherits PathEditor\n        L.Editable.PolygonEditor = L.Editable.PathEditor.extend({\n\n            CLOSED: true,\n            MIN_VERTEX: 3,\n\n            newPointForward: function newPointForward(latlng) {\n                L.Editable.PathEditor.prototype.newPointForward.call(this, latlng);\n                if (!this.tools.backwardLineGuide._latlngs.length) this.tools.anchorBackwardLineGuide(latlng);\n                if (this._drawnLatLngs.length === 2) this.tools.attachBackwardLineGuide();\n            },\n\n            addNewEmptyHole: function addNewEmptyHole(latlng) {\n                this.ensureNotFlat();\n                var latlngs = this.feature.shapeAt(latlng);\n                if (!latlngs) return;\n                var holes = [];\n                latlngs.push(holes);\n                return holes;\n            },\n\n            // 🍂method newHole(latlng?: L.LatLng, index: int)\n            // Set up drawing tools for creating a new hole on the Polygon. If the `latlng` param is given, a first point is created.\n            newHole: function newHole(latlng) {\n                var holes = this.addNewEmptyHole(latlng);\n                if (!holes) return;\n                this.setDrawnLatLngs(holes);\n                this.startDrawingForward();\n                if (latlng) this.newPointForward(latlng);\n            },\n\n            addNewEmptyShape: function addNewEmptyShape() {\n                if (this.feature._latlngs.length && this.feature._latlngs[0].length) {\n                    var shape = [];\n                    this.appendShape(shape);\n                    return shape;\n                } else {\n                    return this.feature._latlngs;\n                }\n            },\n\n            ensureMulti: function ensureMulti() {\n                if (this.feature._latlngs.length && isFlat(this.feature._latlngs[0])) {\n                    this.feature._latlngs = [this.feature._latlngs];\n                }\n            },\n\n            ensureNotFlat: function ensureNotFlat() {\n                if (!this.feature._latlngs.length || isFlat(this.feature._latlngs)) this.feature._latlngs = [this.feature._latlngs];\n            },\n\n            vertexCanBeDeleted: function vertexCanBeDeleted(vertex) {\n                var parent = this.feature.parentShape(vertex.latlngs),\n                    idx = L.Util.indexOf(parent, vertex.latlngs);\n                if (idx > 0) return true; // Holes can be totally deleted without removing the layer itself.\n                return L.Editable.PathEditor.prototype.vertexCanBeDeleted.call(this, vertex);\n            },\n\n            getDefaultLatLngs: function getDefaultLatLngs() {\n                if (!this.feature._latlngs.length) this.feature._latlngs.push([]);\n                return this.feature._latlngs[0];\n            },\n\n            formatShape: function formatShape(shape) {\n                // [[1, 2], [3, 4]] => must be nested\n                // [] => must be nested\n                // [[]] => is already nested\n                if (isFlat(shape) && (!shape[0] || shape[0].length !== 0)) return [shape];else return shape;\n            }\n\n        });\n\n        // 🍂namespace Editable; 🍂class RectangleEditor; 🍂aka L.Editable.RectangleEditor\n        // 🍂inherits PathEditor\n        L.Editable.RectangleEditor = L.Editable.PathEditor.extend({\n\n            CLOSED: true,\n            MIN_VERTEX: 4,\n\n            options: {\n                skipMiddleMarkers: true\n            },\n\n            extendBounds: function extendBounds(e) {\n                var index = e.vertex.getIndex(),\n                    next = e.vertex.getNext(),\n                    previous = e.vertex.getPrevious(),\n                    oppositeIndex = (index + 2) % 4,\n                    opposite = e.vertex.latlngs[oppositeIndex],\n                    bounds = new L.LatLngBounds(e.latlng, opposite);\n                // Update latlngs by hand to preserve order.\n                previous.latlng.update([e.latlng.lat, opposite.lng]);\n                next.latlng.update([opposite.lat, e.latlng.lng]);\n                this.updateBounds(bounds);\n                this.refreshVertexMarkers();\n            },\n\n            onDrawingMouseDown: function onDrawingMouseDown(e) {\n                L.Editable.PathEditor.prototype.onDrawingMouseDown.call(this, e);\n                this.connect();\n                var latlngs = this.getDefaultLatLngs();\n                // L.Polygon._convertLatLngs removes last latlng if it equals first point,\n                // which is the case here as all latlngs are [0, 0]\n                if (latlngs.length === 3) latlngs.push(e.latlng);\n                var bounds = new L.LatLngBounds(e.latlng, e.latlng);\n                this.updateBounds(bounds);\n                this.updateLatLngs(bounds);\n                this.refresh();\n                this.reset();\n                // Stop dragging map.\n                // L.Draggable has two workflows:\n                // - mousedown => mousemove => mouseup\n                // - touchstart => touchmove => touchend\n                // Problem: L.Map.Tap does not allow us to listen to touchstart, so we only\n                // can deal with mousedown, but then when in a touch device, we are dealing with\n                // simulated events (actually simulated by L.Map.Tap), which are no more taken\n                // into account by L.Draggable.\n                // Ref.: https://github.com/Leaflet/Leaflet.Editable/issues/103\n                e.originalEvent._simulated = false;\n                this.map.dragging._draggable._onUp(e.originalEvent);\n                // Now transfer ongoing drag action to the bottom right corner.\n                // Should we refine which corner will handle the drag according to\n                // drag direction?\n                latlngs[3].__vertex.dragging._draggable._onDown(e.originalEvent);\n            },\n\n            onDrawingMouseUp: function onDrawingMouseUp(e) {\n                this.commitDrawing(e);\n                e.originalEvent._simulated = false;\n                L.Editable.PathEditor.prototype.onDrawingMouseUp.call(this, e);\n            },\n\n            onDrawingMouseMove: function onDrawingMouseMove(e) {\n                e.originalEvent._simulated = false;\n                L.Editable.PathEditor.prototype.onDrawingMouseMove.call(this, e);\n            },\n\n            getDefaultLatLngs: function getDefaultLatLngs(latlngs) {\n                return latlngs || this.feature._latlngs[0];\n            },\n\n            updateBounds: function updateBounds(bounds) {\n                this.feature._bounds = bounds;\n            },\n\n            updateLatLngs: function updateLatLngs(bounds) {\n                var latlngs = this.getDefaultLatLngs(),\n                    newLatlngs = this.feature._boundsToLatLngs(bounds);\n                // Keep references.\n                for (var i = 0; i < latlngs.length; i++) {\n                    latlngs[i].update(newLatlngs[i]);\n                }\n            }\n\n        });\n\n        // 🍂namespace Editable; 🍂class CircleEditor; 🍂aka L.Editable.CircleEditor\n        // 🍂inherits PathEditor\n        L.Editable.CircleEditor = L.Editable.PathEditor.extend({\n\n            MIN_VERTEX: 2,\n\n            options: {\n                skipMiddleMarkers: true\n            },\n\n            initialize: function initialize(map, feature, options) {\n                L.Editable.PathEditor.prototype.initialize.call(this, map, feature, options);\n                this._resizeLatLng = this.computeResizeLatLng();\n            },\n\n            computeResizeLatLng: function computeResizeLatLng() {\n                // While circle is not added to the map, _radius is not set.\n                var delta = (this.feature._radius || this.feature._mRadius) * Math.cos(Math.PI / 4),\n                    point = this.map.project(this.feature._latlng);\n                return this.map.unproject([point.x + delta, point.y - delta]);\n            },\n\n            updateResizeLatLng: function updateResizeLatLng() {\n                this._resizeLatLng.update(this.computeResizeLatLng());\n                this._resizeLatLng.__vertex.update();\n            },\n\n            getLatLngs: function getLatLngs() {\n                return [this.feature._latlng, this._resizeLatLng];\n            },\n\n            getDefaultLatLngs: function getDefaultLatLngs() {\n                return this.getLatLngs();\n            },\n\n            onVertexMarkerDrag: function onVertexMarkerDrag(e) {\n                if (e.vertex.getIndex() === 1) this.resize(e);else this.updateResizeLatLng(e);\n                L.Editable.PathEditor.prototype.onVertexMarkerDrag.call(this, e);\n            },\n\n            resize: function resize(e) {\n                var radius = this.feature._latlng.distanceTo(e.latlng);\n                this.feature.setRadius(radius);\n            },\n\n            onDrawingMouseDown: function onDrawingMouseDown(e) {\n                L.Editable.PathEditor.prototype.onDrawingMouseDown.call(this, e);\n                this._resizeLatLng.update(e.latlng);\n                this.feature._latlng.update(e.latlng);\n                this.connect();\n                // Stop dragging map.\n                e.originalEvent._simulated = false;\n                this.map.dragging._draggable._onUp(e.originalEvent);\n                // Now transfer ongoing drag action to the radius handler.\n                this._resizeLatLng.__vertex.dragging._draggable._onDown(e.originalEvent);\n            },\n\n            onDrawingMouseUp: function onDrawingMouseUp(e) {\n                this.commitDrawing(e);\n                e.originalEvent._simulated = false;\n                L.Editable.PathEditor.prototype.onDrawingMouseUp.call(this, e);\n            },\n\n            onDrawingMouseMove: function onDrawingMouseMove(e) {\n                e.originalEvent._simulated = false;\n                L.Editable.PathEditor.prototype.onDrawingMouseMove.call(this, e);\n            },\n\n            onDrag: function onDrag(e) {\n                L.Editable.PathEditor.prototype.onDrag.call(this, e);\n                this.feature.dragging.updateLatLng(this._resizeLatLng);\n            }\n\n        });\n\n        // 🍂namespace Editable; 🍂class EditableMixin\n        // `EditableMixin` is included to `L.Polyline`, `L.Polygon`, `L.Rectangle`, `L.Circle`\n        // and `L.Marker`. It adds some methods to them.\n        // *When editing is enabled, the editor is accessible on the instance with the\n        // `editor` property.*\n        var EditableMixin = {\n\n            createEditor: function createEditor(map) {\n                map = map || this._map;\n                var tools = (this.options.editOptions || {}).editTools || map.editTools;\n                if (!tools) throw Error('Unable to detect Editable instance.');\n                var Klass = this.options.editorClass || this.getEditorClass(tools);\n                return new Klass(map, this, this.options.editOptions);\n            },\n\n            // 🍂method enableEdit(map?: L.Map): this.editor\n            // Enable editing, by creating an editor if not existing, and then calling `enable` on it.\n            enableEdit: function enableEdit(map) {\n                if (!this.editor) this.createEditor(map);\n                this.editor.enable();\n                return this.editor;\n            },\n\n            // 🍂method editEnabled(): boolean\n            // Return true if current instance has an editor attached, and this editor is enabled.\n            editEnabled: function editEnabled() {\n                return this.editor && this.editor.enabled();\n            },\n\n            // 🍂method disableEdit()\n            // Disable editing, also remove the editor property reference.\n            disableEdit: function disableEdit() {\n                if (this.editor) {\n                    this.editor.disable();\n                    delete this.editor;\n                }\n            },\n\n            // 🍂method toggleEdit()\n            // Enable or disable editing, according to current status.\n            toggleEdit: function toggleEdit() {\n                if (this.editEnabled()) this.disableEdit();else this.enableEdit();\n            },\n\n            _onEditableAdd: function _onEditableAdd() {\n                if (this.editor) this.enableEdit();\n            }\n\n        };\n\n        var PolylineMixin = {\n\n            getEditorClass: function getEditorClass(tools) {\n                return tools && tools.options.polylineEditorClass ? tools.options.polylineEditorClass : L.Editable.PolylineEditor;\n            },\n\n            shapeAt: function shapeAt(latlng, latlngs) {\n                // We can have those cases:\n                // - latlngs are just a flat array of latlngs, use this\n                // - latlngs is an array of arrays of latlngs, loop over\n                var shape = null;\n                latlngs = latlngs || this._latlngs;\n                if (!latlngs.length) return shape;else if (isFlat(latlngs) && this.isInLatLngs(latlng, latlngs)) shape = latlngs;else for (var i = 0; i < latlngs.length; i++) {\n                    if (this.isInLatLngs(latlng, latlngs[i])) return latlngs[i];\n                }return shape;\n            },\n\n            isInLatLngs: function isInLatLngs(l, latlngs) {\n                if (!latlngs) return false;\n                var i,\n                    k,\n                    len,\n                    part = [],\n                    p,\n                    w = this._clickTolerance();\n                this._projectLatlngs(latlngs, part, this._pxBounds);\n                part = part[0];\n                p = this._map.latLngToLayerPoint(l);\n\n                if (!this._pxBounds.contains(p)) {\n                    return false;\n                }\n                for (i = 1, len = part.length, k = 0; i < len; k = i++) {\n\n                    if (L.LineUtil.pointToSegmentDistance(p, part[k], part[i]) <= w) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n\n        };\n\n        var PolygonMixin = {\n\n            getEditorClass: function getEditorClass(tools) {\n                return tools && tools.options.polygonEditorClass ? tools.options.polygonEditorClass : L.Editable.PolygonEditor;\n            },\n\n            shapeAt: function shapeAt(latlng, latlngs) {\n                // We can have those cases:\n                // - latlngs are just a flat array of latlngs, use this\n                // - latlngs is an array of arrays of latlngs, this is a simple polygon (maybe with holes), use the first\n                // - latlngs is an array of arrays of arrays, this is a multi, loop over\n                var shape = null;\n                latlngs = latlngs || this._latlngs;\n                if (!latlngs.length) return shape;else if (isFlat(latlngs) && this.isInLatLngs(latlng, latlngs)) shape = latlngs;else if (isFlat(latlngs[0]) && this.isInLatLngs(latlng, latlngs[0])) shape = latlngs;else for (var i = 0; i < latlngs.length; i++) {\n                    if (this.isInLatLngs(latlng, latlngs[i][0])) return latlngs[i];\n                }return shape;\n            },\n\n            isInLatLngs: function isInLatLngs(l, latlngs) {\n                var inside = false,\n                    l1,\n                    l2,\n                    j,\n                    k,\n                    len2;\n\n                for (j = 0, len2 = latlngs.length, k = len2 - 1; j < len2; k = j++) {\n                    l1 = latlngs[j];\n                    l2 = latlngs[k];\n\n                    if (l1.lat > l.lat !== l2.lat > l.lat && l.lng < (l2.lng - l1.lng) * (l.lat - l1.lat) / (l2.lat - l1.lat) + l1.lng) {\n                        inside = !inside;\n                    }\n                }\n\n                return inside;\n            },\n\n            parentShape: function parentShape(shape, latlngs) {\n                latlngs = latlngs || this._latlngs;\n                if (!latlngs) return;\n                var idx = L.Util.indexOf(latlngs, shape);\n                if (idx !== -1) return latlngs;\n                for (var i = 0; i < latlngs.length; i++) {\n                    idx = L.Util.indexOf(latlngs[i], shape);\n                    if (idx !== -1) return latlngs[i];\n                }\n            }\n\n        };\n\n        var MarkerMixin = {\n\n            getEditorClass: function getEditorClass(tools) {\n                return tools && tools.options.markerEditorClass ? tools.options.markerEditorClass : L.Editable.MarkerEditor;\n            }\n\n        };\n\n        var RectangleMixin = {\n\n            getEditorClass: function getEditorClass(tools) {\n                return tools && tools.options.rectangleEditorClass ? tools.options.rectangleEditorClass : L.Editable.RectangleEditor;\n            }\n\n        };\n\n        var CircleMixin = {\n\n            getEditorClass: function getEditorClass(tools) {\n                return tools && tools.options.circleEditorClass ? tools.options.circleEditorClass : L.Editable.CircleEditor;\n            }\n\n        };\n\n        var keepEditable = function keepEditable() {\n            // Make sure you can remove/readd an editable layer.\n            this.on('add', this._onEditableAdd);\n        };\n\n        var isFlat = L.LineUtil.isFlat || L.LineUtil._flat || L.Polyline._flat; // <=> 1.1 compat.\n\n\n        if (L.Polyline) {\n            L.Polyline.include(EditableMixin);\n            L.Polyline.include(PolylineMixin);\n            L.Polyline.addInitHook(keepEditable);\n        }\n        if (L.Polygon) {\n            L.Polygon.include(EditableMixin);\n            L.Polygon.include(PolygonMixin);\n        }\n        if (L.Marker) {\n            L.Marker.include(EditableMixin);\n            L.Marker.include(MarkerMixin);\n            L.Marker.addInitHook(keepEditable);\n        }\n        if (L.Rectangle) {\n            L.Rectangle.include(EditableMixin);\n            L.Rectangle.include(RectangleMixin);\n        }\n        if (L.Circle) {\n            L.Circle.include(EditableMixin);\n            L.Circle.include(CircleMixin);\n        }\n\n        L.LatLng.prototype.update = function (latlng) {\n            latlng = L.latLng(latlng);\n            this.lat = latlng.lat;\n            this.lng = latlng.lng;\n        };\n    }\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlZ1ZTJMZWFmbGV0RWRpdGFibGVQbHVnaW4uanMiXSwibmFtZXMiOlsiaW5zdGFsbCIsImluaXQiLCJ3aW5kb3ciLCJMIiwiRWRpdGFibGUiLCJFdmVudGVkIiwiZXh0ZW5kIiwic3RhdGljcyIsIkZPUldBUkQiLCJCQUNLV0FSRCIsIm9wdGlvbnMiLCJ6SW5kZXgiLCJwb2x5Z29uQ2xhc3MiLCJQb2x5Z29uIiwicG9seWxpbmVDbGFzcyIsIlBvbHlsaW5lIiwibWFya2VyQ2xhc3MiLCJNYXJrZXIiLCJyZWN0YW5nbGVDbGFzcyIsIlJlY3RhbmdsZSIsImNpcmNsZUNsYXNzIiwiQ2lyY2xlIiwiZHJhd2luZ0NTU0NsYXNzIiwiZHJhd2luZ0N1cnNvciIsImVkaXRMYXllciIsInVuZGVmaW5lZCIsImZlYXR1cmVzTGF5ZXIiLCJwb2x5bGluZUVkaXRvckNsYXNzIiwicG9seWdvbkVkaXRvckNsYXNzIiwibWFya2VyRWRpdG9yQ2xhc3MiLCJyZWN0YW5nbGVFZGl0b3JDbGFzcyIsImNpcmNsZUVkaXRvckNsYXNzIiwibGluZUd1aWRlT3B0aW9ucyIsInNraXBNaWRkbGVNYXJrZXJzIiwiaW5pdGlhbGl6ZSIsIm1hcCIsInNldE9wdGlvbnMiLCJfbGFzdFpJbmRleCIsImNyZWF0ZUVkaXRMYXllciIsImNyZWF0ZUZlYXR1cmVzTGF5ZXIiLCJmb3J3YXJkTGluZUd1aWRlIiwiY3JlYXRlTGluZUd1aWRlIiwiYmFja3dhcmRMaW5lR3VpZGUiLCJmaXJlQW5kRm9yd2FyZCIsInR5cGUiLCJlIiwiZWRpdFRvb2xzIiwiZmlyZSIsImRhc2hBcnJheSIsIndlaWdodCIsImludGVyYWN0aXZlIiwicG9seWxpbmUiLCJjcmVhdGVWZXJ0ZXhJY29uIiwiQnJvd3NlciIsIm1vYmlsZSIsInRvdWNoIiwiVG91Y2hWZXJ0ZXhJY29uIiwiVmVydGV4SWNvbiIsIkxheWVyR3JvdXAiLCJhZGRUbyIsIm1vdmVGb3J3YXJkTGluZUd1aWRlIiwibGF0bG5nIiwiX2xhdGxuZ3MiLCJsZW5ndGgiLCJfYm91bmRzIiwicmVkcmF3IiwibW92ZUJhY2t3YXJkTGluZUd1aWRlIiwiYW5jaG9yRm9yd2FyZExpbmVHdWlkZSIsImFuY2hvckJhY2t3YXJkTGluZUd1aWRlIiwiYXR0YWNoRm9yd2FyZExpbmVHdWlkZSIsImFkZExheWVyIiwiYXR0YWNoQmFja3dhcmRMaW5lR3VpZGUiLCJkZXRhY2hGb3J3YXJkTGluZUd1aWRlIiwic2V0TGF0TG5ncyIsInJlbW92ZUxheWVyIiwiZGV0YWNoQmFja3dhcmRMaW5lR3VpZGUiLCJibG9ja0V2ZW50cyIsIl9vbGRUYXJnZXRzIiwiX3RhcmdldHMiLCJ1bmJsb2NrRXZlbnRzIiwicmVnaXN0ZXJGb3JEcmF3aW5nIiwiZWRpdG9yIiwiX2RyYXdpbmdFZGl0b3IiLCJ1bnJlZ2lzdGVyRm9yRHJhd2luZyIsInJlc2V0Iiwib24iLCJvbkRyYXdpbmdNb3VzZU1vdmUiLCJvbk1vdXNlZG93biIsIm9uTW91c2V1cCIsIkRvbVV0aWwiLCJhZGRDbGFzcyIsIl9jb250YWluZXIiLCJkZWZhdWx0TWFwQ3Vyc29yIiwic3R5bGUiLCJjdXJzb3IiLCJyZW1vdmVDbGFzcyIsIm9mZiIsIl9kcmF3aW5nIiwiY2FuY2VsRHJhd2luZyIsIm9yaWdpbmFsRXZlbnQiLCJ3aGljaCIsIl9tb3VzZURvd24iLCJvbkRyYXdpbmdNb3VzZURvd24iLCJtb3VzZURvd24iLCJvbkRyYXdpbmdNb3VzZVVwIiwib3JpZ2luIiwicG9pbnQiLCJjbGllbnRYIiwiY2xpZW50WSIsImRpc3RhbmNlIiwiZGlzdGFuY2VUbyIsIk1hdGgiLCJhYnMiLCJkZXZpY2VQaXhlbFJhdGlvIiwib25EcmF3aW5nQ2xpY2siLCJkcmF3aW5nIiwic3RvcERyYXdpbmciLCJjb21taXREcmF3aW5nIiwiY29ubmVjdENyZWF0ZWRUb01hcCIsImxheWVyIiwic3RhcnRQb2x5bGluZSIsImxpbmUiLCJjcmVhdGVQb2x5bGluZSIsImVuYWJsZUVkaXQiLCJuZXdTaGFwZSIsInN0YXJ0UG9seWdvbiIsInBvbHlnb24iLCJjcmVhdGVQb2x5Z29uIiwic3RhcnRNYXJrZXIiLCJnZXRDZW50ZXIiLCJjbG9uZSIsIm1hcmtlciIsImNyZWF0ZU1hcmtlciIsInN0YXJ0RHJhd2luZyIsInN0YXJ0UmVjdGFuZ2xlIiwiY29ybmVyIiwibGF0TG5nIiwiYm91bmRzIiwiTGF0TG5nQm91bmRzIiwicmVjdGFuZ2xlIiwiY3JlYXRlUmVjdGFuZ2xlIiwic3RhcnRDaXJjbGUiLCJjaXJjbGUiLCJjcmVhdGVDaXJjbGUiLCJzdGFydEhvbGUiLCJuZXdIb2xlIiwiY3JlYXRlTGF5ZXIiLCJrbGFzcyIsImxhdGxuZ3MiLCJVdGlsIiwiZWRpdE9wdGlvbnMiLCJtYWtlQ2FuY2VsbGFibGUiLCJjYW5jZWwiLCJfY2FuY2VsbGVkIiwiTWFwIiwibWVyZ2VPcHRpb25zIiwiZWRpdFRvb2xzQ2xhc3MiLCJlZGl0YWJsZSIsImFkZEluaXRIb29rIiwid2hlblJlYWR5IiwiRGl2SWNvbiIsImljb25TaXplIiwiUG9pbnQiLCJWZXJ0ZXhNYXJrZXIiLCJkcmFnZ2FibGUiLCJjbGFzc05hbWUiLCJwcm90b3R5cGUiLCJjYWxsIiwiaWNvbiIsInRvb2xzIiwiX192ZXJ0ZXgiLCJzZXRaSW5kZXhPZmZzZXQiLCJvbkFkZCIsIm9uRHJhZyIsIm9uRHJhZ1N0YXJ0Iiwib25EcmFnRW5kIiwib25DbGljayIsIm9uQ29udGV4dE1lbnUiLCJvbk1vdXNlRG93biIsIm9uTW91c2VPdmVyIiwib25Nb3VzZU91dCIsImFkZE1pZGRsZU1hcmtlcnMiLCJvblJlbW92ZSIsIm1pZGRsZU1hcmtlciIsImRlbGV0ZSIsInZlcnRleCIsIm9uVmVydGV4TWFya2VyRHJhZyIsImljb25Qb3MiLCJnZXRQb3NpdGlvbiIsIl9pY29uIiwiX21hcCIsImxheWVyUG9pbnRUb0xhdExuZyIsInVwZGF0ZSIsIl9sYXRsbmciLCJyZWZyZXNoIiwidXBkYXRlTGF0TG5nIiwibmV4dCIsImdldE5leHQiLCJvblZlcnRleE1hcmtlckRyYWdTdGFydCIsIm9uVmVydGV4TWFya2VyRHJhZ0VuZCIsIm9uVmVydGV4TWFya2VyQ2xpY2siLCJEb21FdmVudCIsInN0b3AiLCJvblZlcnRleE1hcmtlckNvbnRleHRNZW51Iiwib25WZXJ0ZXhNYXJrZXJNb3VzZURvd24iLCJvblZlcnRleE1hcmtlck1vdXNlT3ZlciIsIm9uVmVydGV4TWFya2VyTW91c2VPdXQiLCJzcGxpY2UiLCJnZXRJbmRleCIsIm9uVmVydGV4RGVsZXRlZCIsImRlbGV0ZVNoYXBlIiwicmVzZXRNaWRkbGVNYXJrZXIiLCJpbmRleE9mIiwiZ2V0TGFzdEluZGV4IiwiZ2V0UHJldmlvdXMiLCJpbmRleCIsInByZXZpb3VzSW5kZXgiLCJDTE9TRUQiLCJwcmV2aW91cyIsIm5leHRJbmRleCIsImFkZE1pZGRsZU1hcmtlciIsImhhc01pZGRsZU1hcmtlcnMiLCJzcGxpdCIsInNwbGl0U2hhcGUiLCJjb250aW51ZSIsImNvbnRpbnVlQmFja3dhcmQiLCJjb250aW51ZUZvcndhcmQiLCJ2ZXJ0ZXhNYXJrZXJDbGFzcyIsIk1pZGRsZU1hcmtlciIsIm9wYWNpdHkiLCJsZWZ0IiwicmlnaHQiLCJjb21wdXRlTGF0TG5nIiwiX29wYWNpdHkiLCJzZXRWaXNpYmlsaXR5IiwibGVmdFBvaW50IiwibGF0TG5nVG9Db250YWluZXJQb2ludCIsInJpZ2h0UG9pbnQiLCJzaXplIiwieCIsImhpZGUiLCJzaG93Iiwic2V0T3BhY2l0eSIsInNldExhdExuZyIsInkiLCJjb250YWluZXJQb2ludFRvTGF0TG5nIiwib25NaWRkbGVNYXJrZXJNb3VzZURvd24iLCJhZGRWZXJ0ZXhNYXJrZXIiLCJvbk5ld1ZlcnRleCIsInBhcmVudCIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsImFwcGVuZENoaWxkIiwiX2luaXRJY29uIiwiX2luaXRJbnRlcmFjdGlvbiIsIkRyYWdnYWJsZSIsIl9kcmFnZ2luZyIsImRyYWdnaW5nIiwiX2RyYWdnYWJsZSIsIl9vbkRvd24iLCJtaWRkbGVNYXJrZXJDbGFzcyIsIkJhc2VFZGl0b3IiLCJIYW5kbGVyIiwiZmVhdHVyZSIsImFkZEhvb2tzIiwiaXNDb25uZWN0ZWQiLCJvbkZlYXR1cmVBZGQiLCJvbmNlIiwib25FbmFibGUiLCJfZ2V0RXZlbnRzIiwicmVtb3ZlSG9va3MiLCJkaXNhYmxlIiwiY2xlYXJMYXllcnMiLCJvbkRpc2FibGUiLCJlbmFibGUiLCJvbkVkaXRpbmciLCJvblN0YXJ0RHJhd2luZyIsIm9uRW5kRHJhd2luZyIsIm9uQ2FuY2VsRHJhd2luZyIsIm9uQ29tbWl0RHJhd2luZyIsImVuZERyYXdpbmciLCJjb25uZWN0IiwicHJvY2Vzc0RyYXdpbmdDbGljayIsImhhc0xheWVyIiwib25Nb3ZlIiwiZHJhZ3N0YXJ0IiwiZHJhZyIsImRyYWdlbmQiLCJyZW1vdmUiLCJNYXJrZXJFZGl0b3IiLCJQYXRoRWRpdG9yIiwiTUlOX1ZFUlRFWCIsImluaXRWZXJ0ZXhNYXJrZXJzIiwiZW5hYmxlZCIsImdldExhdExuZ3MiLCJpc0ZsYXQiLCJhZGRWZXJ0ZXhNYXJrZXJzIiwiaSIsInJlZnJlc2hWZXJ0ZXhNYXJrZXJzIiwiZ2V0RGVmYXVsdExhdExuZ3MiLCJjb21taXQiLCJjdHJsS2V5Iiwib25WZXJ0ZXhNYXJrZXJDdHJsQ2xpY2siLCJhbHRLZXkiLCJvblZlcnRleE1hcmtlckFsdENsaWNrIiwic2hpZnRLZXkiLCJvblZlcnRleE1hcmtlclNoaWZ0Q2xpY2siLCJtZXRhS2V5Iiwib25WZXJ0ZXhNYXJrZXJNZXRhS2V5Q2xpY2siLCJfZHJhd25MYXRMbmdzIiwib25WZXJ0ZXhSYXdNYXJrZXJDbGljayIsInZlcnRleENhbkJlRGVsZXRlZCIsImV4dGVuZEJvdW5kcyIsInNldERyYXduTGF0TG5ncyIsInN0YXJ0RHJhd2luZ0ZvcndhcmQiLCJhZGRMYXRMbmciLCJwdXNoIiwidW5zaGlmdCIsIm5ld1BvaW50Rm9yd2FyZCIsIm5ld1BvaW50QmFja3dhcmQiLCJjb25zb2xlIiwiZXJyb3IiLCJyZW1vdmVMYXRMbmciLCJwb3AiLCJzaGFwZSIsImFkZE5ld0VtcHR5U2hhcGUiLCJfZGVsZXRlU2hhcGUiLCJlbnN1cmVOb3RGbGF0Iiwic2VsZiIsImlucGxhY2VEZWxldGUiLCJOdW1iZXIiLCJNQVhfVkFMVUUiLCJzcGxpY2VEZWxldGUiLCJkZWxldGVTaGFwZUF0Iiwic2hhcGVBdCIsImFwcGVuZFNoYXBlIiwiaW5zZXJ0U2hhcGUiLCJwcmVwZW5kU2hhcGUiLCJlbnN1cmVNdWx0aSIsImZvcm1hdFNoYXBlIiwiX2VuYWJsZWQiLCJQb2x5bGluZUVkaXRvciIsInN0YXJ0RHJhd2luZ0JhY2t3YXJkIiwiTGF0TG5nIiwic2hhcGVJbmRleCIsImZpcnN0Iiwic2xpY2UiLCJzZWNvbmQiLCJsYXQiLCJsbmciLCJhbHQiLCJQb2x5Z29uRWRpdG9yIiwiYWRkTmV3RW1wdHlIb2xlIiwiaG9sZXMiLCJwYXJlbnRTaGFwZSIsImlkeCIsIlJlY3RhbmdsZUVkaXRvciIsIm9wcG9zaXRlSW5kZXgiLCJvcHBvc2l0ZSIsInVwZGF0ZUJvdW5kcyIsInVwZGF0ZUxhdExuZ3MiLCJfc2ltdWxhdGVkIiwiX29uVXAiLCJuZXdMYXRsbmdzIiwiX2JvdW5kc1RvTGF0TG5ncyIsIkNpcmNsZUVkaXRvciIsIl9yZXNpemVMYXRMbmciLCJjb21wdXRlUmVzaXplTGF0TG5nIiwiZGVsdGEiLCJfcmFkaXVzIiwiX21SYWRpdXMiLCJjb3MiLCJQSSIsInByb2plY3QiLCJ1bnByb2plY3QiLCJ1cGRhdGVSZXNpemVMYXRMbmciLCJyZXNpemUiLCJyYWRpdXMiLCJzZXRSYWRpdXMiLCJFZGl0YWJsZU1peGluIiwiY3JlYXRlRWRpdG9yIiwiRXJyb3IiLCJLbGFzcyIsImVkaXRvckNsYXNzIiwiZ2V0RWRpdG9yQ2xhc3MiLCJlZGl0RW5hYmxlZCIsImRpc2FibGVFZGl0IiwidG9nZ2xlRWRpdCIsIl9vbkVkaXRhYmxlQWRkIiwiUG9seWxpbmVNaXhpbiIsImlzSW5MYXRMbmdzIiwibCIsImsiLCJsZW4iLCJwYXJ0IiwicCIsInciLCJfY2xpY2tUb2xlcmFuY2UiLCJfcHJvamVjdExhdGxuZ3MiLCJfcHhCb3VuZHMiLCJsYXRMbmdUb0xheWVyUG9pbnQiLCJjb250YWlucyIsIkxpbmVVdGlsIiwicG9pbnRUb1NlZ21lbnREaXN0YW5jZSIsIlBvbHlnb25NaXhpbiIsImluc2lkZSIsImwxIiwibDIiLCJqIiwibGVuMiIsIk1hcmtlck1peGluIiwiUmVjdGFuZ2xlTWl4aW4iLCJDaXJjbGVNaXhpbiIsImtlZXBFZGl0YWJsZSIsIl9mbGF0IiwiaW5jbHVkZSJdLCJtYXBwaW5ncyI6IkFBQUEsZUFBZTtBQUNYQSxXQURXLHFCQUNGO0FBQ0wsYUFBS0MsSUFBTCxDQUFVQyxPQUFPQyxDQUFqQjtBQUNILEtBSFU7QUFJWEYsUUFKVyxnQkFJTkUsQ0FKTSxFQUlKO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBQSxVQUFFQyxRQUFGLEdBQWFELEVBQUVFLE9BQUYsQ0FBVUMsTUFBVixDQUFpQjs7QUFFMUJDLHFCQUFTO0FBQ0xDLHlCQUFTLENBREo7QUFFTEMsMEJBQVUsQ0FBQztBQUZOLGFBRmlCOztBQU8xQkMscUJBQVM7O0FBRUw7QUFDQTtBQUNBO0FBQ0FDLHdCQUFRLElBTEg7O0FBT0w7QUFDQTtBQUNBQyw4QkFBY1QsRUFBRVUsT0FUWDs7QUFXTDtBQUNBO0FBQ0FDLCtCQUFlWCxFQUFFWSxRQWJaOztBQWVMO0FBQ0E7QUFDQUMsNkJBQWFiLEVBQUVjLE1BakJWOztBQW1CTDtBQUNBO0FBQ0FDLGdDQUFnQmYsRUFBRWdCLFNBckJiOztBQXVCTDtBQUNBO0FBQ0FDLDZCQUFhakIsRUFBRWtCLE1BekJWOztBQTJCTDtBQUNBO0FBQ0FDLGlDQUFpQiwwQkE3Qlo7O0FBK0JMO0FBQ0E7QUFDQUMsK0JBQWUsV0FqQ1Y7O0FBbUNMO0FBQ0E7QUFDQUMsMkJBQVdDLFNBckNOOztBQXVDTDtBQUNBO0FBQ0FDLCtCQUFlRCxTQXpDVjs7QUEyQ0w7QUFDQTtBQUNBRSxxQ0FBcUJGLFNB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QWlCcEMsYUFBakI7QUFDQXhYLGNBQUVrQixNQUFGLENBQVMwWSxPQUFULENBQWlCSCxXQUFqQjtBQUNIOztBQUVEelosVUFBRW9WLE1BQUYsQ0FBU2pMLFNBQVQsQ0FBbUIwQixNQUFuQixHQUE0QixVQUFVbkksTUFBVixFQUFrQjtBQUMxQ0EscUJBQVMxRCxFQUFFcUksTUFBRixDQUFTM0UsTUFBVCxDQUFUO0FBQ0EsaUJBQUsrUixHQUFMLEdBQVcvUixPQUFPK1IsR0FBbEI7QUFDQSxpQkFBS0MsR0FBTCxHQUFXaFMsT0FBT2dTLEdBQWxCO0FBQ0gsU0FKRDtBQUtIO0FBejREVSxDQUFmIiwiZmlsZSI6IlZ1ZTJMZWFmbGV0RWRpdGFibGVQbHVnaW4uanMiLCJzb3VyY2VSb290IjoiL1VzZXJzL3B1bWVsb3RlYS9WdWVQcm9qZWN0cy92dWUyLWxlYWZsZXQtZWRpdGFibGUiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCB7XG4gICAgaW5zdGFsbCgpe1xuICAgICAgICB0aGlzLmluaXQod2luZG93LkwpXG4gICAgfSxcbiAgICBpbml0KEwpe1xuICAgICAgICAvLyDwn42CbWluaWNsYXNzIENhbmNlbGFibGVFdmVudCAoRXZlbnQgb2JqZWN0cylcbiAgICAgICAgLy8g8J+Ngm1ldGhvZCBjYW5jZWwoKVxuICAgICAgICAvLyBDYW5jZWwgYW55IHN1YnNlcXVlbnQgYWN0aW9uLlxuXG4gICAgICAgIC8vIPCfjYJtaW5pY2xhc3MgVmVydGV4RXZlbnQgKEV2ZW50IG9iamVjdHMpXG4gICAgICAgIC8vIPCfjYJwcm9wZXJ0eSB2ZXJ0ZXg6IFZlcnRleE1hcmtlclxuICAgICAgICAvLyBUaGUgdmVydGV4IHRoYXQgZmlyZXMgdGhlIGV2ZW50LlxuXG4gICAgICAgIC8vIPCfjYJtaW5pY2xhc3MgU2hhcGVFdmVudCAoRXZlbnQgb2JqZWN0cylcbiAgICAgICAgLy8g8J+NgnByb3BlcnR5IHNoYXBlOiBBcnJheVxuICAgICAgICAvLyBUaGUgc2hhcGUgKExhdExuZ3MgYXJyYXkpIHN1YmplY3Qgb2YgdGhlIGFjdGlvbi5cblxuICAgICAgICAvLyDwn42CbWluaWNsYXNzIENhbmNlbGFibGVWZXJ0ZXhFdmVudCAoRXZlbnQgb2JqZWN0cylcbiAgICAgICAgLy8g8J+NgmluaGVyaXRzIFZlcnRleEV2ZW50XG4gICAgICAgIC8vIPCfjYJpbmhlcml0cyBDYW5jZWxhYmxlRXZlbnRcblxuICAgICAgICAvLyDwn42CbWluaWNsYXNzIENhbmNlbGFibGVTaGFwZUV2ZW50IChFdmVudCBvYmplY3RzKVxuICAgICAgICAvLyDwn42CaW5oZXJpdHMgU2hhcGVFdmVudFxuICAgICAgICAvLyDwn42CaW5oZXJpdHMgQ2FuY2VsYWJsZUV2ZW50XG5cbiAgICAgICAgLy8g8J+Ngm1pbmljbGFzcyBMYXllckV2ZW50IChFdmVudCBvYmplY3RzKVxuICAgICAgICAvLyDwn42CcHJvcGVydHkgbGF5ZXI6IG9iamVjdFxuICAgICAgICAvLyBUaGUgTGF5ZXIgKE1hcmtlciwgUG9seWxpbmXigKYpIHN1YmplY3Qgb2YgdGhlIGFjdGlvbi5cblxuICAgICAgICAvLyDwn42CbmFtZXNwYWNlIEVkaXRhYmxlOyDwn42CY2xhc3MgRWRpdGFibGU7IPCfjYJha2EgTC5FZGl0YWJsZVxuICAgICAgICAvLyBNYWluIGVkaXRpb24gaGFuZGxlci4gQnkgZGVmYXVsdCwgaXQgaXMgYXR0YWNoZWQgdG8gdGhlIG1hcFxuICAgICAgICAvLyBhcyBgbWFwLmVkaXRUb29sc2AgcHJvcGVydHkuXG4gICAgICAgIC8vIExlYWZsZXQuRWRpdGFibGUgaXMgbWFkZSB0byBiZSBmdWxseSBleHRlbmRhYmxlLiBZb3UgaGF2ZSB0aHJlZSB3YXlzIHRvIGN1c3RvbWl6ZVxuICAgICAgICAvLyB0aGUgYmVoYXZpb3VyOiB1c2luZyBvcHRpb25zLCBsaXN0ZW5pbmcgdG8gZXZlbnRzLCBvciBleHRlbmRpbmcuXG4gICAgICAgIEwuRWRpdGFibGUgPSBMLkV2ZW50ZWQuZXh0ZW5kKHtcblxuICAgICAgICAgICAgc3RhdGljczoge1xuICAgICAgICAgICAgICAgIEZPUldBUkQ6IDEsXG4gICAgICAgICAgICAgICAgQkFDS1dBUkQ6IC0xXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBvcHRpb25zOiB7XG5cbiAgICAgICAgICAgICAgICAvLyBZb3UgY2FuIHBhc3MgdGhlbSB3aGVuIGNyZWF0aW5nIGEgbWFwIHVzaW5nIHRoZSBgZWRpdE9wdGlvbnNgIGtleS5cbiAgICAgICAgICAgICAgICAvLyDwn42Cb3B0aW9uIHpJbmRleDogaW50ID0gMTAwMFxuICAgICAgICAgICAgICAgIC8vIFRoZSBkZWZhdWx0IHpJbmRleCBvZiB0aGUgZWRpdGluZyB0b29scy5cbiAgICAgICAgICAgICAgICB6SW5kZXg6IDEwMDAsXG5cbiAgICAgICAgICAgICAgICAvLyDwn42Cb3B0aW9uIHBvbHlnb25DbGFzczogY2xhc3MgPSBMLlBvbHlnb25cbiAgICAgICAgICAgICAgICAvLyBDbGFzcyB0byBiZSB1c2VkIHdoZW4gY3JlYXRpbmcgYSBuZXcgUG9seWdvbi5cbiAgICAgICAgICAgICAgICBwb2x5Z29uQ2xhc3M6IEwuUG9seWdvbixcblxuICAgICAgICAgICAgICAgIC8vIPCfjYJvcHRpb24gcG9seWxpbmVDbGFzczogY2xhc3MgPSBMLlBvbHlsaW5lXG4gICAgICAgICAgICAgICAgLy8gQ2xhc3MgdG8gYmUgdXNlZCB3aGVuIGNyZWF0aW5nIGEgbmV3IFBvbHlsaW5lLlxuICAgICAgICAgICAgICAgIHBvbHlsaW5lQ2xhc3M6IEwuUG9seWxpbmUsXG5cbiAgICAgICAgICAgICAgICAvLyDwn42Cb3B0aW9uIG1hcmtlckNsYXNzOiBjbGFzcyA9IEwuTWFya2VyXG4gICAgICAgICAgICAgICAgLy8gQ2xhc3MgdG8gYmUgdXNlZCB3aGVuIGNyZWF0aW5nIGEgbmV3IE1hcmtlci5cbiAgICAgICAgICAgICAgICBtYXJrZXJDbGFzczogTC5NYXJrZXIsXG5cbiAgICAgICAgICAgICAgICAvLyDwn42Cb3B0aW9uIHJlY3RhbmdsZUNsYXNzOiBjbGFzcyA9IEwuUmVjdGFuZ2xlXG4gICAgICAgICAgICAgICAgLy8gQ2xhc3MgdG8gYmUgdXNlZCB3aGVuIGNyZWF0aW5nIGEgbmV3IFJlY3RhbmdsZS5cbiAgICAgICAgICAgICAgICByZWN0YW5nbGVDbGFzczogTC5SZWN0YW5nbGUsXG5cbiAgICAgICAgICAgICAgICAvLyDwn42Cb3B0aW9uIGNpcmNsZUNsYXNzOiBjbGFzcyA9IEwuQ2lyY2xlXG4gICAgICAgICAgICAgICAgLy8gQ2xhc3MgdG8gYmUgdXNlZCB3aGVuIGNyZWF0aW5nIGEgbmV3IENpcmNsZS5cbiAgICAgICAgICAgICAgICBjaXJjbGVDbGFzczogTC5DaXJjbGUsXG5cbiAgICAgICAgICAgICAgICAvLyDwn42Cb3B0aW9uIGRyYXdpbmdDU1NDbGFzczogc3RyaW5nID0gJ2xlYWZsZXQtZWRpdGFibGUtZHJhd2luZydcbiAgICAgICAgICAgICAgICAvLyBDU1MgY2xhc3MgdG8gYmUgYWRkZWQgdG8gdGhlIG1hcCBjb250YWluZXIgd2hpbGUgZHJhd2luZy5cbiAgICAgICAgICAgICAgICBkcmF3aW5nQ1NTQ2xhc3M6ICdsZWFmbGV0LWVkaXRhYmxlLWRyYXdpbmcnLFxuXG4gICAgICAgICAgICAgICAgLy8g8J+Ngm9wdGlvbiBkcmF3aW5nQ3Vyc29yOiBjb25zdCA9ICdjcm9zc2hhaXInXG4gICAgICAgICAgICAgICAgLy8gQ3Vyc29yIG1vZGUgc2V0IHRvIHRoZSBtYXAgd2hpbGUgZHJhd2luZy5cbiAgICAgICAgICAgICAgICBkcmF3aW5nQ3Vyc29yOiAnY3Jvc3NoYWlyJyxcblxuICAgICAgICAgICAgICAgIC8vIPCfjYJvcHRpb24gZWRpdExheWVyOiBMYXllciA9IG5ldyBMLkxheWVyR3JvdXAoKVxuICAgICAgICAgICAgICAgIC8vIExheWVyIHVzZWQgdG8gc3RvcmUgZWRpdCB0b29scyAodmVydGV4LCBsaW5lIGd1aWRl4oCmKS5cbiAgICAgICAgICAgICAgICBlZGl0TGF5ZXI6IHVuZGVmaW5lZCxcblxuICAgICAgICAgICAgICAgIC8vIPCfjYJvcHRpb24gZmVhdHVyZXNMYXllcjogTGF5ZXIgPSBuZXcgTC5MYXllckdyb3VwKClcbiAgICAgICAgICAgICAgICAvLyBEZWZhdWx0IGxheWVyIHVzZWQgdG8gc3RvcmUgZHJhd24gZmVhdHVyZXMgKE1hcmtlciwgUG9seWxpbmXigKYpLlxuICAgICAgICAgICAgICAgIGZlYXR1cmVzTGF5ZXI6IHVuZGVmaW5lZCxcblxuICAgICAgICAgICAgICAgIC8vIPCfjYJvcHRpb24gcG9seWxpbmVFZGl0b3JDbGFzczogY2xhc3MgPSBQb2x5bGluZUVkaXRvclxuICAgICAgICAgICAgICAgIC8vIENsYXNzIHRvIGJlIHVzZWQgYXMgUG9seWxpbmUgZWRpdG9yLlxuICAgICAgICAgICAgICAgIHBvbHlsaW5lRWRpdG9yQ2xhc3M6IHVuZGVmaW5lZCxcblxuICAgICAgICAgICAgICAgIC8vIPCfjYJvcHRpb24gcG9seWdvbkVkaXRvckNsYXNzOiBjbGFzcyA9IFBvbHlnb25FZGl0b3JcbiAgICAgICAgICAgICAgICAvLyBDbGFzcyB0byBiZSB1c2VkIGFzIFBvbHlnb24gZWRpdG9yLlxuICAgICAgICAgICAgICAgIHBvbHlnb25FZGl0b3JDbGFzczogdW5kZWZpbmVkLFxuXG4gICAgICAgICAgICAgICAgLy8g8J+Ngm9wdGlvbiBtYXJrZXJFZGl0b3JDbGFzczogY2xhc3MgPSBNYXJrZXJFZGl0b3JcbiAgICAgICAgICAgICAgICAvLyBDbGFzcyB0byBiZSB1c2VkIGFzIE1hcmtlciBlZGl0b3IuXG4gICAgICAgICAgICAgICAgbWFya2VyRWRpdG9yQ2xhc3M6IHVuZGVmaW5lZCxcblxuICAgICAgICAgICAgICAgIC8vIPCfjYJvcHRpb24gcmVjdGFuZ2xlRWRpdG9yQ2xhc3M6IGNsYXNzID0gUmVjdGFuZ2xlRWRpdG9yXG4gICAgICAgICAgICAgICAgLy8gQ2xhc3MgdG8gYmUgdXNlZCBhcyBSZWN0YW5nbGUgZWRpdG9yLlxuICAgICAgICAgICAgICAgIHJlY3RhbmdsZUVkaXRvckNsYXNzOiB1bmRlZmluZWQsXG5cbiAgICAgICAgICAgICAgICAvLyDwn42Cb3B0aW9uIGNpcmNsZUVkaXRvckNsYXNzOiBjbGFzcyA9IENpcmNsZUVkaXRvclxuICAgICAgICAgICAgICAgIC8vIENsYXNzIHRvIGJlIHVzZWQgYXMgQ2lyY2xlIGVkaXRvci5cbiAgICAgICAgICAgICAgICBjaXJjbGVFZGl0b3JDbGFzczogdW5kZWZpbmVkLFxuXG4gICAgICAgICAgICAgICAgLy8g8J+Ngm9wdGlvbiBsaW5lR3VpZGVPcHRpb25zOiBoYXNoID0ge31cbiAgICAgICAgICAgICAgICAvLyBPcHRpb25zIHRvIGJlIHBhc3NlZCB0byB0aGUgbGluZSBndWlkZXMuXG4gICAgICAgICAgICAgICAgbGluZUd1aWRlT3B0aW9uczoge30sXG5cbiAgICAgICAgICAgICAgICAvLyDwn42Cb3B0aW9uIHNraXBNaWRkbGVNYXJrZXJzOiBib29sZWFuID0gZmFsc2VcbiAgICAgICAgICAgICAgICAvLyBTZXQgdGhpcyB0byB0cnVlIGlmIHlvdSBkb24ndCB3YW50IG1pZGRsZSBtYXJrZXJzLlxuICAgICAgICAgICAgICAgIHNraXBNaWRkbGVNYXJrZXJzOiBmYWxzZVxuXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBpbml0aWFsaXplOiBmdW5jdGlvbiAobWFwLCBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgTC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RaSW5kZXggPSB0aGlzLm9wdGlvbnMuekluZGV4O1xuICAgICAgICAgICAgICAgIHRoaXMubWFwID0gbWFwO1xuICAgICAgICAgICAgICAgIHRoaXMuZWRpdExheWVyID0gdGhpcy5jcmVhdGVFZGl0TGF5ZXIoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZlYXR1cmVzTGF5ZXIgPSB0aGlzLmNyZWF0ZUZlYXR1cmVzTGF5ZXIoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZvcndhcmRMaW5lR3VpZGUgPSB0aGlzLmNyZWF0ZUxpbmVHdWlkZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuYmFja3dhcmRMaW5lR3VpZGUgPSB0aGlzLmNyZWF0ZUxpbmVHdWlkZSgpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZmlyZUFuZEZvcndhcmQ6IGZ1bmN0aW9uICh0eXBlLCBlKSB7XG4gICAgICAgICAgICAgICAgZSA9IGUgfHwge307XG4gICAgICAgICAgICAgICAgZS5lZGl0VG9vbHMgPSB0aGlzO1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyZSh0eXBlLCBlKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1hcC5maXJlKHR5cGUsIGUpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgY3JlYXRlTGluZUd1aWRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBMLmV4dGVuZCh7ZGFzaEFycmF5OiAnNSwxMCcsIHdlaWdodDogMSwgaW50ZXJhY3RpdmU6IGZhbHNlfSwgdGhpcy5vcHRpb25zLmxpbmVHdWlkZU9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBMLnBvbHlsaW5lKFtdLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGNyZWF0ZVZlcnRleEljb246IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEwuQnJvd3Nlci5tb2JpbGUgJiYgTC5Ccm93c2VyLnRvdWNoID8gbmV3IEwuRWRpdGFibGUuVG91Y2hWZXJ0ZXhJY29uKG9wdGlvbnMpIDogbmV3IEwuRWRpdGFibGUuVmVydGV4SWNvbihvcHRpb25zKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGNyZWF0ZUVkaXRMYXllcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuZWRpdExheWVyIHx8IG5ldyBMLkxheWVyR3JvdXAoKS5hZGRUbyh0aGlzLm1hcCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBjcmVhdGVGZWF0dXJlc0xheWVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5mZWF0dXJlc0xheWVyIHx8IG5ldyBMLkxheWVyR3JvdXAoKS5hZGRUbyh0aGlzLm1hcCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBtb3ZlRm9yd2FyZExpbmVHdWlkZTogZnVuY3Rpb24gKGxhdGxuZykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZvcndhcmRMaW5lR3VpZGUuX2xhdGxuZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZm9yd2FyZExpbmVHdWlkZS5fbGF0bG5nc1sxXSA9IGxhdGxuZztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mb3J3YXJkTGluZUd1aWRlLl9ib3VuZHMuZXh0ZW5kKGxhdGxuZyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZm9yd2FyZExpbmVHdWlkZS5yZWRyYXcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBtb3ZlQmFja3dhcmRMaW5lR3VpZGU6IGZ1bmN0aW9uIChsYXRsbmcpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5iYWNrd2FyZExpbmVHdWlkZS5fbGF0bG5ncy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5iYWNrd2FyZExpbmVHdWlkZS5fbGF0bG5nc1sxXSA9IGxhdGxuZztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5iYWNrd2FyZExpbmVHdWlkZS5fYm91bmRzLmV4dGVuZChsYXRsbmcpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJhY2t3YXJkTGluZUd1aWRlLnJlZHJhdygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGFuY2hvckZvcndhcmRMaW5lR3VpZGU6IGZ1bmN0aW9uIChsYXRsbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZvcndhcmRMaW5lR3VpZGUuX2xhdGxuZ3NbMF0gPSBsYXRsbmc7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3J3YXJkTGluZUd1aWRlLl9ib3VuZHMuZXh0ZW5kKGxhdGxuZyk7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3J3YXJkTGluZUd1aWRlLnJlZHJhdygpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgYW5jaG9yQmFja3dhcmRMaW5lR3VpZGU6IGZ1bmN0aW9uIChsYXRsbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJhY2t3YXJkTGluZUd1aWRlLl9sYXRsbmdzWzBdID0gbGF0bG5nO1xuICAgICAgICAgICAgICAgIHRoaXMuYmFja3dhcmRMaW5lR3VpZGUuX2JvdW5kcy5leHRlbmQobGF0bG5nKTtcbiAgICAgICAgICAgICAgICB0aGlzLmJhY2t3YXJkTGluZUd1aWRlLnJlZHJhdygpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgYXR0YWNoRm9yd2FyZExpbmVHdWlkZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZWRpdExheWVyLmFkZExheWVyKHRoaXMuZm9yd2FyZExpbmVHdWlkZSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBhdHRhY2hCYWNrd2FyZExpbmVHdWlkZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZWRpdExheWVyLmFkZExheWVyKHRoaXMuYmFja3dhcmRMaW5lR3VpZGUpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZGV0YWNoRm9yd2FyZExpbmVHdWlkZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZm9yd2FyZExpbmVHdWlkZS5zZXRMYXRMbmdzKFtdKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVkaXRMYXllci5yZW1vdmVMYXllcih0aGlzLmZvcndhcmRMaW5lR3VpZGUpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZGV0YWNoQmFja3dhcmRMaW5lR3VpZGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJhY2t3YXJkTGluZUd1aWRlLnNldExhdExuZ3MoW10pO1xuICAgICAgICAgICAgICAgIHRoaXMuZWRpdExheWVyLnJlbW92ZUxheWVyKHRoaXMuYmFja3dhcmRMaW5lR3VpZGUpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgYmxvY2tFdmVudHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyBIYWNrOiBmb3JjZSBtYXAgbm90IHRvIGxpc3RlbiB0byBvdGhlciBsYXllcnMgZXZlbnRzIHdoaWxlIGRyYXdpbmcuXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9vbGRUYXJnZXRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29sZFRhcmdldHMgPSB0aGlzLm1hcC5fdGFyZ2V0cztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXAuX3RhcmdldHMgPSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICB1bmJsb2NrRXZlbnRzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX29sZFRhcmdldHMpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzZXQsIGJ1dCBrZWVwIHRhcmdldHMgY3JlYXRlZCB3aGlsZSBkcmF3aW5nLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hcC5fdGFyZ2V0cyA9IEwuZXh0ZW5kKHRoaXMubWFwLl90YXJnZXRzLCB0aGlzLl9vbGRUYXJnZXRzKTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX29sZFRhcmdldHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgcmVnaXN0ZXJGb3JEcmF3aW5nOiBmdW5jdGlvbiAoZWRpdG9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2RyYXdpbmdFZGl0b3IpIHRoaXMudW5yZWdpc3RlckZvckRyYXdpbmcodGhpcy5fZHJhd2luZ0VkaXRvcik7XG4gICAgICAgICAgICAgICAgdGhpcy5ibG9ja0V2ZW50cygpO1xuICAgICAgICAgICAgICAgIGVkaXRvci5yZXNldCgpOyAgLy8gTWFrZSBzdXJlIGVkaXRvciB0b29scyBzdGlsbCByZWNlaXZlIGV2ZW50cy5cbiAgICAgICAgICAgICAgICB0aGlzLl9kcmF3aW5nRWRpdG9yID0gZWRpdG9yO1xuICAgICAgICAgICAgICAgIHRoaXMubWFwLm9uKCdtb3VzZW1vdmUgdG91Y2htb3ZlJywgZWRpdG9yLm9uRHJhd2luZ01vdXNlTW92ZSwgZWRpdG9yKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1hcC5vbignbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlZG93biwgdGhpcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXAub24oJ21vdXNldXAnLCB0aGlzLm9uTW91c2V1cCwgdGhpcyk7XG4gICAgICAgICAgICAgICAgTC5Eb21VdGlsLmFkZENsYXNzKHRoaXMubWFwLl9jb250YWluZXIsIHRoaXMub3B0aW9ucy5kcmF3aW5nQ1NTQ2xhc3MpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGVmYXVsdE1hcEN1cnNvciA9IHRoaXMubWFwLl9jb250YWluZXIuc3R5bGUuY3Vyc29yO1xuICAgICAgICAgICAgICAgIHRoaXMubWFwLl9jb250YWluZXIuc3R5bGUuY3Vyc29yID0gdGhpcy5vcHRpb25zLmRyYXdpbmdDdXJzb3I7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICB1bnJlZ2lzdGVyRm9yRHJhd2luZzogZnVuY3Rpb24gKGVkaXRvcikge1xuICAgICAgICAgICAgICAgIHRoaXMudW5ibG9ja0V2ZW50cygpO1xuICAgICAgICAgICAgICAgIEwuRG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLm1hcC5fY29udGFpbmVyLCB0aGlzLm9wdGlvbnMuZHJhd2luZ0NTU0NsYXNzKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1hcC5fY29udGFpbmVyLnN0eWxlLmN1cnNvciA9IHRoaXMuZGVmYXVsdE1hcEN1cnNvcjtcbiAgICAgICAgICAgICAgICBlZGl0b3IgPSBlZGl0b3IgfHwgdGhpcy5fZHJhd2luZ0VkaXRvcjtcbiAgICAgICAgICAgICAgICBpZiAoIWVkaXRvcikgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHRoaXMubWFwLm9mZignbW91c2Vtb3ZlIHRvdWNobW92ZScsIGVkaXRvci5vbkRyYXdpbmdNb3VzZU1vdmUsIGVkaXRvcik7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXAub2ZmKCdtb3VzZWRvd24nLCB0aGlzLm9uTW91c2Vkb3duLCB0aGlzKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1hcC5vZmYoJ21vdXNldXAnLCB0aGlzLm9uTW91c2V1cCwgdGhpcyk7XG4gICAgICAgICAgICAgICAgaWYgKGVkaXRvciAhPT0gdGhpcy5fZHJhd2luZ0VkaXRvcikgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9kcmF3aW5nRWRpdG9yO1xuICAgICAgICAgICAgICAgIGlmIChlZGl0b3IuX2RyYXdpbmcpIGVkaXRvci5jYW5jZWxEcmF3aW5nKCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBvbk1vdXNlZG93bjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZS5vcmlnaW5hbEV2ZW50LndoaWNoICE9IDEpIHJldHVybjtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb3VzZURvd24gPSBlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYXdpbmdFZGl0b3Iub25EcmF3aW5nTW91c2VEb3duKGUpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgb25Nb3VzZXVwOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9tb3VzZURvd24pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVkaXRvciA9IHRoaXMuX2RyYXdpbmdFZGl0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3VzZURvd24gPSB0aGlzLl9tb3VzZURvd247XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21vdXNlRG93biA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGVkaXRvci5vbkRyYXdpbmdNb3VzZVVwKGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fZHJhd2luZ0VkaXRvciAhPT0gZWRpdG9yKSByZXR1cm47ICAvLyBvbkRyYXdpbmdNb3VzZVVwIG1heSBjYWxsIHVucmVnaXN0ZXJGcm9tRHJhd2luZy5cbiAgICAgICAgICAgICAgICAgICAgdmFyIG9yaWdpbiA9IEwucG9pbnQobW91c2VEb3duLm9yaWdpbmFsRXZlbnQuY2xpZW50WCwgbW91c2VEb3duLm9yaWdpbmFsRXZlbnQuY2xpZW50WSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IEwucG9pbnQoZS5vcmlnaW5hbEV2ZW50LmNsaWVudFgsIGUub3JpZ2luYWxFdmVudC5jbGllbnRZKS5kaXN0YW5jZVRvKG9yaWdpbik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhkaXN0YW5jZSkgPCA5ICogKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpKSB0aGlzLl9kcmF3aW5nRWRpdG9yLm9uRHJhd2luZ0NsaWNrKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIPCfjYJzZWN0aW9uIFB1YmxpYyBtZXRob2RzXG4gICAgICAgICAgICAvLyBZb3Ugd2lsbCBnZW5lcmFsbHkgYWNjZXNzIHRoZW0gYnkgdGhlIGBtYXAuZWRpdFRvb2xzYFxuICAgICAgICAgICAgLy8gaW5zdGFuY2U6XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gYG1hcC5lZGl0VG9vbHMuc3RhcnRQb2x5bGluZSgpO2BcblxuICAgICAgICAgICAgLy8g8J+Ngm1ldGhvZCBkcmF3aW5nKCk6IGJvb2xlYW5cbiAgICAgICAgICAgIC8vIFJldHVybiB0cnVlIGlmIGFueSBkcmF3aW5nIGFjdGlvbiBpcyBvbmdvaW5nLlxuICAgICAgICAgICAgZHJhd2luZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kcmF3aW5nRWRpdG9yICYmIHRoaXMuX2RyYXdpbmdFZGl0b3IuZHJhd2luZygpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8g8J+Ngm1ldGhvZCBzdG9wRHJhd2luZygpXG4gICAgICAgICAgICAvLyBXaGVuIHlvdSBuZWVkIHRvIHN0b3AgYW55IG9uZ29pbmcgZHJhd2luZywgd2l0aG91dCBuZWVkaW5nIHRvIGtub3cgd2hpY2ggZWRpdG9yIGlzIGFjdGl2ZS5cbiAgICAgICAgICAgIHN0b3BEcmF3aW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51bnJlZ2lzdGVyRm9yRHJhd2luZygpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8g8J+Ngm1ldGhvZCBjb21taXREcmF3aW5nKClcbiAgICAgICAgICAgIC8vIFdoZW4geW91IG5lZWQgdG8gY29tbWl0IGFueSBvbmdvaW5nIGRyYXdpbmcsIHdpdGhvdXQgbmVlZGluZyB0byBrbm93IHdoaWNoIGVkaXRvciBpcyBhY3RpdmUuXG4gICAgICAgICAgICBjb21taXREcmF3aW5nOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fZHJhd2luZ0VkaXRvcikgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYXdpbmdFZGl0b3IuY29tbWl0RHJhd2luZyhlKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGNvbm5lY3RDcmVhdGVkVG9NYXA6IGZ1bmN0aW9uIChsYXllcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZlYXR1cmVzTGF5ZXIuYWRkTGF5ZXIobGF5ZXIpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8g8J+Ngm1ldGhvZCBzdGFydFBvbHlsaW5lKGxhdGxuZzogTC5MYXRMbmcsIG9wdGlvbnM6IGhhc2gpOiBMLlBvbHlsaW5lXG4gICAgICAgICAgICAvLyBTdGFydCBkcmF3aW5nIGEgUG9seWxpbmUuIElmIGBsYXRsbmdgIGlzIGdpdmVuLCBhIGZpcnN0IHBvaW50IHdpbGwgYmUgYWRkZWQuIEluIGFueSBjYXNlLCBjb250aW51aW5nIG9uIHVzZXIgY2xpY2suXG4gICAgICAgICAgICAvLyBJZiBgb3B0aW9uc2AgaXMgZ2l2ZW4sIGl0IHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBQb2x5bGluZSBjbGFzcyBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICAgIHN0YXJ0UG9seWxpbmU6IGZ1bmN0aW9uIChsYXRsbmcsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGluZSA9IHRoaXMuY3JlYXRlUG9seWxpbmUoW10sIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGxpbmUuZW5hYmxlRWRpdCh0aGlzLm1hcCkubmV3U2hhcGUobGF0bG5nKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGluZTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIPCfjYJtZXRob2Qgc3RhcnRQb2x5Z29uKGxhdGxuZzogTC5MYXRMbmcsIG9wdGlvbnM6IGhhc2gpOiBMLlBvbHlnb25cbiAgICAgICAgICAgIC8vIFN0YXJ0IGRyYXdpbmcgYSBQb2x5Z29uLiBJZiBgbGF0bG5nYCBpcyBnaXZlbiwgYSBmaXJzdCBwb2ludCB3aWxsIGJlIGFkZGVkLiBJbiBhbnkgY2FzZSwgY29udGludWluZyBvbiB1c2VyIGNsaWNrLlxuICAgICAgICAgICAgLy8gSWYgYG9wdGlvbnNgIGlzIGdpdmVuLCBpdCB3aWxsIGJlIHBhc3NlZCB0byB0aGUgUG9seWdvbiBjbGFzcyBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICAgIHN0YXJ0UG9seWdvbjogZnVuY3Rpb24gKGxhdGxuZywgb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHZhciBwb2x5Z29uID0gdGhpcy5jcmVhdGVQb2x5Z29uKFtdLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBwb2x5Z29uLmVuYWJsZUVkaXQodGhpcy5tYXApLm5ld1NoYXBlKGxhdGxuZyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvbHlnb247XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyDwn42CbWV0aG9kIHN0YXJ0TWFya2VyKGxhdGxuZzogTC5MYXRMbmcsIG9wdGlvbnM6IGhhc2gpOiBMLk1hcmtlclxuICAgICAgICAgICAgLy8gU3RhcnQgYWRkaW5nIGEgTWFya2VyLiBJZiBgbGF0bG5nYCBpcyBnaXZlbiwgdGhlIE1hcmtlciB3aWxsIGJlIHNob3duIGZpcnN0IGF0IHRoaXMgcG9pbnQuXG4gICAgICAgICAgICAvLyBJbiBhbnkgY2FzZSwgaXQgd2lsbCBmb2xsb3cgdGhlIHVzZXIgbW91c2UsIGFuZCB3aWxsIGhhdmUgYSBmaW5hbCBgbGF0bG5nYCBvbiBuZXh0IGNsaWNrIChvciB0b3VjaCkuXG4gICAgICAgICAgICAvLyBJZiBgb3B0aW9uc2AgaXMgZ2l2ZW4sIGl0IHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBNYXJrZXIgY2xhc3MgY29uc3RydWN0b3IuXG4gICAgICAgICAgICBzdGFydE1hcmtlcjogZnVuY3Rpb24gKGxhdGxuZywgb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIGxhdGxuZyA9IGxhdGxuZyB8fCB0aGlzLm1hcC5nZXRDZW50ZXIoKS5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIHZhciBtYXJrZXIgPSB0aGlzLmNyZWF0ZU1hcmtlcihsYXRsbmcsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIG1hcmtlci5lbmFibGVFZGl0KHRoaXMubWFwKS5zdGFydERyYXdpbmcoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFya2VyO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8g8J+Ngm1ldGhvZCBzdGFydFJlY3RhbmdsZShsYXRsbmc6IEwuTGF0TG5nLCBvcHRpb25zOiBoYXNoKTogTC5SZWN0YW5nbGVcbiAgICAgICAgICAgIC8vIFN0YXJ0IGRyYXdpbmcgYSBSZWN0YW5nbGUuIElmIGBsYXRsbmdgIGlzIGdpdmVuLCB0aGUgUmVjdGFuZ2xlIGFuY2hvciB3aWxsIGJlIGFkZGVkLiBJbiBhbnkgY2FzZSwgY29udGludWluZyBvbiB1c2VyIGRyYWcuXG4gICAgICAgICAgICAvLyBJZiBgb3B0aW9uc2AgaXMgZ2l2ZW4sIGl0IHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBSZWN0YW5nbGUgY2xhc3MgY29uc3RydWN0b3IuXG4gICAgICAgICAgICBzdGFydFJlY3RhbmdsZTogZnVuY3Rpb24obGF0bG5nLCBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvcm5lciA9IGxhdGxuZyB8fCBMLmxhdExuZyhbMCwgMF0pO1xuICAgICAgICAgICAgICAgIHZhciBib3VuZHMgPSBuZXcgTC5MYXRMbmdCb3VuZHMoY29ybmVyLCBjb3JuZXIpO1xuICAgICAgICAgICAgICAgIHZhciByZWN0YW5nbGUgPSB0aGlzLmNyZWF0ZVJlY3RhbmdsZShib3VuZHMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHJlY3RhbmdsZS5lbmFibGVFZGl0KHRoaXMubWFwKS5zdGFydERyYXdpbmcoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjdGFuZ2xlO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8g8J+Ngm1ldGhvZCBzdGFydENpcmNsZShsYXRsbmc6IEwuTGF0TG5nLCBvcHRpb25zOiBoYXNoKTogTC5DaXJjbGVcbiAgICAgICAgICAgIC8vIFN0YXJ0IGRyYXdpbmcgYSBDaXJjbGUuIElmIGBsYXRsbmdgIGlzIGdpdmVuLCB0aGUgQ2lyY2xlIGFuY2hvciB3aWxsIGJlIGFkZGVkLiBJbiBhbnkgY2FzZSwgY29udGludWluZyBvbiB1c2VyIGRyYWcuXG4gICAgICAgICAgICAvLyBJZiBgb3B0aW9uc2AgaXMgZ2l2ZW4sIGl0IHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBDaXJjbGUgY2xhc3MgY29uc3RydWN0b3IuXG4gICAgICAgICAgICBzdGFydENpcmNsZTogZnVuY3Rpb24gKGxhdGxuZywgb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIGxhdGxuZyA9IGxhdGxuZyB8fCB0aGlzLm1hcC5nZXRDZW50ZXIoKS5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIHZhciBjaXJjbGUgPSB0aGlzLmNyZWF0ZUNpcmNsZShsYXRsbmcsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGNpcmNsZS5lbmFibGVFZGl0KHRoaXMubWFwKS5zdGFydERyYXdpbmcoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2lyY2xlO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc3RhcnRIb2xlOiBmdW5jdGlvbiAoZWRpdG9yLCBsYXRsbmcpIHtcbiAgICAgICAgICAgICAgICBlZGl0b3IubmV3SG9sZShsYXRsbmcpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgY3JlYXRlTGF5ZXI6IGZ1bmN0aW9uIChrbGFzcywgbGF0bG5ncywgb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBMLlV0aWwuZXh0ZW5kKHtlZGl0T3B0aW9uczoge2VkaXRUb29sczogdGhpc319LCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB2YXIgbGF5ZXIgPSBuZXcga2xhc3MobGF0bG5ncywgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgLy8g8J+Ngm5hbWVzcGFjZSBFZGl0YWJsZVxuICAgICAgICAgICAgICAgIC8vIPCfjYJldmVudCBlZGl0YWJsZTpjcmVhdGVkOiBMYXllckV2ZW50XG4gICAgICAgICAgICAgICAgLy8gRmlyZWQgd2hlbiBhIG5ldyBmZWF0dXJlIChNYXJrZXIsIFBvbHlsaW5l4oCmKSBpcyBjcmVhdGVkLlxuICAgICAgICAgICAgICAgIHRoaXMuZmlyZUFuZEZvcndhcmQoJ2VkaXRhYmxlOmNyZWF0ZWQnLCB7bGF5ZXI6IGxheWVyfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxheWVyO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgY3JlYXRlUG9seWxpbmU6IGZ1bmN0aW9uIChsYXRsbmdzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlTGF5ZXIob3B0aW9ucyAmJiBvcHRpb25zLnBvbHlsaW5lQ2xhc3MgfHwgdGhpcy5vcHRpb25zLnBvbHlsaW5lQ2xhc3MsIGxhdGxuZ3MsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgY3JlYXRlUG9seWdvbjogZnVuY3Rpb24gKGxhdGxuZ3MsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVMYXllcihvcHRpb25zICYmIG9wdGlvbnMucG9seWdvbkNsYXNzIHx8IHRoaXMub3B0aW9ucy5wb2x5Z29uQ2xhc3MsIGxhdGxuZ3MsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgY3JlYXRlTWFya2VyOiBmdW5jdGlvbiAobGF0bG5nLCBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlTGF5ZXIob3B0aW9ucyAmJiBvcHRpb25zLm1hcmtlckNsYXNzIHx8IHRoaXMub3B0aW9ucy5tYXJrZXJDbGFzcywgbGF0bG5nLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGNyZWF0ZVJlY3RhbmdsZTogZnVuY3Rpb24gKGJvdW5kcywgb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUxheWVyKG9wdGlvbnMgJiYgb3B0aW9ucy5yZWN0YW5nbGVDbGFzcyB8fCB0aGlzLm9wdGlvbnMucmVjdGFuZ2xlQ2xhc3MsIGJvdW5kcywgb3B0aW9ucyk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBjcmVhdGVDaXJjbGU6IGZ1bmN0aW9uIChsYXRsbmcsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVMYXllcihvcHRpb25zICYmIG9wdGlvbnMuY2lyY2xlQ2xhc3MgfHwgdGhpcy5vcHRpb25zLmNpcmNsZUNsYXNzLCBsYXRsbmcsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0pO1xuXG4gICAgICAgIEwuZXh0ZW5kKEwuRWRpdGFibGUsIHtcblxuICAgICAgICAgICAgbWFrZUNhbmNlbGxhYmxlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGUuY2FuY2VsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBlLl9jYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8g8J+Ngm5hbWVzcGFjZSBNYXA7IPCfjYJjbGFzcyBNYXBcbiAgICAgICAgLy8gTGVhZmxldC5FZGl0YWJsZSBhZGQgb3B0aW9ucyBhbmQgZXZlbnRzIHRvIHRoZSBgTC5NYXBgIG9iamVjdC5cbiAgICAgICAgLy8gU2VlIGBFZGl0YWJsZWAgZXZlbnRzIGZvciB0aGUgbGlzdCBvZiBldmVudHMgZmlyZWQgb24gdGhlIE1hcC5cbiAgICAgICAgLy8g8J+NgmV4YW1wbGVcbiAgICAgICAgLy9cbiAgICAgICAgLy8gYGBganNcbiAgICAgICAgLy8gdmFyIG1hcCA9IEwubWFwKCdtYXAnLCB7XG4gICAgICAgIC8vICBlZGl0YWJsZTogdHJ1ZSxcbiAgICAgICAgLy8gIGVkaXRPcHRpb25zOiB7XG4gICAgICAgIC8vICAgIOKAplxuICAgICAgICAvLyB9XG4gICAgICAgIC8vIH0pO1xuICAgICAgICAvLyBgYGBcbiAgICAgICAgLy8g8J+NgnNlY3Rpb24gRWRpdGFibGUgTWFwIE9wdGlvbnNcbiAgICAgICAgTC5NYXAubWVyZ2VPcHRpb25zKHtcblxuICAgICAgICAgICAgLy8g8J+Ngm5hbWVzcGFjZSBNYXBcbiAgICAgICAgICAgIC8vIPCfjYJzZWN0aW9uIE1hcCBPcHRpb25zXG4gICAgICAgICAgICAvLyDwn42Cb3B0aW9uIGVkaXRUb29sc0NsYXNzOiBjbGFzcyA9IEwuRWRpdGFibGVcbiAgICAgICAgICAgIC8vIENsYXNzIHRvIGJlIHVzZWQgYXMgdmVydGV4LCBmb3IgcGF0aCBlZGl0aW5nLlxuICAgICAgICAgICAgZWRpdFRvb2xzQ2xhc3M6IEwuRWRpdGFibGUsXG5cbiAgICAgICAgICAgIC8vIPCfjYJvcHRpb24gZWRpdGFibGU6IGJvb2xlYW4gPSBmYWxzZVxuICAgICAgICAgICAgLy8gV2hldGhlciB0byBjcmVhdGUgYSBMLkVkaXRhYmxlIGluc3RhbmNlIGF0IG1hcCBpbml0LlxuICAgICAgICAgICAgZWRpdGFibGU6IGZhbHNlLFxuXG4gICAgICAgICAgICAvLyDwn42Cb3B0aW9uIGVkaXRPcHRpb25zOiBoYXNoID0ge31cbiAgICAgICAgICAgIC8vIE9wdGlvbnMgdG8gcGFzcyB0byBMLkVkaXRhYmxlIHdoZW4gaW5zdGFudGlhdGluZy5cbiAgICAgICAgICAgIGVkaXRPcHRpb25zOiB7fVxuXG4gICAgICAgIH0pO1xuXG4gICAgICAgIEwuTWFwLmFkZEluaXRIb29rKGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgdGhpcy53aGVuUmVhZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWRpdGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lZGl0VG9vbHMgPSBuZXcgdGhpcy5vcHRpb25zLmVkaXRUb29sc0NsYXNzKHRoaXMsIHRoaXMub3B0aW9ucy5lZGl0T3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgTC5FZGl0YWJsZS5WZXJ0ZXhJY29uID0gTC5EaXZJY29uLmV4dGVuZCh7XG5cbiAgICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICBpY29uU2l6ZTogbmV3IEwuUG9pbnQoOCwgOClcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9KTtcblxuICAgICAgICBMLkVkaXRhYmxlLlRvdWNoVmVydGV4SWNvbiA9IEwuRWRpdGFibGUuVmVydGV4SWNvbi5leHRlbmQoe1xuXG4gICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgaWNvblNpemU6IG5ldyBMLlBvaW50KDIwLCAyMClcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9KTtcblxuXG4gICAgICAgIC8vIPCfjYJuYW1lc3BhY2UgRWRpdGFibGU7IPCfjYJjbGFzcyBWZXJ0ZXhNYXJrZXI7IEhhbmRsZXIgZm9yIGRyYWdnaW5nIHBhdGggdmVydGljZXMuXG4gICAgICAgIEwuRWRpdGFibGUuVmVydGV4TWFya2VyID0gTC5NYXJrZXIuZXh0ZW5kKHtcblxuICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICAgIGRyYWdnYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdsZWFmbGV0LWRpdi1pY29uIGxlYWZsZXQtdmVydGV4LWljb24nXG4gICAgICAgICAgICB9LFxuXG5cbiAgICAgICAgICAgIC8vIPCfjYJzZWN0aW9uIFB1YmxpYyBtZXRob2RzXG4gICAgICAgICAgICAvLyBUaGUgbWFya2VyIHVzZWQgdG8gaGFuZGxlIHBhdGggdmVydGV4LiBZb3Ugd2lsbCB1c3VhbGx5IGludGVyYWN0IHdpdGggYSBgVmVydGV4TWFya2VyYFxuICAgICAgICAgICAgLy8gaW5zdGFuY2Ugd2hlbiBsaXN0ZW5pbmcgZm9yIGV2ZW50cyBsaWtlIGBlZGl0YWJsZTp2ZXJ0ZXg6Y3RybGNsaWNrYC5cblxuICAgICAgICAgICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdGxuZywgbGF0bG5ncywgZWRpdG9yLCBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgZG9uJ3QgdXNlIHRoaXMuX2xhdGxuZywgYmVjYXVzZSBvbiBkcmFnIExlYWZsZXQgcmVwbGFjZSBpdCB3aGlsZVxuICAgICAgICAgICAgICAgIC8vIHdlIHdhbnQgdG8ga2VlcCByZWZlcmVuY2UuXG4gICAgICAgICAgICAgICAgdGhpcy5sYXRsbmcgPSBsYXRsbmc7XG4gICAgICAgICAgICAgICAgdGhpcy5sYXRsbmdzID0gbGF0bG5ncztcbiAgICAgICAgICAgICAgICB0aGlzLmVkaXRvciA9IGVkaXRvcjtcbiAgICAgICAgICAgICAgICBMLk1hcmtlci5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIGxhdGxuZywgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmljb24gPSB0aGlzLmVkaXRvci50b29scy5jcmVhdGVWZXJ0ZXhJY29uKHtjbGFzc05hbWU6IHRoaXMub3B0aW9ucy5jbGFzc05hbWV9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmxhdGxuZy5fX3ZlcnRleCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdGhpcy5lZGl0b3IuZWRpdExheWVyLmFkZExheWVyKHRoaXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0WkluZGV4T2Zmc2V0KGVkaXRvci50b29scy5fbGFzdFpJbmRleCArIDEpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgb25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcbiAgICAgICAgICAgICAgICBMLk1hcmtlci5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzLCBtYXApO1xuICAgICAgICAgICAgICAgIHRoaXMub24oJ2RyYWcnLCB0aGlzLm9uRHJhZyk7XG4gICAgICAgICAgICAgICAgdGhpcy5vbignZHJhZ3N0YXJ0JywgdGhpcy5vbkRyYWdTdGFydCk7XG4gICAgICAgICAgICAgICAgdGhpcy5vbignZHJhZ2VuZCcsIHRoaXMub25EcmFnRW5kKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uKCdtb3VzZXVwJywgdGhpcy5vbk1vdXNldXApO1xuICAgICAgICAgICAgICAgIHRoaXMub24oJ2NsaWNrJywgdGhpcy5vbkNsaWNrKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uKCdjb250ZXh0bWVudScsIHRoaXMub25Db250ZXh0TWVudSk7XG4gICAgICAgICAgICAgICAgdGhpcy5vbignbW91c2Vkb3duIHRvdWNoc3RhcnQnLCB0aGlzLm9uTW91c2VEb3duKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uKCdtb3VzZW92ZXInLCB0aGlzLm9uTW91c2VPdmVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uKCdtb3VzZW91dCcsIHRoaXMub25Nb3VzZU91dCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRNaWRkbGVNYXJrZXJzKCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1pZGRsZU1hcmtlcikgdGhpcy5taWRkbGVNYXJrZXIuZGVsZXRlKCk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMubGF0bG5nLl9fdmVydGV4O1xuICAgICAgICAgICAgICAgIHRoaXMub2ZmKCdkcmFnJywgdGhpcy5vbkRyYWcpO1xuICAgICAgICAgICAgICAgIHRoaXMub2ZmKCdkcmFnc3RhcnQnLCB0aGlzLm9uRHJhZ1N0YXJ0KTtcbiAgICAgICAgICAgICAgICB0aGlzLm9mZignZHJhZ2VuZCcsIHRoaXMub25EcmFnRW5kKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9mZignbW91c2V1cCcsIHRoaXMub25Nb3VzZXVwKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9mZignY2xpY2snLCB0aGlzLm9uQ2xpY2spO1xuICAgICAgICAgICAgICAgIHRoaXMub2ZmKCdjb250ZXh0bWVudScsIHRoaXMub25Db250ZXh0TWVudSk7XG4gICAgICAgICAgICAgICAgdGhpcy5vZmYoJ21vdXNlZG93biB0b3VjaHN0YXJ0JywgdGhpcy5vbk1vdXNlRG93bik7XG4gICAgICAgICAgICAgICAgdGhpcy5vZmYoJ21vdXNlb3ZlcicsIHRoaXMub25Nb3VzZU92ZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMub2ZmKCdtb3VzZW91dCcsIHRoaXMub25Nb3VzZU91dCk7XG4gICAgICAgICAgICAgICAgTC5NYXJrZXIucHJvdG90eXBlLm9uUmVtb3ZlLmNhbGwodGhpcywgbWFwKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIG9uRHJhZzogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBlLnZlcnRleCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdGhpcy5lZGl0b3Iub25WZXJ0ZXhNYXJrZXJEcmFnKGUpO1xuICAgICAgICAgICAgICAgIHZhciBpY29uUG9zID0gTC5Eb21VdGlsLmdldFBvc2l0aW9uKHRoaXMuX2ljb24pLFxuICAgICAgICAgICAgICAgICAgICBsYXRsbmcgPSB0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKGljb25Qb3MpO1xuICAgICAgICAgICAgICAgIHRoaXMubGF0bG5nLnVwZGF0ZShsYXRsbmcpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xhdGxuZyA9IHRoaXMubGF0bG5nOyAgLy8gUHVzaCBiYWNrIHRvIExlYWZsZXQgb3VyIHJlZmVyZW5jZS5cbiAgICAgICAgICAgICAgICB0aGlzLmVkaXRvci5yZWZyZXNoKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubWlkZGxlTWFya2VyKSB0aGlzLm1pZGRsZU1hcmtlci51cGRhdGVMYXRMbmcoKTtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dCA9IHRoaXMuZ2V0TmV4dCgpO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0ICYmIG5leHQubWlkZGxlTWFya2VyKSBuZXh0Lm1pZGRsZU1hcmtlci51cGRhdGVMYXRMbmcoKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIG9uRHJhZ1N0YXJ0OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGUudmVydGV4ID0gdGhpcztcbiAgICAgICAgICAgICAgICB0aGlzLmVkaXRvci5vblZlcnRleE1hcmtlckRyYWdTdGFydChlKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIG9uRHJhZ0VuZDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBlLnZlcnRleCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdGhpcy5lZGl0b3Iub25WZXJ0ZXhNYXJrZXJEcmFnRW5kKGUpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgb25DbGljazogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBlLnZlcnRleCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdGhpcy5lZGl0b3Iub25WZXJ0ZXhNYXJrZXJDbGljayhlKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIG9uTW91c2V1cDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBMLkRvbUV2ZW50LnN0b3AoZSk7XG4gICAgICAgICAgICAgICAgZS52ZXJ0ZXggPSB0aGlzO1xuICAgICAgICAgICAgICAgIHRoaXMuZWRpdG9yLm1hcC5maXJlKCdtb3VzZXVwJywgZSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBvbkNvbnRleHRNZW51OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIGUudmVydGV4ID0gdGhpcztcbiAgICAgICAgICAgICAgICB0aGlzLmVkaXRvci5vblZlcnRleE1hcmtlckNvbnRleHRNZW51KGUpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgb25Nb3VzZURvd246IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgZS52ZXJ0ZXggPSB0aGlzO1xuICAgICAgICAgICAgICAgIHRoaXMuZWRpdG9yLm9uVmVydGV4TWFya2VyTW91c2VEb3duKGUpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgb25Nb3VzZU92ZXI6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgZS52ZXJ0ZXggPSB0aGlzO1xuICAgICAgICAgICAgICAgIHRoaXMuZWRpdG9yLm9uVmVydGV4TWFya2VyTW91c2VPdmVyKGUpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgb25Nb3VzZU91dDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBlLnZlcnRleCA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdGhpcy5lZGl0b3Iub25WZXJ0ZXhNYXJrZXJNb3VzZU91dChlKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIPCfjYJtZXRob2QgZGVsZXRlKClcbiAgICAgICAgICAgIC8vIERlbGV0ZSBhIHZlcnRleCBhbmQgdGhlIHJlbGF0ZWQgTGF0TG5nLlxuICAgICAgICAgICAgZGVsZXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5leHQgPSB0aGlzLmdldE5leHQoKTsgIC8vIENvbXB1dGUgYmVmb3JlIGNoYW5naW5nIGxhdGxuZ1xuICAgICAgICAgICAgICAgIHRoaXMubGF0bG5ncy5zcGxpY2UodGhpcy5nZXRJbmRleCgpLCAxKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVkaXRvci5lZGl0TGF5ZXIucmVtb3ZlTGF5ZXIodGhpcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5lZGl0b3Iub25WZXJ0ZXhEZWxldGVkKHtsYXRsbmc6IHRoaXMubGF0bG5nLCB2ZXJ0ZXg6IHRoaXN9KTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMubGF0bG5ncy5sZW5ndGgpIHRoaXMuZWRpdG9yLmRlbGV0ZVNoYXBlKHRoaXMubGF0bG5ncyk7XG4gICAgICAgICAgICAgICAgaWYgKG5leHQpIG5leHQucmVzZXRNaWRkbGVNYXJrZXIoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVkaXRvci5yZWZyZXNoKCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyDwn42CbWV0aG9kIGdldEluZGV4KCk6IGludFxuICAgICAgICAgICAgLy8gR2V0IHRoZSBpbmRleCBvZiB0aGUgY3VycmVudCB2ZXJ0ZXggYW1vbmcgb3RoZXJzIG9mIHRoZSBzYW1lIExhdExuZ3MgZ3JvdXAuXG4gICAgICAgICAgICBnZXRJbmRleDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxhdGxuZ3MuaW5kZXhPZih0aGlzLmxhdGxuZyk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyDwn42CbWV0aG9kIGdldExhc3RJbmRleCgpOiBpbnRcbiAgICAgICAgICAgIC8vIEdldCBsYXN0IHZlcnRleCBpbmRleCBvZiB0aGUgTGF0TG5ncyBncm91cCBvZiB0aGUgY3VycmVudCB2ZXJ0ZXguXG4gICAgICAgICAgICBnZXRMYXN0SW5kZXg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sYXRsbmdzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyDwn42CbWV0aG9kIGdldFByZXZpb3VzKCk6IFZlcnRleE1hcmtlclxuICAgICAgICAgICAgLy8gR2V0IHRoZSBwcmV2aW91cyBWZXJ0ZXhNYXJrZXIgaW4gdGhlIHNhbWUgTGF0TG5ncyBncm91cC5cbiAgICAgICAgICAgIGdldFByZXZpb3VzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGF0bG5ncy5sZW5ndGggPCAyKSByZXR1cm47XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5nZXRJbmRleCgpLFxuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c0luZGV4ID0gaW5kZXggLSAxO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gMCAmJiB0aGlzLmVkaXRvci5DTE9TRUQpIHByZXZpb3VzSW5kZXggPSB0aGlzLmdldExhc3RJbmRleCgpO1xuICAgICAgICAgICAgICAgIHZhciBwcmV2aW91cyA9IHRoaXMubGF0bG5nc1twcmV2aW91c0luZGV4XTtcbiAgICAgICAgICAgICAgICBpZiAocHJldmlvdXMpIHJldHVybiBwcmV2aW91cy5fX3ZlcnRleDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIPCfjYJtZXRob2QgZ2V0TmV4dCgpOiBWZXJ0ZXhNYXJrZXJcbiAgICAgICAgICAgIC8vIEdldCB0aGUgbmV4dCBWZXJ0ZXhNYXJrZXIgaW4gdGhlIHNhbWUgTGF0TG5ncyBncm91cC5cbiAgICAgICAgICAgIGdldE5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sYXRsbmdzLmxlbmd0aCA8IDIpIHJldHVybjtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmdldEluZGV4KCksXG4gICAgICAgICAgICAgICAgICAgIG5leHRJbmRleCA9IGluZGV4ICsgMTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IHRoaXMuZ2V0TGFzdEluZGV4KCkgJiYgdGhpcy5lZGl0b3IuQ0xPU0VEKSBuZXh0SW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gdGhpcy5sYXRsbmdzW25leHRJbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKG5leHQpIHJldHVybiBuZXh0Ll9fdmVydGV4O1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgYWRkTWlkZGxlTWFya2VyOiBmdW5jdGlvbiAocHJldmlvdXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZWRpdG9yLmhhc01pZGRsZU1hcmtlcnMoKSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHByZXZpb3VzID0gcHJldmlvdXMgfHwgdGhpcy5nZXRQcmV2aW91cygpO1xuICAgICAgICAgICAgICAgIGlmIChwcmV2aW91cyAmJiAhdGhpcy5taWRkbGVNYXJrZXIpIHRoaXMubWlkZGxlTWFya2VyID0gdGhpcy5lZGl0b3IuYWRkTWlkZGxlTWFya2VyKHByZXZpb3VzLCB0aGlzLCB0aGlzLmxhdGxuZ3MsIHRoaXMuZWRpdG9yKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGFkZE1pZGRsZU1hcmtlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZWRpdG9yLmhhc01pZGRsZU1hcmtlcnMoKSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHZhciBwcmV2aW91cyA9IHRoaXMuZ2V0UHJldmlvdXMoKTtcbiAgICAgICAgICAgICAgICBpZiAocHJldmlvdXMpIHRoaXMuYWRkTWlkZGxlTWFya2VyKHByZXZpb3VzKTtcbiAgICAgICAgICAgICAgICB2YXIgbmV4dCA9IHRoaXMuZ2V0TmV4dCgpO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0KSBuZXh0LnJlc2V0TWlkZGxlTWFya2VyKCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICByZXNldE1pZGRsZU1hcmtlcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1pZGRsZU1hcmtlcikgdGhpcy5taWRkbGVNYXJrZXIuZGVsZXRlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRNaWRkbGVNYXJrZXIoKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIPCfjYJtZXRob2Qgc3BsaXQoKVxuICAgICAgICAgICAgLy8gU3BsaXQgdGhlIHZlcnRleCBMYXRMbmdzIGdyb3VwIGF0IGl0cyBpbmRleCwgaWYgcG9zc2libGUuXG4gICAgICAgICAgICBzcGxpdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5lZGl0b3Iuc3BsaXRTaGFwZSkgcmV0dXJuOyAgLy8gT25seSBmb3IgUG9seWxpbmVFZGl0b3JcbiAgICAgICAgICAgICAgICB0aGlzLmVkaXRvci5zcGxpdFNoYXBlKHRoaXMubGF0bG5ncywgdGhpcy5nZXRJbmRleCgpKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIPCfjYJtZXRob2QgY29udGludWUoKVxuICAgICAgICAgICAgLy8gQ29udGludWUgdGhlIHZlcnRleCBMYXRMbmdzIGZyb20gdGhpcyB2ZXJ0ZXguIE9ubHkgYWN0aXZlIGZvciBmaXJzdCBhbmQgbGFzdCB2ZXJ0aWNlcyBvZiBhIFBvbHlsaW5lLlxuICAgICAgICAgICAgY29udGludWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZWRpdG9yLmNvbnRpbnVlQmFja3dhcmQpIHJldHVybjsgIC8vIE9ubHkgZm9yIFBvbHlsaW5lRWRpdG9yXG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5nZXRJbmRleCgpO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gMCkgdGhpcy5lZGl0b3IuY29udGludWVCYWNrd2FyZCh0aGlzLmxhdGxuZ3MpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGluZGV4ID09PSB0aGlzLmdldExhc3RJbmRleCgpKSB0aGlzLmVkaXRvci5jb250aW51ZUZvcndhcmQodGhpcy5sYXRsbmdzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9KTtcblxuICAgICAgICBMLkVkaXRhYmxlLm1lcmdlT3B0aW9ucyh7XG5cbiAgICAgICAgICAgIC8vIPCfjYJuYW1lc3BhY2UgRWRpdGFibGVcbiAgICAgICAgICAgIC8vIPCfjYJvcHRpb24gdmVydGV4TWFya2VyQ2xhc3M6IGNsYXNzID0gVmVydGV4TWFya2VyXG4gICAgICAgICAgICAvLyBDbGFzcyB0byBiZSB1c2VkIGFzIHZlcnRleCwgZm9yIHBhdGggZWRpdGluZy5cbiAgICAgICAgICAgIHZlcnRleE1hcmtlckNsYXNzOiBMLkVkaXRhYmxlLlZlcnRleE1hcmtlclxuXG4gICAgICAgIH0pO1xuXG4gICAgICAgIEwuRWRpdGFibGUuTWlkZGxlTWFya2VyID0gTC5NYXJrZXIuZXh0ZW5kKHtcblxuICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAuNSxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdsZWFmbGV0LWRpdi1pY29uIGxlYWZsZXQtbWlkZGxlLWljb24nLFxuICAgICAgICAgICAgICAgIGRyYWdnYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxlZnQsIHJpZ2h0LCBsYXRsbmdzLCBlZGl0b3IsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgICAgICAgICAgICAgIHRoaXMucmlnaHQgPSByaWdodDtcbiAgICAgICAgICAgICAgICB0aGlzLmVkaXRvciA9IGVkaXRvcjtcbiAgICAgICAgICAgICAgICB0aGlzLmxhdGxuZ3MgPSBsYXRsbmdzO1xuICAgICAgICAgICAgICAgIEwuTWFya2VyLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgdGhpcy5jb21wdXRlTGF0TG5nKCksIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX29wYWNpdHkgPSB0aGlzLm9wdGlvbnMub3BhY2l0eTtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuaWNvbiA9IHRoaXMuZWRpdG9yLnRvb2xzLmNyZWF0ZVZlcnRleEljb24oe2NsYXNzTmFtZTogdGhpcy5vcHRpb25zLmNsYXNzTmFtZX0pO1xuICAgICAgICAgICAgICAgIHRoaXMuZWRpdG9yLmVkaXRMYXllci5hZGRMYXllcih0aGlzKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFZpc2liaWxpdHkoKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNldFZpc2liaWxpdHk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGVmdFBvaW50ID0gdGhpcy5fbWFwLmxhdExuZ1RvQ29udGFpbmVyUG9pbnQodGhpcy5sZWZ0LmxhdGxuZyksXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0UG9pbnQgPSB0aGlzLl9tYXAubGF0TG5nVG9Db250YWluZXJQb2ludCh0aGlzLnJpZ2h0LmxhdGxuZyksXG4gICAgICAgICAgICAgICAgICAgIHNpemUgPSBMLnBvaW50KHRoaXMub3B0aW9ucy5pY29uLm9wdGlvbnMuaWNvblNpemUpO1xuICAgICAgICAgICAgICAgIGlmIChsZWZ0UG9pbnQuZGlzdGFuY2VUbyhyaWdodFBvaW50KSA8IHNpemUueCAqIDMpIHRoaXMuaGlkZSgpO1xuICAgICAgICAgICAgICAgIGVsc2UgdGhpcy5zaG93KCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzaG93OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRPcGFjaXR5KHRoaXMuX29wYWNpdHkpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgaGlkZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0T3BhY2l0eSgwKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHVwZGF0ZUxhdExuZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0TGF0TG5nKHRoaXMuY29tcHV0ZUxhdExuZygpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFZpc2liaWxpdHkoKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGNvbXB1dGVMYXRMbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGVmdFBvaW50ID0gdGhpcy5lZGl0b3IubWFwLmxhdExuZ1RvQ29udGFpbmVyUG9pbnQodGhpcy5sZWZ0LmxhdGxuZyksXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0UG9pbnQgPSB0aGlzLmVkaXRvci5tYXAubGF0TG5nVG9Db250YWluZXJQb2ludCh0aGlzLnJpZ2h0LmxhdGxuZyksXG4gICAgICAgICAgICAgICAgICAgIHkgPSAobGVmdFBvaW50LnkgKyByaWdodFBvaW50LnkpIC8gMixcbiAgICAgICAgICAgICAgICAgICAgeCA9IChsZWZ0UG9pbnQueCArIHJpZ2h0UG9pbnQueCkgLyAyO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVkaXRvci5tYXAuY29udGFpbmVyUG9pbnRUb0xhdExuZyhbeCwgeV0pO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgb25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcbiAgICAgICAgICAgICAgICBMLk1hcmtlci5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzLCBtYXApO1xuICAgICAgICAgICAgICAgIEwuRG9tRXZlbnQub24odGhpcy5faWNvbiwgJ21vdXNlZG93biB0b3VjaHN0YXJ0JywgdGhpcy5vbk1vdXNlRG93biwgdGhpcyk7XG4gICAgICAgICAgICAgICAgbWFwLm9uKCd6b29tZW5kJywgdGhpcy5zZXRWaXNpYmlsaXR5LCB0aGlzKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMucmlnaHQubWlkZGxlTWFya2VyO1xuICAgICAgICAgICAgICAgIEwuRG9tRXZlbnQub2ZmKHRoaXMuX2ljb24sICdtb3VzZWRvd24gdG91Y2hzdGFydCcsIHRoaXMub25Nb3VzZURvd24sIHRoaXMpO1xuICAgICAgICAgICAgICAgIG1hcC5vZmYoJ3pvb21lbmQnLCB0aGlzLnNldFZpc2liaWxpdHksIHRoaXMpO1xuICAgICAgICAgICAgICAgIEwuTWFya2VyLnByb3RvdHlwZS5vblJlbW92ZS5jYWxsKHRoaXMsIG1hcCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBvbk1vdXNlRG93bjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgaWNvblBvcyA9IEwuRG9tVXRpbC5nZXRQb3NpdGlvbih0aGlzLl9pY29uKSxcbiAgICAgICAgICAgICAgICAgICAgbGF0bG5nID0gdGhpcy5lZGl0b3IubWFwLmxheWVyUG9pbnRUb0xhdExuZyhpY29uUG9zKTtcbiAgICAgICAgICAgICAgICBlID0ge1xuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBlLFxuICAgICAgICAgICAgICAgICAgICBsYXRsbmc6IGxhdGxuZ1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5vcGFjaXR5ID09PSAwKSByZXR1cm47XG4gICAgICAgICAgICAgICAgTC5FZGl0YWJsZS5tYWtlQ2FuY2VsbGFibGUoZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5lZGl0b3Iub25NaWRkbGVNYXJrZXJNb3VzZURvd24oZSk7XG4gICAgICAgICAgICAgICAgaWYgKGUuX2NhbmNlbGxlZCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHRoaXMubGF0bG5ncy5zcGxpY2UodGhpcy5pbmRleCgpLCAwLCBlLmxhdGxuZyk7XG4gICAgICAgICAgICAgICAgdGhpcy5lZGl0b3IucmVmcmVzaCgpO1xuICAgICAgICAgICAgICAgIHZhciBpY29uID0gdGhpcy5faWNvbjtcbiAgICAgICAgICAgICAgICB2YXIgbWFya2VyID0gdGhpcy5lZGl0b3IuYWRkVmVydGV4TWFya2VyKGUubGF0bG5nLCB0aGlzLmxhdGxuZ3MpO1xuICAgICAgICAgICAgICAgIHRoaXMuZWRpdG9yLm9uTmV3VmVydGV4KG1hcmtlcik7XG4gICAgICAgICAgICAgICAgLyogSGFjayB0byB3b3JrYXJvdW5kIGJyb3dzZXIgbm90IGZpcmluZyB0b3VjaGVuZCB3aGVuIGVsZW1lbnQgaXMgbm8gbW9yZSBvbiBET00gKi9cbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gbWFya2VyLl9pY29uLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKG1hcmtlci5faWNvbik7XG4gICAgICAgICAgICAgICAgbWFya2VyLl9pY29uID0gaWNvbjtcbiAgICAgICAgICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQobWFya2VyLl9pY29uKTtcbiAgICAgICAgICAgICAgICBtYXJrZXIuX2luaXRJY29uKCk7XG4gICAgICAgICAgICAgICAgbWFya2VyLl9pbml0SW50ZXJhY3Rpb24oKTtcbiAgICAgICAgICAgICAgICBtYXJrZXIuc2V0T3BhY2l0eSgxKTtcbiAgICAgICAgICAgICAgICAvKiBFbmQgaGFjayAqL1xuICAgICAgICAgICAgICAgIC8vIFRyYW5zZmVyIG9uZ29pbmcgZHJhZ2dpbmcgdG8gcmVhbCBtYXJrZXJcbiAgICAgICAgICAgICAgICBMLkRyYWdnYWJsZS5fZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBtYXJrZXIuZHJhZ2dpbmcuX2RyYWdnYWJsZS5fb25Eb3duKGUub3JpZ2luYWxFdmVudCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWxldGUoKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGRlbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZWRpdG9yLmVkaXRMYXllci5yZW1vdmVMYXllcih0aGlzKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGluZGV4OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubGF0bG5ncy5pbmRleE9mKHRoaXMucmlnaHQubGF0bG5nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9KTtcblxuICAgICAgICBMLkVkaXRhYmxlLm1lcmdlT3B0aW9ucyh7XG5cbiAgICAgICAgICAgIC8vIPCfjYJuYW1lc3BhY2UgRWRpdGFibGVcbiAgICAgICAgICAgIC8vIPCfjYJvcHRpb24gbWlkZGxlTWFya2VyQ2xhc3M6IGNsYXNzID0gVmVydGV4TWFya2VyXG4gICAgICAgICAgICAvLyBDbGFzcyB0byBiZSB1c2VkIGFzIG1pZGRsZSB2ZXJ0ZXgsIHB1bGxlZCBieSB0aGUgdXNlciB0byBjcmVhdGUgYSBuZXcgcG9pbnQgaW4gdGhlIG1pZGRsZSBvZiBhIHBhdGguXG4gICAgICAgICAgICBtaWRkbGVNYXJrZXJDbGFzczogTC5FZGl0YWJsZS5NaWRkbGVNYXJrZXJcblxuICAgICAgICB9KTtcblxuICAgICAgICAvLyDwn42CbmFtZXNwYWNlIEVkaXRhYmxlOyDwn42CY2xhc3MgQmFzZUVkaXRvcjsg8J+NgmFrYSBMLkVkaXRhYmxlLkJhc2VFZGl0b3JcbiAgICAgICAgLy8gV2hlbiBlZGl0aW5nIGEgZmVhdHVyZSAoTWFya2VyLCBQb2x5bGluZeKApiksIGFuIGVkaXRvciBpcyBhdHRhY2hlZCB0byBpdC4gVGhpc1xuICAgICAgICAvLyBlZGl0b3IgYmFzaWNhbGx5IGtub3dzIGhvdyB0byBoYW5kbGUgdGhlIGVkaXRpb24uXG4gICAgICAgIEwuRWRpdGFibGUuQmFzZUVkaXRvciA9IEwuSGFuZGxlci5leHRlbmQoe1xuXG4gICAgICAgICAgICBpbml0aWFsaXplOiBmdW5jdGlvbiAobWFwLCBmZWF0dXJlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgTC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHRoaXMubWFwID0gbWFwO1xuICAgICAgICAgICAgICAgIHRoaXMuZmVhdHVyZSA9IGZlYXR1cmU7XG4gICAgICAgICAgICAgICAgdGhpcy5mZWF0dXJlLmVkaXRvciA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdGhpcy5lZGl0TGF5ZXIgPSBuZXcgTC5MYXllckdyb3VwKCk7XG4gICAgICAgICAgICAgICAgdGhpcy50b29scyA9IHRoaXMub3B0aW9ucy5lZGl0VG9vbHMgfHwgbWFwLmVkaXRUb29scztcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIPCfjYJtZXRob2QgZW5hYmxlKCk6IHRoaXNcbiAgICAgICAgICAgIC8vIFNldCB1cCB0aGUgZHJhd2luZyB0b29scyBmb3IgdGhlIGZlYXR1cmUgdG8gYmUgZWRpdGFibGUuXG4gICAgICAgICAgICBhZGRIb29rczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzQ29ubmVjdGVkKCkpIHRoaXMub25GZWF0dXJlQWRkKCk7XG4gICAgICAgICAgICAgICAgZWxzZSB0aGlzLmZlYXR1cmUub25jZSgnYWRkJywgdGhpcy5vbkZlYXR1cmVBZGQsIHRoaXMpO1xuICAgICAgICAgICAgICAgIHRoaXMub25FbmFibGUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZlYXR1cmUub24odGhpcy5fZ2V0RXZlbnRzKCksIHRoaXMpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8g8J+Ngm1ldGhvZCBkaXNhYmxlKCk6IHRoaXNcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgZHJhd2luZyB0b29scyBmb3IgdGhlIGZlYXR1cmUuXG4gICAgICAgICAgICByZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmVhdHVyZS5vZmYodGhpcy5fZ2V0RXZlbnRzKCksIHRoaXMpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZlYXR1cmUuZHJhZ2dpbmcpIHRoaXMuZmVhdHVyZS5kcmFnZ2luZy5kaXNhYmxlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5lZGl0TGF5ZXIuY2xlYXJMYXllcnMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRvb2xzLmVkaXRMYXllci5yZW1vdmVMYXllcih0aGlzLmVkaXRMYXllcik7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkRpc2FibGUoKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZHJhd2luZykgdGhpcy5jYW5jZWxEcmF3aW5nKCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyDwn42CbWV0aG9kIGRyYXdpbmcoKTogYm9vbGVhblxuICAgICAgICAgICAgLy8gUmV0dXJuIHRydWUgaWYgYW55IGRyYXdpbmcgYWN0aW9uIGlzIG9uZ29pbmcgd2l0aCB0aGlzIGVkaXRvci5cbiAgICAgICAgICAgIGRyYXdpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gISF0aGlzLl9kcmF3aW5nO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uICgpIHt9LFxuXG4gICAgICAgICAgICBvbkZlYXR1cmVBZGQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRvb2xzLmVkaXRMYXllci5hZGRMYXllcih0aGlzLmVkaXRMYXllcik7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmVhdHVyZS5kcmFnZ2luZykgdGhpcy5mZWF0dXJlLmRyYWdnaW5nLmVuYWJsZSgpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgaGFzTWlkZGxlTWFya2VyczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhdGhpcy5vcHRpb25zLnNraXBNaWRkbGVNYXJrZXJzICYmICF0aGlzLnRvb2xzLm9wdGlvbnMuc2tpcE1pZGRsZU1hcmtlcnM7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBmaXJlQW5kRm9yd2FyZDogZnVuY3Rpb24gKHR5cGUsIGUpIHtcbiAgICAgICAgICAgICAgICBlID0gZSB8fCB7fTtcbiAgICAgICAgICAgICAgICBlLmxheWVyID0gdGhpcy5mZWF0dXJlO1xuICAgICAgICAgICAgICAgIHRoaXMuZmVhdHVyZS5maXJlKHR5cGUsIGUpO1xuICAgICAgICAgICAgICAgIHRoaXMudG9vbHMuZmlyZUFuZEZvcndhcmQodHlwZSwgZSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBvbkVuYWJsZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vIPCfjYJuYW1lc3BhY2UgRWRpdGFibGVcbiAgICAgICAgICAgICAgICAvLyDwn42CZXZlbnQgZWRpdGFibGU6ZW5hYmxlOiBFdmVudFxuICAgICAgICAgICAgICAgIC8vIEZpcmVkIHdoZW4gYW4gZXhpc3RpbmcgZmVhdHVyZSBpcyByZWFkeSB0byBiZSBlZGl0ZWQuXG4gICAgICAgICAgICAgICAgdGhpcy5maXJlQW5kRm9yd2FyZCgnZWRpdGFibGU6ZW5hYmxlJyk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBvbkRpc2FibGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyDwn42CbmFtZXNwYWNlIEVkaXRhYmxlXG4gICAgICAgICAgICAgICAgLy8g8J+NgmV2ZW50IGVkaXRhYmxlOmRpc2FibGU6IEV2ZW50XG4gICAgICAgICAgICAgICAgLy8gRmlyZWQgd2hlbiBhbiBleGlzdGluZyBmZWF0dXJlIGlzIG5vdCByZWFkeSBhbnltb3JlIHRvIGJlIGVkaXRlZC5cbiAgICAgICAgICAgICAgICB0aGlzLmZpcmVBbmRGb3J3YXJkKCdlZGl0YWJsZTpkaXNhYmxlJyk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBvbkVkaXRpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyDwn42CbmFtZXNwYWNlIEVkaXRhYmxlXG4gICAgICAgICAgICAgICAgLy8g8J+NgmV2ZW50IGVkaXRhYmxlOmVkaXRpbmc6IEV2ZW50XG4gICAgICAgICAgICAgICAgLy8gRmlyZWQgYXMgc29vbiBhcyBhbnkgY2hhbmdlIGlzIG1hZGUgdG8gdGhlIGZlYXR1cmUgZ2VvbWV0cnkuXG4gICAgICAgICAgICAgICAgdGhpcy5maXJlQW5kRm9yd2FyZCgnZWRpdGFibGU6ZWRpdGluZycpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgb25TdGFydERyYXdpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyDwn42CbmFtZXNwYWNlIEVkaXRhYmxlXG4gICAgICAgICAgICAgICAgLy8g8J+NgnNlY3Rpb24gRHJhd2luZyBldmVudHNcbiAgICAgICAgICAgICAgICAvLyDwn42CZXZlbnQgZWRpdGFibGU6ZHJhd2luZzpzdGFydDogRXZlbnRcbiAgICAgICAgICAgICAgICAvLyBGaXJlZCB3aGVuIGEgZmVhdHVyZSBpcyB0byBiZSBkcmF3bi5cbiAgICAgICAgICAgICAgICB0aGlzLmZpcmVBbmRGb3J3YXJkKCdlZGl0YWJsZTpkcmF3aW5nOnN0YXJ0Jyk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBvbkVuZERyYXdpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyDwn42CbmFtZXNwYWNlIEVkaXRhYmxlXG4gICAgICAgICAgICAgICAgLy8g8J+NgnNlY3Rpb24gRHJhd2luZyBldmVudHNcbiAgICAgICAgICAgICAgICAvLyDwn42CZXZlbnQgZWRpdGFibGU6ZHJhd2luZzplbmQ6IEV2ZW50XG4gICAgICAgICAgICAgICAgLy8gRmlyZWQgd2hlbiBhIGZlYXR1cmUgaXMgbm90IGRyYXduIGFueW1vcmUuXG4gICAgICAgICAgICAgICAgdGhpcy5maXJlQW5kRm9yd2FyZCgnZWRpdGFibGU6ZHJhd2luZzplbmQnKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIG9uQ2FuY2VsRHJhd2luZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vIPCfjYJuYW1lc3BhY2UgRWRpdGFibGVcbiAgICAgICAgICAgICAgICAvLyDwn42Cc2VjdGlvbiBEcmF3aW5nIGV2ZW50c1xuICAgICAgICAgICAgICAgIC8vIPCfjYJldmVudCBlZGl0YWJsZTpkcmF3aW5nOmNhbmNlbDogRXZlbnRcbiAgICAgICAgICAgICAgICAvLyBGaXJlZCB3aGVuIHVzZXIgY2FuY2VsIGRyYXdpbmcgd2hpbGUgYSBmZWF0dXJlIGlzIGJlaW5nIGRyYXduLlxuICAgICAgICAgICAgICAgIHRoaXMuZmlyZUFuZEZvcndhcmQoJ2VkaXRhYmxlOmRyYXdpbmc6Y2FuY2VsJyk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBvbkNvbW1pdERyYXdpbmc6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgLy8g8J+Ngm5hbWVzcGFjZSBFZGl0YWJsZVxuICAgICAgICAgICAgICAgIC8vIPCfjYJzZWN0aW9uIERyYXdpbmcgZXZlbnRzXG4gICAgICAgICAgICAgICAgLy8g8J+NgmV2ZW50IGVkaXRhYmxlOmRyYXdpbmc6Y29tbWl0OiBFdmVudFxuICAgICAgICAgICAgICAgIC8vIEZpcmVkIHdoZW4gdXNlciBmaW5pc2ggZHJhd2luZyBhIGZlYXR1cmUuXG4gICAgICAgICAgICAgICAgdGhpcy5maXJlQW5kRm9yd2FyZCgnZWRpdGFibGU6ZHJhd2luZzpjb21taXQnLCBlKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIG9uRHJhd2luZ01vdXNlRG93bjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAvLyDwn42CbmFtZXNwYWNlIEVkaXRhYmxlXG4gICAgICAgICAgICAgICAgLy8g8J+NgnNlY3Rpb24gRHJhd2luZyBldmVudHNcbiAgICAgICAgICAgICAgICAvLyDwn42CZXZlbnQgZWRpdGFibGU6ZHJhd2luZzptb3VzZWRvd246IEV2ZW50XG4gICAgICAgICAgICAgICAgLy8gRmlyZWQgd2hlbiB1c2VyIGBtb3VzZWRvd25gIHdoaWxlIGRyYXdpbmcuXG4gICAgICAgICAgICAgICAgdGhpcy5maXJlQW5kRm9yd2FyZCgnZWRpdGFibGU6ZHJhd2luZzptb3VzZWRvd24nLCBlKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIG9uRHJhd2luZ01vdXNlVXA6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgLy8g8J+Ngm5hbWVzcGFjZSBFZGl0YWJsZVxuICAgICAgICAgICAgICAgIC8vIPCfjYJzZWN0aW9uIERyYXdpbmcgZXZlbnRzXG4gICAgICAgICAgICAgICAgLy8g8J+NgmV2ZW50IGVkaXRhYmxlOmRyYXdpbmc6bW91c2V1cDogRXZlbnRcbiAgICAgICAgICAgICAgICAvLyBGaXJlZCB3aGVuIHVzZXIgYG1vdXNldXBgIHdoaWxlIGRyYXdpbmcuXG4gICAgICAgICAgICAgICAgdGhpcy5maXJlQW5kRm9yd2FyZCgnZWRpdGFibGU6ZHJhd2luZzptb3VzZXVwJywgZSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzdGFydERyYXdpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2RyYXdpbmcpIHRoaXMuX2RyYXdpbmcgPSBMLkVkaXRhYmxlLkZPUldBUkQ7XG4gICAgICAgICAgICAgICAgdGhpcy50b29scy5yZWdpc3RlckZvckRyYXdpbmcodGhpcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5vblN0YXJ0RHJhd2luZygpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgY29tbWl0RHJhd2luZzogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uQ29tbWl0RHJhd2luZyhlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVuZERyYXdpbmcoKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGNhbmNlbERyYXdpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBjYWxsZWQgZHVyaW5nIGEgdmVydGV4IGRyYWcsIHRoZSB2ZXJ0ZXggd2lsbCBiZSByZW1vdmVkIGJlZm9yZVxuICAgICAgICAgICAgICAgIC8vIHRoZSBtb3VzZXVwIGZpcmVzIG9uIGl0LiBUaGlzIGlzIGEgd29ya2Fyb3VuZC4gTWF5YmUgYmV0dGVyIGZpeCBpc1xuICAgICAgICAgICAgICAgIC8vIFRvIGhhdmUgTC5EcmFnZ2FibGUgcmVzZXQgaXQncyBzdGF0dXMgb24gZGlzYWJsZSAoTGVhZmxldCBzaWRlKS5cbiAgICAgICAgICAgICAgICBMLkRyYWdnYWJsZS5fZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uQ2FuY2VsRHJhd2luZygpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW5kRHJhd2luZygpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZW5kRHJhd2luZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYXdpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLnRvb2xzLnVucmVnaXN0ZXJGb3JEcmF3aW5nKHRoaXMpO1xuICAgICAgICAgICAgICAgIHRoaXMub25FbmREcmF3aW5nKCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBvbkRyYXdpbmdDbGljazogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZHJhd2luZygpKSByZXR1cm47XG4gICAgICAgICAgICAgICAgTC5FZGl0YWJsZS5tYWtlQ2FuY2VsbGFibGUoZSk7XG4gICAgICAgICAgICAgICAgLy8g8J+Ngm5hbWVzcGFjZSBFZGl0YWJsZVxuICAgICAgICAgICAgICAgIC8vIPCfjYJzZWN0aW9uIERyYXdpbmcgZXZlbnRzXG4gICAgICAgICAgICAgICAgLy8g8J+NgmV2ZW50IGVkaXRhYmxlOmRyYXdpbmc6Y2xpY2s6IENhbmNlbGFibGVFdmVudFxuICAgICAgICAgICAgICAgIC8vIEZpcmVkIHdoZW4gdXNlciBgY2xpY2tgIHdoaWxlIGRyYXdpbmcsIGJlZm9yZSBhbnkgaW50ZXJuYWwgYWN0aW9uIGlzIGJlaW5nIHByb2Nlc3NlZC5cbiAgICAgICAgICAgICAgICB0aGlzLmZpcmVBbmRGb3J3YXJkKCdlZGl0YWJsZTpkcmF3aW5nOmNsaWNrJywgZSk7XG4gICAgICAgICAgICAgICAgaWYgKGUuX2NhbmNlbGxlZCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc0Nvbm5lY3RlZCgpKSB0aGlzLmNvbm5lY3QoZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzRHJhd2luZ0NsaWNrKGUpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgaXNDb25uZWN0ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tYXAuaGFzTGF5ZXIodGhpcy5mZWF0dXJlKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGNvbm5lY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRvb2xzLmNvbm5lY3RDcmVhdGVkVG9NYXAodGhpcy5mZWF0dXJlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRvb2xzLmVkaXRMYXllci5hZGRMYXllcih0aGlzLmVkaXRMYXllcik7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBvbk1vdmU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgLy8g8J+Ngm5hbWVzcGFjZSBFZGl0YWJsZVxuICAgICAgICAgICAgICAgIC8vIPCfjYJzZWN0aW9uIERyYXdpbmcgZXZlbnRzXG4gICAgICAgICAgICAgICAgLy8g8J+NgmV2ZW50IGVkaXRhYmxlOmRyYXdpbmc6bW92ZTogRXZlbnRcbiAgICAgICAgICAgICAgICAvLyBGaXJlZCB3aGVuIGBtb3ZlYCBtb3VzZSB3aGlsZSBkcmF3aW5nLCB3aGlsZSBkcmFnZ2luZyBhIG1hcmtlciwgYW5kIHdoaWxlIGRyYWdnaW5nIGEgdmVydGV4LlxuICAgICAgICAgICAgICAgIHRoaXMuZmlyZUFuZEZvcndhcmQoJ2VkaXRhYmxlOmRyYXdpbmc6bW92ZScsIGUpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgb25EcmF3aW5nTW91c2VNb3ZlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHRoaXMub25Nb3ZlKGUpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgX2dldEV2ZW50czogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRyYWdzdGFydDogdGhpcy5vbkRyYWdTdGFydCxcbiAgICAgICAgICAgICAgICAgICAgZHJhZzogdGhpcy5vbkRyYWcsXG4gICAgICAgICAgICAgICAgICAgIGRyYWdlbmQ6IHRoaXMub25EcmFnRW5kLFxuICAgICAgICAgICAgICAgICAgICByZW1vdmU6IHRoaXMuZGlzYWJsZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBvbkRyYWdTdGFydDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uRWRpdGluZygpO1xuICAgICAgICAgICAgICAgIC8vIPCfjYJuYW1lc3BhY2UgRWRpdGFibGVcbiAgICAgICAgICAgICAgICAvLyDwn42CZXZlbnQgZWRpdGFibGU6ZHJhZ3N0YXJ0OiBFdmVudFxuICAgICAgICAgICAgICAgIC8vIEZpcmVkIGJlZm9yZSBhIHBhdGggZmVhdHVyZSBpcyBkcmFnZ2VkLlxuICAgICAgICAgICAgICAgIHRoaXMuZmlyZUFuZEZvcndhcmQoJ2VkaXRhYmxlOmRyYWdzdGFydCcsIGUpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgb25EcmFnOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHRoaXMub25Nb3ZlKGUpO1xuICAgICAgICAgICAgICAgIC8vIPCfjYJuYW1lc3BhY2UgRWRpdGFibGVcbiAgICAgICAgICAgICAgICAvLyDwn42CZXZlbnQgZWRpdGFibGU6ZHJhZzogRXZlbnRcbiAgICAgICAgICAgICAgICAvLyBGaXJlZCB3aGVuIGEgcGF0aCBmZWF0dXJlIGlzIGJlaW5nIGRyYWdnZWQuXG4gICAgICAgICAgICAgICAgdGhpcy5maXJlQW5kRm9yd2FyZCgnZWRpdGFibGU6ZHJhZycsIGUpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgb25EcmFnRW5kOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIC8vIPCfjYJuYW1lc3BhY2UgRWRpdGFibGVcbiAgICAgICAgICAgICAgICAvLyDwn42CZXZlbnQgZWRpdGFibGU6ZHJhZ2VuZDogRXZlbnRcbiAgICAgICAgICAgICAgICAvLyBGaXJlZCBhZnRlciBhIHBhdGggZmVhdHVyZSBoYXMgYmVlbiBkcmFnZ2VkLlxuICAgICAgICAgICAgICAgIHRoaXMuZmlyZUFuZEZvcndhcmQoJ2VkaXRhYmxlOmRyYWdlbmQnLCBlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9KTtcblxuICAgICAgICAvLyDwn42CbmFtZXNwYWNlIEVkaXRhYmxlOyDwn42CY2xhc3MgTWFya2VyRWRpdG9yOyDwn42CYWthIEwuRWRpdGFibGUuTWFya2VyRWRpdG9yXG4gICAgICAgIC8vIPCfjYJpbmhlcml0cyBCYXNlRWRpdG9yXG4gICAgICAgIC8vIEVkaXRvciBmb3IgTWFya2VyLlxuICAgICAgICBMLkVkaXRhYmxlLk1hcmtlckVkaXRvciA9IEwuRWRpdGFibGUuQmFzZUVkaXRvci5leHRlbmQoe1xuXG4gICAgICAgICAgICBvbkRyYXdpbmdNb3VzZU1vdmU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgTC5FZGl0YWJsZS5CYXNlRWRpdG9yLnByb3RvdHlwZS5vbkRyYXdpbmdNb3VzZU1vdmUuY2FsbCh0aGlzLCBlKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZHJhd2luZykgdGhpcy5mZWF0dXJlLnNldExhdExuZyhlLmxhdGxuZyk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBwcm9jZXNzRHJhd2luZ0NsaWNrOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIC8vIPCfjYJuYW1lc3BhY2UgRWRpdGFibGVcbiAgICAgICAgICAgICAgICAvLyDwn42Cc2VjdGlvbiBEcmF3aW5nIGV2ZW50c1xuICAgICAgICAgICAgICAgIC8vIPCfjYJldmVudCBlZGl0YWJsZTpkcmF3aW5nOmNsaWNrZWQ6IEV2ZW50XG4gICAgICAgICAgICAgICAgLy8gRmlyZWQgd2hlbiB1c2VyIGBjbGlja2Agd2hpbGUgZHJhd2luZywgYWZ0ZXIgYWxsIGludGVybmFsIGFjdGlvbnMuXG4gICAgICAgICAgICAgICAgdGhpcy5maXJlQW5kRm9yd2FyZCgnZWRpdGFibGU6ZHJhd2luZzpjbGlja2VkJywgZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb21taXREcmF3aW5nKGUpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgY29ubmVjdDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBPbiB0b3VjaCwgdGhlIGxhdGxuZyBoYXMgbm90IGJlZW4gdXBkYXRlZCBiZWNhdXNlIHRoZXJlIGlzXG4gICAgICAgICAgICAgICAgLy8gbm8gbW91c2Vtb3ZlLlxuICAgICAgICAgICAgICAgIGlmIChlKSB0aGlzLmZlYXR1cmUuX2xhdGxuZyA9IGUubGF0bG5nO1xuICAgICAgICAgICAgICAgIEwuRWRpdGFibGUuQmFzZUVkaXRvci5wcm90b3R5cGUuY29ubmVjdC5jYWxsKHRoaXMsIGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIPCfjYJuYW1lc3BhY2UgRWRpdGFibGU7IPCfjYJjbGFzcyBQYXRoRWRpdG9yOyDwn42CYWthIEwuRWRpdGFibGUuUGF0aEVkaXRvclxuICAgICAgICAvLyDwn42CaW5oZXJpdHMgQmFzZUVkaXRvclxuICAgICAgICAvLyBCYXNlIGNsYXNzIGZvciBhbGwgcGF0aCBlZGl0b3JzLlxuICAgICAgICBMLkVkaXRhYmxlLlBhdGhFZGl0b3IgPSBMLkVkaXRhYmxlLkJhc2VFZGl0b3IuZXh0ZW5kKHtcblxuICAgICAgICAgICAgQ0xPU0VEOiBmYWxzZSxcbiAgICAgICAgICAgIE1JTl9WRVJURVg6IDIsXG5cbiAgICAgICAgICAgIGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgTC5FZGl0YWJsZS5CYXNlRWRpdG9yLnByb3RvdHlwZS5hZGRIb29rcy5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZlYXR1cmUpIHRoaXMuaW5pdFZlcnRleE1hcmtlcnMoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGluaXRWZXJ0ZXhNYXJrZXJzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5lbmFibGVkKCkpIHJldHVybjtcbiAgICAgICAgICAgICAgICBsYXRsbmdzID0gbGF0bG5ncyB8fCB0aGlzLmdldExhdExuZ3MoKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNGbGF0KGxhdGxuZ3MpKSB0aGlzLmFkZFZlcnRleE1hcmtlcnMobGF0bG5ncyk7XG4gICAgICAgICAgICAgICAgZWxzZSBmb3IgKHZhciBpID0gMDsgaSA8IGxhdGxuZ3MubGVuZ3RoOyBpKyspIHRoaXMuaW5pdFZlcnRleE1hcmtlcnMobGF0bG5nc1tpXSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXRMYXRMbmdzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmVhdHVyZS5nZXRMYXRMbmdzKCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyDwn42CbWV0aG9kIHJlc2V0KClcbiAgICAgICAgICAgIC8vIFJlYnVpbGQgZWRpdCBlbGVtZW50cyAoVmVydGV4LCBNaWRkbGVNYXJrZXIsIGV0Yy4pLlxuICAgICAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVkaXRMYXllci5jbGVhckxheWVycygpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5pdFZlcnRleE1hcmtlcnMoKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGFkZFZlcnRleE1hcmtlcjogZnVuY3Rpb24gKGxhdGxuZywgbGF0bG5ncykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdGhpcy50b29scy5vcHRpb25zLnZlcnRleE1hcmtlckNsYXNzKGxhdGxuZywgbGF0bG5ncywgdGhpcyk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBvbk5ld1ZlcnRleDogZnVuY3Rpb24gKHZlcnRleCkge1xuICAgICAgICAgICAgICAgIC8vIPCfjYJuYW1lc3BhY2UgRWRpdGFibGVcbiAgICAgICAgICAgICAgICAvLyDwn42Cc2VjdGlvbiBWZXJ0ZXggZXZlbnRzXG4gICAgICAgICAgICAgICAgLy8g8J+NgmV2ZW50IGVkaXRhYmxlOnZlcnRleDpuZXc6IFZlcnRleEV2ZW50XG4gICAgICAgICAgICAgICAgLy8gRmlyZWQgd2hlbiBhIG5ldyB2ZXJ0ZXggaXMgY3JlYXRlZC5cbiAgICAgICAgICAgICAgICB0aGlzLmZpcmVBbmRGb3J3YXJkKCdlZGl0YWJsZTp2ZXJ0ZXg6bmV3Jywge2xhdGxuZzogdmVydGV4LmxhdGxuZywgdmVydGV4OiB2ZXJ0ZXh9KTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGFkZFZlcnRleE1hcmtlcnM6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXRsbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkVmVydGV4TWFya2VyKGxhdGxuZ3NbaV0sIGxhdGxuZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHJlZnJlc2hWZXJ0ZXhNYXJrZXJzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuICAgICAgICAgICAgICAgIGxhdGxuZ3MgPSBsYXRsbmdzIHx8IHRoaXMuZ2V0RGVmYXVsdExhdExuZ3MoKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhdGxuZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGF0bG5nc1tpXS5fX3ZlcnRleC51cGRhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBhZGRNaWRkbGVNYXJrZXI6IGZ1bmN0aW9uIChsZWZ0LCByaWdodCwgbGF0bG5ncykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdGhpcy50b29scy5vcHRpb25zLm1pZGRsZU1hcmtlckNsYXNzKGxlZnQsIHJpZ2h0LCBsYXRsbmdzLCB0aGlzKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIG9uVmVydGV4TWFya2VyQ2xpY2s6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgTC5FZGl0YWJsZS5tYWtlQ2FuY2VsbGFibGUoZSk7XG4gICAgICAgICAgICAgICAgLy8g8J+Ngm5hbWVzcGFjZSBFZGl0YWJsZVxuICAgICAgICAgICAgICAgIC8vIPCfjYJzZWN0aW9uIFZlcnRleCBldmVudHNcbiAgICAgICAgICAgICAgICAvLyDwn42CZXZlbnQgZWRpdGFibGU6dmVydGV4OmNsaWNrOiBDYW5jZWxhYmxlVmVydGV4RXZlbnRcbiAgICAgICAgICAgICAgICAvLyBGaXJlZCB3aGVuIGEgYGNsaWNrYCBpcyBpc3N1ZWQgb24gYSB2ZXJ0ZXgsIGJlZm9yZSBhbnkgaW50ZXJuYWwgYWN0aW9uIGlzIGJlaW5nIHByb2Nlc3NlZC5cbiAgICAgICAgICAgICAgICB0aGlzLmZpcmVBbmRGb3J3YXJkKCdlZGl0YWJsZTp2ZXJ0ZXg6Y2xpY2snLCBlKTtcbiAgICAgICAgICAgICAgICBpZiAoZS5fY2FuY2VsbGVkKSByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudG9vbHMuZHJhd2luZygpICYmIHRoaXMudG9vbHMuX2RyYXdpbmdFZGl0b3IgIT09IHRoaXMpIHJldHVybjtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBlLnZlcnRleC5nZXRJbmRleCgpLCBjb21taXQ7XG4gICAgICAgICAgICAgICAgaWYgKGUub3JpZ2luYWxFdmVudC5jdHJsS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25WZXJ0ZXhNYXJrZXJDdHJsQ2xpY2soZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlLm9yaWdpbmFsRXZlbnQuYWx0S2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25WZXJ0ZXhNYXJrZXJBbHRDbGljayhlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGUub3JpZ2luYWxFdmVudC5zaGlmdEtleSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uVmVydGV4TWFya2VyU2hpZnRDbGljayhlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGUub3JpZ2luYWxFdmVudC5tZXRhS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25WZXJ0ZXhNYXJrZXJNZXRhS2V5Q2xpY2soZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpbmRleCA9PT0gZS52ZXJ0ZXguZ2V0TGFzdEluZGV4KCkgJiYgdGhpcy5fZHJhd2luZyA9PT0gTC5FZGl0YWJsZS5GT1JXQVJEKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA+PSB0aGlzLk1JTl9WRVJURVggLSAxKSBjb21taXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPT09IDAgJiYgdGhpcy5fZHJhd2luZyA9PT0gTC5FZGl0YWJsZS5CQUNLV0FSRCAmJiB0aGlzLl9kcmF3bkxhdExuZ3MubGVuZ3RoID49IHRoaXMuTUlOX1ZFUlRFWCkge1xuICAgICAgICAgICAgICAgICAgICBjb21taXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPT09IDAgJiYgdGhpcy5fZHJhd2luZyA9PT0gTC5FZGl0YWJsZS5GT1JXQVJEICYmIHRoaXMuX2RyYXduTGF0TG5ncy5sZW5ndGggPj0gdGhpcy5NSU5fVkVSVEVYICYmIHRoaXMuQ0xPU0VEKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1pdCA9IHRydWU7ICAvLyBBbGxvdyB0byBjbG9zZSBvbiBmaXJzdCBwb2ludCBhbHNvIGZvciBwb2x5Z29uc1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25WZXJ0ZXhSYXdNYXJrZXJDbGljayhlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8g8J+Ngm5hbWVzcGFjZSBFZGl0YWJsZVxuICAgICAgICAgICAgICAgIC8vIPCfjYJzZWN0aW9uIFZlcnRleCBldmVudHNcbiAgICAgICAgICAgICAgICAvLyDwn42CZXZlbnQgZWRpdGFibGU6dmVydGV4OmNsaWNrZWQ6IFZlcnRleEV2ZW50XG4gICAgICAgICAgICAgICAgLy8gRmlyZWQgd2hlbiBhIGBjbGlja2AgaXMgaXNzdWVkIG9uIGEgdmVydGV4LCBhZnRlciBhbGwgaW50ZXJuYWwgYWN0aW9ucy5cbiAgICAgICAgICAgICAgICB0aGlzLmZpcmVBbmRGb3J3YXJkKCdlZGl0YWJsZTp2ZXJ0ZXg6Y2xpY2tlZCcsIGUpO1xuICAgICAgICAgICAgICAgIGlmIChjb21taXQpIHRoaXMuY29tbWl0RHJhd2luZyhlKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIG9uVmVydGV4UmF3TWFya2VyQ2xpY2s6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgLy8g8J+Ngm5hbWVzcGFjZSBFZGl0YWJsZVxuICAgICAgICAgICAgICAgIC8vIPCfjYJzZWN0aW9uIFZlcnRleCBldmVudHNcbiAgICAgICAgICAgICAgICAvLyDwn42CZXZlbnQgZWRpdGFibGU6dmVydGV4OnJhd2NsaWNrOiBDYW5jZWxhYmxlVmVydGV4RXZlbnRcbiAgICAgICAgICAgICAgICAvLyBGaXJlZCB3aGVuIGEgYGNsaWNrYCBpcyBpc3N1ZWQgb24gYSB2ZXJ0ZXggd2l0aG91dCBhbnkgc3BlY2lhbCBrZXkgYW5kIHdpdGhvdXQgYmVpbmcgaW4gZHJhd2luZyBtb2RlLlxuICAgICAgICAgICAgICAgIHRoaXMuZmlyZUFuZEZvcndhcmQoJ2VkaXRhYmxlOnZlcnRleDpyYXdjbGljaycsIGUpO1xuICAgICAgICAgICAgICAgIGlmIChlLl9jYW5jZWxsZWQpIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMudmVydGV4Q2FuQmVEZWxldGVkKGUudmVydGV4KSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGUudmVydGV4LmRlbGV0ZSgpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgdmVydGV4Q2FuQmVEZWxldGVkOiBmdW5jdGlvbiAodmVydGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZlcnRleC5sYXRsbmdzLmxlbmd0aCA+IHRoaXMuTUlOX1ZFUlRFWDtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIG9uVmVydGV4RGVsZXRlZDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAvLyDwn42CbmFtZXNwYWNlIEVkaXRhYmxlXG4gICAgICAgICAgICAgICAgLy8g8J+NgnNlY3Rpb24gVmVydGV4IGV2ZW50c1xuICAgICAgICAgICAgICAgIC8vIPCfjYJldmVudCBlZGl0YWJsZTp2ZXJ0ZXg6ZGVsZXRlZDogVmVydGV4RXZlbnRcbiAgICAgICAgICAgICAgICAvLyBGaXJlZCBhZnRlciBhIHZlcnRleCBoYXMgYmVlbiBkZWxldGVkIGJ5IHVzZXIuXG4gICAgICAgICAgICAgICAgdGhpcy5maXJlQW5kRm9yd2FyZCgnZWRpdGFibGU6dmVydGV4OmRlbGV0ZWQnLCBlKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIG9uVmVydGV4TWFya2VyQ3RybENsaWNrOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIC8vIPCfjYJuYW1lc3BhY2UgRWRpdGFibGVcbiAgICAgICAgICAgICAgICAvLyDwn42Cc2VjdGlvbiBWZXJ0ZXggZXZlbnRzXG4gICAgICAgICAgICAgICAgLy8g8J+NgmV2ZW50IGVkaXRhYmxlOnZlcnRleDpjdHJsY2xpY2s6IFZlcnRleEV2ZW50XG4gICAgICAgICAgICAgICAgLy8gRmlyZWQgd2hlbiBhIGBjbGlja2Agd2l0aCBgY3RybEtleWAgaXMgaXNzdWVkIG9uIGEgdmVydGV4LlxuICAgICAgICAgICAgICAgIHRoaXMuZmlyZUFuZEZvcndhcmQoJ2VkaXRhYmxlOnZlcnRleDpjdHJsY2xpY2snLCBlKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIG9uVmVydGV4TWFya2VyU2hpZnRDbGljazogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAvLyDwn42CbmFtZXNwYWNlIEVkaXRhYmxlXG4gICAgICAgICAgICAgICAgLy8g8J+NgnNlY3Rpb24gVmVydGV4IGV2ZW50c1xuICAgICAgICAgICAgICAgIC8vIPCfjYJldmVudCBlZGl0YWJsZTp2ZXJ0ZXg6c2hpZnRjbGljazogVmVydGV4RXZlbnRcbiAgICAgICAgICAgICAgICAvLyBGaXJlZCB3aGVuIGEgYGNsaWNrYCB3aXRoIGBzaGlmdEtleWAgaXMgaXNzdWVkIG9uIGEgdmVydGV4LlxuICAgICAgICAgICAgICAgIHRoaXMuZmlyZUFuZEZvcndhcmQoJ2VkaXRhYmxlOnZlcnRleDpzaGlmdGNsaWNrJywgZSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBvblZlcnRleE1hcmtlck1ldGFLZXlDbGljazogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAvLyDwn42CbmFtZXNwYWNlIEVkaXRhYmxlXG4gICAgICAgICAgICAgICAgLy8g8J+NgnNlY3Rpb24gVmVydGV4IGV2ZW50c1xuICAgICAgICAgICAgICAgIC8vIPCfjYJldmVudCBlZGl0YWJsZTp2ZXJ0ZXg6bWV0YWtleWNsaWNrOiBWZXJ0ZXhFdmVudFxuICAgICAgICAgICAgICAgIC8vIEZpcmVkIHdoZW4gYSBgY2xpY2tgIHdpdGggYG1ldGFLZXlgIGlzIGlzc3VlZCBvbiBhIHZlcnRleC5cbiAgICAgICAgICAgICAgICB0aGlzLmZpcmVBbmRGb3J3YXJkKCdlZGl0YWJsZTp2ZXJ0ZXg6bWV0YWtleWNsaWNrJywgZSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBvblZlcnRleE1hcmtlckFsdENsaWNrOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIC8vIPCfjYJuYW1lc3BhY2UgRWRpdGFibGVcbiAgICAgICAgICAgICAgICAvLyDwn42Cc2VjdGlvbiBWZXJ0ZXggZXZlbnRzXG4gICAgICAgICAgICAgICAgLy8g8J+NgmV2ZW50IGVkaXRhYmxlOnZlcnRleDphbHRjbGljazogVmVydGV4RXZlbnRcbiAgICAgICAgICAgICAgICAvLyBGaXJlZCB3aGVuIGEgYGNsaWNrYCB3aXRoIGBhbHRLZXlgIGlzIGlzc3VlZCBvbiBhIHZlcnRleC5cbiAgICAgICAgICAgICAgICB0aGlzLmZpcmVBbmRGb3J3YXJkKCdlZGl0YWJsZTp2ZXJ0ZXg6YWx0Y2xpY2snLCBlKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIG9uVmVydGV4TWFya2VyQ29udGV4dE1lbnU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgLy8g8J+Ngm5hbWVzcGFjZSBFZGl0YWJsZVxuICAgICAgICAgICAgICAgIC8vIPCfjYJzZWN0aW9uIFZlcnRleCBldmVudHNcbiAgICAgICAgICAgICAgICAvLyDwn42CZXZlbnQgZWRpdGFibGU6dmVydGV4OmNvbnRleHRtZW51OiBWZXJ0ZXhFdmVudFxuICAgICAgICAgICAgICAgIC8vIEZpcmVkIHdoZW4gYSBgY29udGV4dG1lbnVgIGlzIGlzc3VlZCBvbiBhIHZlcnRleC5cbiAgICAgICAgICAgICAgICB0aGlzLmZpcmVBbmRGb3J3YXJkKCdlZGl0YWJsZTp2ZXJ0ZXg6Y29udGV4dG1lbnUnLCBlKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIG9uVmVydGV4TWFya2VyTW91c2VEb3duOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIC8vIPCfjYJuYW1lc3BhY2UgRWRpdGFibGVcbiAgICAgICAgICAgICAgICAvLyDwn42Cc2VjdGlvbiBWZXJ0ZXggZXZlbnRzXG4gICAgICAgICAgICAgICAgLy8g8J+NgmV2ZW50IGVkaXRhYmxlOnZlcnRleDptb3VzZWRvd246IFZlcnRleEV2ZW50XG4gICAgICAgICAgICAgICAgLy8gRmlyZWQgd2hlbiB1c2VyIGBtb3VzZWRvd25gIGEgdmVydGV4LlxuICAgICAgICAgICAgICAgIHRoaXMuZmlyZUFuZEZvcndhcmQoJ2VkaXRhYmxlOnZlcnRleDptb3VzZWRvd24nLCBlKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIG9uVmVydGV4TWFya2VyTW91c2VPdmVyOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIC8vIPCfjYJuYW1lc3BhY2UgRWRpdGFibGVcbiAgICAgICAgICAgICAgICAvLyDwn42Cc2VjdGlvbiBWZXJ0ZXggZXZlbnRzXG4gICAgICAgICAgICAgICAgLy8g8J+NgmV2ZW50IGVkaXRhYmxlOnZlcnRleDptb3VzZW92ZXI6IFZlcnRleEV2ZW50XG4gICAgICAgICAgICAgICAgLy8gRmlyZWQgd2hlbiBhIHVzZXIncyBtb3VzZSBlbnRlcnMgdGhlIHZlcnRleFxuICAgICAgICAgICAgICAgIHRoaXMuZmlyZUFuZEZvcndhcmQoJ2VkaXRhYmxlOnZlcnRleDptb3VzZW92ZXInLCBlKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIG9uVmVydGV4TWFya2VyTW91c2VPdXQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgLy8g8J+Ngm5hbWVzcGFjZSBFZGl0YWJsZVxuICAgICAgICAgICAgICAgIC8vIPCfjYJzZWN0aW9uIFZlcnRleCBldmVudHNcbiAgICAgICAgICAgICAgICAvLyDwn42CZXZlbnQgZWRpdGFibGU6dmVydGV4Om1vdXNlb3V0OiBWZXJ0ZXhFdmVudFxuICAgICAgICAgICAgICAgIC8vIEZpcmVkIHdoZW4gYSB1c2VyJ3MgbW91c2UgbGVhdmVzIHRoZSB2ZXJ0ZXhcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmVBbmRGb3J3YXJkKCdlZGl0YWJsZTp2ZXJ0ZXg6bW91c2VvdXQnLCBlKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIG9uTWlkZGxlTWFya2VyTW91c2VEb3duOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIC8vIPCfjYJuYW1lc3BhY2UgRWRpdGFibGVcbiAgICAgICAgICAgICAgICAvLyDwn42Cc2VjdGlvbiBNaWRkbGVNYXJrZXIgZXZlbnRzXG4gICAgICAgICAgICAgICAgLy8g8J+NgmV2ZW50IGVkaXRhYmxlOm1pZGRsZW1hcmtlcjptb3VzZWRvd246IFZlcnRleEV2ZW50XG4gICAgICAgICAgICAgICAgLy8gRmlyZWQgd2hlbiB1c2VyIGBtb3VzZWRvd25gIGEgbWlkZGxlIG1hcmtlci5cbiAgICAgICAgICAgICAgICB0aGlzLmZpcmVBbmRGb3J3YXJkKCdlZGl0YWJsZTptaWRkbGVtYXJrZXI6bW91c2Vkb3duJywgZSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBvblZlcnRleE1hcmtlckRyYWc6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbk1vdmUoZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmVhdHVyZS5fYm91bmRzKSB0aGlzLmV4dGVuZEJvdW5kcyhlKTtcbiAgICAgICAgICAgICAgICAvLyDwn42CbmFtZXNwYWNlIEVkaXRhYmxlXG4gICAgICAgICAgICAgICAgLy8g8J+NgnNlY3Rpb24gVmVydGV4IGV2ZW50c1xuICAgICAgICAgICAgICAgIC8vIPCfjYJldmVudCBlZGl0YWJsZTp2ZXJ0ZXg6ZHJhZzogVmVydGV4RXZlbnRcbiAgICAgICAgICAgICAgICAvLyBGaXJlZCB3aGVuIGEgdmVydGV4IGlzIGRyYWdnZWQgYnkgdXNlci5cbiAgICAgICAgICAgICAgICB0aGlzLmZpcmVBbmRGb3J3YXJkKCdlZGl0YWJsZTp2ZXJ0ZXg6ZHJhZycsIGUpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgb25WZXJ0ZXhNYXJrZXJEcmFnU3RhcnQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgLy8g8J+Ngm5hbWVzcGFjZSBFZGl0YWJsZVxuICAgICAgICAgICAgICAgIC8vIPCfjYJzZWN0aW9uIFZlcnRleCBldmVudHNcbiAgICAgICAgICAgICAgICAvLyDwn42CZXZlbnQgZWRpdGFibGU6dmVydGV4OmRyYWdzdGFydDogVmVydGV4RXZlbnRcbiAgICAgICAgICAgICAgICAvLyBGaXJlZCBiZWZvcmUgYSB2ZXJ0ZXggaXMgZHJhZ2dlZCBieSB1c2VyLlxuICAgICAgICAgICAgICAgIHRoaXMuZmlyZUFuZEZvcndhcmQoJ2VkaXRhYmxlOnZlcnRleDpkcmFnc3RhcnQnLCBlKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIG9uVmVydGV4TWFya2VyRHJhZ0VuZDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAvLyDwn42CbmFtZXNwYWNlIEVkaXRhYmxlXG4gICAgICAgICAgICAgICAgLy8g8J+NgnNlY3Rpb24gVmVydGV4IGV2ZW50c1xuICAgICAgICAgICAgICAgIC8vIPCfjYJldmVudCBlZGl0YWJsZTp2ZXJ0ZXg6ZHJhZ2VuZDogVmVydGV4RXZlbnRcbiAgICAgICAgICAgICAgICAvLyBGaXJlZCBhZnRlciBhIHZlcnRleCBpcyBkcmFnZ2VkIGJ5IHVzZXIuXG4gICAgICAgICAgICAgICAgdGhpcy5maXJlQW5kRm9yd2FyZCgnZWRpdGFibGU6dmVydGV4OmRyYWdlbmQnLCBlKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNldERyYXduTGF0TG5nczogZnVuY3Rpb24gKGxhdGxuZ3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmF3bkxhdExuZ3MgPSBsYXRsbmdzIHx8IHRoaXMuZ2V0RGVmYXVsdExhdExuZ3MoKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHN0YXJ0RHJhd2luZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fZHJhd25MYXRMbmdzKSB0aGlzLnNldERyYXduTGF0TG5ncygpO1xuICAgICAgICAgICAgICAgIEwuRWRpdGFibGUuQmFzZUVkaXRvci5wcm90b3R5cGUuc3RhcnREcmF3aW5nLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzdGFydERyYXdpbmdGb3J3YXJkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydERyYXdpbmcoKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGVuZERyYXdpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRvb2xzLmRldGFjaEZvcndhcmRMaW5lR3VpZGUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRvb2xzLmRldGFjaEJhY2t3YXJkTGluZUd1aWRlKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2RyYXduTGF0TG5ncyAmJiB0aGlzLl9kcmF3bkxhdExuZ3MubGVuZ3RoIDwgdGhpcy5NSU5fVkVSVEVYKSB0aGlzLmRlbGV0ZVNoYXBlKHRoaXMuX2RyYXduTGF0TG5ncyk7XG4gICAgICAgICAgICAgICAgTC5FZGl0YWJsZS5CYXNlRWRpdG9yLnByb3RvdHlwZS5lbmREcmF3aW5nLmNhbGwodGhpcyk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2RyYXduTGF0TG5ncztcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGFkZExhdExuZzogZnVuY3Rpb24gKGxhdGxuZykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9kcmF3aW5nID09PSBMLkVkaXRhYmxlLkZPUldBUkQpIHRoaXMuX2RyYXduTGF0TG5ncy5wdXNoKGxhdGxuZyk7XG4gICAgICAgICAgICAgICAgZWxzZSB0aGlzLl9kcmF3bkxhdExuZ3MudW5zaGlmdChsYXRsbmcpO1xuICAgICAgICAgICAgICAgIHRoaXMuZmVhdHVyZS5fYm91bmRzLmV4dGVuZChsYXRsbmcpO1xuICAgICAgICAgICAgICAgIHZhciB2ZXJ0ZXggPSB0aGlzLmFkZFZlcnRleE1hcmtlcihsYXRsbmcsIHRoaXMuX2RyYXduTGF0TG5ncyk7XG4gICAgICAgICAgICAgICAgdGhpcy5vbk5ld1ZlcnRleCh2ZXJ0ZXgpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaCgpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgbmV3UG9pbnRGb3J3YXJkOiBmdW5jdGlvbiAobGF0bG5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRMYXRMbmcobGF0bG5nKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRvb2xzLmF0dGFjaEZvcndhcmRMaW5lR3VpZGUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRvb2xzLmFuY2hvckZvcndhcmRMaW5lR3VpZGUobGF0bG5nKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIG5ld1BvaW50QmFja3dhcmQ6IGZ1bmN0aW9uIChsYXRsbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZExhdExuZyhsYXRsbmcpO1xuICAgICAgICAgICAgICAgIHRoaXMudG9vbHMuYW5jaG9yQmFja3dhcmRMaW5lR3VpZGUobGF0bG5nKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIPCfjYJuYW1lc3BhY2UgUGF0aEVkaXRvclxuICAgICAgICAgICAgLy8g8J+Ngm1ldGhvZCBwdXNoKClcbiAgICAgICAgICAgIC8vIFByb2dyYW1tYXRpY2FsbHkgYWRkIGEgcG9pbnQgd2hpbGUgZHJhd2luZy5cbiAgICAgICAgICAgIHB1c2g6IGZ1bmN0aW9uIChsYXRsbmcpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWxhdGxuZykgcmV0dXJuIGNvbnNvbGUuZXJyb3IoJ0wuRWRpdGFibGUuUGF0aEVkaXRvci5wdXNoIGV4cGVjdCBhIHZhbGlkIGxhdGxuZyBhcyBwYXJhbWV0ZXInKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZHJhd2luZyA9PT0gTC5FZGl0YWJsZS5GT1JXQVJEKSB0aGlzLm5ld1BvaW50Rm9yd2FyZChsYXRsbmcpO1xuICAgICAgICAgICAgICAgIGVsc2UgdGhpcy5uZXdQb2ludEJhY2t3YXJkKGxhdGxuZyk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICByZW1vdmVMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcpIHtcbiAgICAgICAgICAgICAgICBsYXRsbmcuX192ZXJ0ZXguZGVsZXRlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyDwn42CbWV0aG9kIHBvcCgpOiBMLkxhdExuZyBvciBudWxsXG4gICAgICAgICAgICAvLyBQcm9ncmFtbWF0aWNhbGx5IHJlbW92ZSBsYXN0IHBvaW50IChpZiBhbnkpIHdoaWxlIGRyYXdpbmcuXG4gICAgICAgICAgICBwb3A6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZHJhd25MYXRMbmdzLmxlbmd0aCA8PSAxKSByZXR1cm47XG4gICAgICAgICAgICAgICAgdmFyIGxhdGxuZztcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZHJhd2luZyA9PT0gTC5FZGl0YWJsZS5GT1JXQVJEKSBsYXRsbmcgPSB0aGlzLl9kcmF3bkxhdExuZ3NbdGhpcy5fZHJhd25MYXRMbmdzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIGVsc2UgbGF0bG5nID0gdGhpcy5fZHJhd25MYXRMbmdzWzBdO1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlTGF0TG5nKGxhdGxuZyk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2RyYXdpbmcgPT09IEwuRWRpdGFibGUuRk9SV0FSRCkgdGhpcy50b29scy5hbmNob3JGb3J3YXJkTGluZUd1aWRlKHRoaXMuX2RyYXduTGF0TG5nc1t0aGlzLl9kcmF3bkxhdExuZ3MubGVuZ3RoIC0gMV0pO1xuICAgICAgICAgICAgICAgIGVsc2UgdGhpcy50b29scy5hbmNob3JGb3J3YXJkTGluZUd1aWRlKHRoaXMuX2RyYXduTGF0TG5nc1swXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxhdGxuZztcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHByb2Nlc3NEcmF3aW5nQ2xpY2s6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUudmVydGV4ICYmIGUudmVydGV4LmVkaXRvciA9PT0gdGhpcykgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9kcmF3aW5nID09PSBMLkVkaXRhYmxlLkZPUldBUkQpIHRoaXMubmV3UG9pbnRGb3J3YXJkKGUubGF0bG5nKTtcbiAgICAgICAgICAgICAgICBlbHNlIHRoaXMubmV3UG9pbnRCYWNrd2FyZChlLmxhdGxuZyk7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlQW5kRm9yd2FyZCgnZWRpdGFibGU6ZHJhd2luZzpjbGlja2VkJywgZSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBvbkRyYXdpbmdNb3VzZU1vdmU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgTC5FZGl0YWJsZS5CYXNlRWRpdG9yLnByb3RvdHlwZS5vbkRyYXdpbmdNb3VzZU1vdmUuY2FsbCh0aGlzLCBlKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZHJhd2luZykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvb2xzLm1vdmVGb3J3YXJkTGluZUd1aWRlKGUubGF0bG5nKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b29scy5tb3ZlQmFja3dhcmRMaW5lR3VpZGUoZS5sYXRsbmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHJlZnJlc2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZlYXR1cmUucmVkcmF3KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkVkaXRpbmcoKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIPCfjYJuYW1lc3BhY2UgUGF0aEVkaXRvclxuICAgICAgICAgICAgLy8g8J+Ngm1ldGhvZCBuZXdTaGFwZShsYXRsbmc/OiBMLkxhdExuZylcbiAgICAgICAgICAgIC8vIEFkZCBhIG5ldyBzaGFwZSAoUG9seWxpbmUsIFBvbHlnb24pIGluIGEgbXVsdGksIGFuZCBzZXR1cCB1cCBkcmF3aW5nIHRvb2xzIHRvIGRyYXcgaXQ7XG4gICAgICAgICAgICAvLyBpZiBvcHRpb25hbCBgbGF0bG5nYCBpcyBnaXZlbiwgc3RhcnQgYSBwYXRoIGF0IHRoaXMgcG9pbnQuXG4gICAgICAgICAgICBuZXdTaGFwZTogZnVuY3Rpb24gKGxhdGxuZykge1xuICAgICAgICAgICAgICAgIHZhciBzaGFwZSA9IHRoaXMuYWRkTmV3RW1wdHlTaGFwZSgpO1xuICAgICAgICAgICAgICAgIGlmICghc2hhcGUpIHJldHVybjtcbiAgICAgICAgICAgICAgICB0aGlzLnNldERyYXduTGF0TG5ncyhzaGFwZVswXSB8fCBzaGFwZSk7ICAvLyBQb2x5Z29uIG9yIHBvbHlsaW5lXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydERyYXdpbmdGb3J3YXJkKCk7XG4gICAgICAgICAgICAgICAgLy8g8J+Ngm5hbWVzcGFjZSBFZGl0YWJsZVxuICAgICAgICAgICAgICAgIC8vIPCfjYJzZWN0aW9uIFNoYXBlIGV2ZW50c1xuICAgICAgICAgICAgICAgIC8vIPCfjYJldmVudCBlZGl0YWJsZTpzaGFwZTpuZXc6IFNoYXBlRXZlbnRcbiAgICAgICAgICAgICAgICAvLyBGaXJlZCB3aGVuIGEgbmV3IHNoYXBlIGlzIGNyZWF0ZWQgaW4gYSBtdWx0aSAoUG9seWdvbiBvciBQb2x5bGluZSkuXG4gICAgICAgICAgICAgICAgdGhpcy5maXJlQW5kRm9yd2FyZCgnZWRpdGFibGU6c2hhcGU6bmV3Jywge3NoYXBlOiBzaGFwZX0pO1xuICAgICAgICAgICAgICAgIGlmIChsYXRsbmcpIHRoaXMubmV3UG9pbnRGb3J3YXJkKGxhdGxuZyk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBkZWxldGVTaGFwZTogZnVuY3Rpb24gKHNoYXBlLCBsYXRsbmdzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGUgPSB7c2hhcGU6IHNoYXBlfTtcbiAgICAgICAgICAgICAgICBMLkVkaXRhYmxlLm1ha2VDYW5jZWxsYWJsZShlKTtcbiAgICAgICAgICAgICAgICAvLyDwn42CbmFtZXNwYWNlIEVkaXRhYmxlXG4gICAgICAgICAgICAgICAgLy8g8J+NgnNlY3Rpb24gU2hhcGUgZXZlbnRzXG4gICAgICAgICAgICAgICAgLy8g8J+NgmV2ZW50IGVkaXRhYmxlOnNoYXBlOmRlbGV0ZTogQ2FuY2VsYWJsZVNoYXBlRXZlbnRcbiAgICAgICAgICAgICAgICAvLyBGaXJlZCBiZWZvcmUgYSBuZXcgc2hhcGUgaXMgZGVsZXRlZCBpbiBhIG11bHRpIChQb2x5Z29uIG9yIFBvbHlsaW5lKS5cbiAgICAgICAgICAgICAgICB0aGlzLmZpcmVBbmRGb3J3YXJkKCdlZGl0YWJsZTpzaGFwZTpkZWxldGUnLCBlKTtcbiAgICAgICAgICAgICAgICBpZiAoZS5fY2FuY2VsbGVkKSByZXR1cm47XG4gICAgICAgICAgICAgICAgc2hhcGUgPSB0aGlzLl9kZWxldGVTaGFwZShzaGFwZSwgbGF0bG5ncyk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZW5zdXJlTm90RmxhdCkgdGhpcy5lbnN1cmVOb3RGbGF0KCk7ICAvLyBQb2x5Z29uLlxuICAgICAgICAgICAgICAgIHRoaXMuZmVhdHVyZS5zZXRMYXRMbmdzKHRoaXMuZ2V0TGF0TG5ncygpKTsgIC8vIEZvcmNlIGJvdW5kcyByZXNldC5cbiAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgLy8g8J+Ngm5hbWVzcGFjZSBFZGl0YWJsZVxuICAgICAgICAgICAgICAgIC8vIPCfjYJzZWN0aW9uIFNoYXBlIGV2ZW50c1xuICAgICAgICAgICAgICAgIC8vIPCfjYJldmVudCBlZGl0YWJsZTpzaGFwZTpkZWxldGVkOiBTaGFwZUV2ZW50XG4gICAgICAgICAgICAgICAgLy8gRmlyZWQgYWZ0ZXIgYSBuZXcgc2hhcGUgaXMgZGVsZXRlZCBpbiBhIG11bHRpIChQb2x5Z29uIG9yIFBvbHlsaW5lKS5cbiAgICAgICAgICAgICAgICB0aGlzLmZpcmVBbmRGb3J3YXJkKCdlZGl0YWJsZTpzaGFwZTpkZWxldGVkJywge3NoYXBlOiBzaGFwZX0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBzaGFwZTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIF9kZWxldGVTaGFwZTogZnVuY3Rpb24gKHNoYXBlLCBsYXRsbmdzKSB7XG4gICAgICAgICAgICAgICAgbGF0bG5ncyA9IGxhdGxuZ3MgfHwgdGhpcy5nZXRMYXRMbmdzKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFsYXRsbmdzLmxlbmd0aCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgaW5wbGFjZURlbGV0ZSA9IGZ1bmN0aW9uIChsYXRsbmdzLCBzaGFwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FsbGVkIHdoZW4gZGVsZXRpbmcgYSBmbGF0IGxhdGxuZ3NcbiAgICAgICAgICAgICAgICAgICAgICAgIHNoYXBlID0gbGF0bG5ncy5zcGxpY2UoMCwgTnVtYmVyLk1BWF9WQUxVRSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2hhcGU7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHNwbGljZURlbGV0ZSA9IGZ1bmN0aW9uIChsYXRsbmdzLCBzaGFwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FsbGVkIHdoZW4gcmVtb3ZpbmcgYSBsYXRsbmdzIGluc2lkZSBhbiBhcnJheVxuICAgICAgICAgICAgICAgICAgICAgICAgbGF0bG5ncy5zcGxpY2UobGF0bG5ncy5pbmRleE9mKHNoYXBlKSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWxhdGxuZ3MubGVuZ3RoKSBzZWxmLl9kZWxldGVTaGFwZShsYXRsbmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzaGFwZTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAobGF0bG5ncyA9PT0gc2hhcGUpIHJldHVybiBpbnBsYWNlRGVsZXRlKGxhdGxuZ3MsIHNoYXBlKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhdGxuZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhdGxuZ3NbaV0gPT09IHNoYXBlKSByZXR1cm4gc3BsaWNlRGVsZXRlKGxhdGxuZ3MsIHNoYXBlKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobGF0bG5nc1tpXS5pbmRleE9mKHNoYXBlKSAhPT0gLTEpIHJldHVybiBzcGxpY2VEZWxldGUobGF0bG5nc1tpXSwgc2hhcGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIPCfjYJuYW1lc3BhY2UgUGF0aEVkaXRvclxuICAgICAgICAgICAgLy8g8J+Ngm1ldGhvZCBkZWxldGVTaGFwZUF0KGxhdGxuZzogTC5MYXRMbmcpOiBBcnJheVxuICAgICAgICAgICAgLy8gUmVtb3ZlIGEgcGF0aCBzaGFwZSBhdCB0aGUgZ2l2ZW4gYGxhdGxuZ2AuXG4gICAgICAgICAgICBkZWxldGVTaGFwZUF0OiBmdW5jdGlvbiAobGF0bG5nKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNoYXBlID0gdGhpcy5mZWF0dXJlLnNoYXBlQXQobGF0bG5nKTtcbiAgICAgICAgICAgICAgICBpZiAoc2hhcGUpIHJldHVybiB0aGlzLmRlbGV0ZVNoYXBlKHNoYXBlKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIPCfjYJtZXRob2QgYXBwZW5kU2hhcGUoc2hhcGU6IEFycmF5KVxuICAgICAgICAgICAgLy8gQXBwZW5kIGEgbmV3IHNoYXBlIHRvIHRoZSBQb2x5Z29uIG9yIFBvbHlsaW5lLlxuICAgICAgICAgICAgYXBwZW5kU2hhcGU6IGZ1bmN0aW9uIChzaGFwZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5zZXJ0U2hhcGUoc2hhcGUpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8g8J+Ngm1ldGhvZCBwcmVwZW5kU2hhcGUoc2hhcGU6IEFycmF5KVxuICAgICAgICAgICAgLy8gUHJlcGVuZCBhIG5ldyBzaGFwZSB0byB0aGUgUG9seWdvbiBvciBQb2x5bGluZS5cbiAgICAgICAgICAgIHByZXBlbmRTaGFwZTogZnVuY3Rpb24gKHNoYXBlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnNlcnRTaGFwZShzaGFwZSwgMCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyDwn42CbWV0aG9kIGluc2VydFNoYXBlKHNoYXBlOiBBcnJheSwgaW5kZXg6IGludClcbiAgICAgICAgICAgIC8vIEluc2VydCBhIG5ldyBzaGFwZSB0byB0aGUgUG9seWdvbiBvciBQb2x5bGluZSBhdCBnaXZlbiBpbmRleCAoZGVmYXVsdCBpcyB0byBhcHBlbmQpLlxuICAgICAgICAgICAgaW5zZXJ0U2hhcGU6IGZ1bmN0aW9uIChzaGFwZSwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVuc3VyZU11bHRpKCk7XG4gICAgICAgICAgICAgICAgc2hhcGUgPSB0aGlzLmZvcm1hdFNoYXBlKHNoYXBlKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGluZGV4ID09PSAndW5kZWZpbmVkJykgaW5kZXggPSB0aGlzLmZlYXR1cmUuX2xhdGxuZ3MubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHRoaXMuZmVhdHVyZS5fbGF0bG5ncy5zcGxpY2UoaW5kZXgsIDAsIHNoYXBlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZlYXR1cmUucmVkcmF3KCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2VuYWJsZWQpIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGV4dGVuZEJvdW5kczogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZlYXR1cmUuX2JvdW5kcy5leHRlbmQoZS52ZXJ0ZXgubGF0bG5nKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIG9uRHJhZ1N0YXJ0OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZWRpdExheWVyLmNsZWFyTGF5ZXJzKCk7XG4gICAgICAgICAgICAgICAgTC5FZGl0YWJsZS5CYXNlRWRpdG9yLnByb3RvdHlwZS5vbkRyYWdTdGFydC5jYWxsKHRoaXMsIGUpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgb25EcmFnRW5kOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5pdFZlcnRleE1hcmtlcnMoKTtcbiAgICAgICAgICAgICAgICBMLkVkaXRhYmxlLkJhc2VFZGl0b3IucHJvdG90eXBlLm9uRHJhZ0VuZC5jYWxsKHRoaXMsIGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIPCfjYJuYW1lc3BhY2UgRWRpdGFibGU7IPCfjYJjbGFzcyBQb2x5bGluZUVkaXRvcjsg8J+NgmFrYSBMLkVkaXRhYmxlLlBvbHlsaW5lRWRpdG9yXG4gICAgICAgIC8vIPCfjYJpbmhlcml0cyBQYXRoRWRpdG9yXG4gICAgICAgIEwuRWRpdGFibGUuUG9seWxpbmVFZGl0b3IgPSBMLkVkaXRhYmxlLlBhdGhFZGl0b3IuZXh0ZW5kKHtcblxuICAgICAgICAgICAgc3RhcnREcmF3aW5nQmFja3dhcmQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmF3aW5nID0gTC5FZGl0YWJsZS5CQUNLV0FSRDtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0RHJhd2luZygpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8g8J+Ngm1ldGhvZCBjb250aW51ZUJhY2t3YXJkKGxhdGxuZ3M/OiBBcnJheSlcbiAgICAgICAgICAgIC8vIFNldCB1cCBkcmF3aW5nIHRvb2xzIHRvIGNvbnRpbnVlIHRoZSBsaW5lIGJhY2t3YXJkLlxuICAgICAgICAgICAgY29udGludWVCYWNrd2FyZDogZnVuY3Rpb24gKGxhdGxuZ3MpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kcmF3aW5nKCkpIHJldHVybjtcbiAgICAgICAgICAgICAgICBsYXRsbmdzID0gbGF0bG5ncyB8fCB0aGlzLmdldERlZmF1bHRMYXRMbmdzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXREcmF3bkxhdExuZ3MobGF0bG5ncyk7XG4gICAgICAgICAgICAgICAgaWYgKGxhdGxuZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvb2xzLmF0dGFjaEJhY2t3YXJkTGluZUd1aWRlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG9vbHMuYW5jaG9yQmFja3dhcmRMaW5lR3VpZGUobGF0bG5nc1swXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnREcmF3aW5nQmFja3dhcmQoKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIPCfjYJtZXRob2QgY29udGludWVGb3J3YXJkKGxhdGxuZ3M/OiBBcnJheSlcbiAgICAgICAgICAgIC8vIFNldCB1cCBkcmF3aW5nIHRvb2xzIHRvIGNvbnRpbnVlIHRoZSBsaW5lIGZvcndhcmQuXG4gICAgICAgICAgICBjb250aW51ZUZvcndhcmQ6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZHJhd2luZygpKSByZXR1cm47XG4gICAgICAgICAgICAgICAgbGF0bG5ncyA9IGxhdGxuZ3MgfHwgdGhpcy5nZXREZWZhdWx0TGF0TG5ncygpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0RHJhd25MYXRMbmdzKGxhdGxuZ3MpO1xuICAgICAgICAgICAgICAgIGlmIChsYXRsbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b29scy5hdHRhY2hGb3J3YXJkTGluZUd1aWRlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG9vbHMuYW5jaG9yRm9yd2FyZExpbmVHdWlkZShsYXRsbmdzW2xhdGxuZ3MubGVuZ3RoIC0gMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0RHJhd2luZ0ZvcndhcmQoKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldERlZmF1bHRMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuICAgICAgICAgICAgICAgIGxhdGxuZ3MgPSBsYXRsbmdzIHx8IHRoaXMuZmVhdHVyZS5fbGF0bG5ncztcbiAgICAgICAgICAgICAgICBpZiAoIWxhdGxuZ3MubGVuZ3RoIHx8IGxhdGxuZ3NbMF0gaW5zdGFuY2VvZiBMLkxhdExuZykgcmV0dXJuIGxhdGxuZ3M7XG4gICAgICAgICAgICAgICAgZWxzZSByZXR1cm4gdGhpcy5nZXREZWZhdWx0TGF0TG5ncyhsYXRsbmdzWzBdKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGVuc3VyZU11bHRpOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmVhdHVyZS5fbGF0bG5ncy5sZW5ndGggJiYgaXNGbGF0KHRoaXMuZmVhdHVyZS5fbGF0bG5ncykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mZWF0dXJlLl9sYXRsbmdzID0gW3RoaXMuZmVhdHVyZS5fbGF0bG5nc107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgYWRkTmV3RW1wdHlTaGFwZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZlYXR1cmUuX2xhdGxuZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzaGFwZSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZFNoYXBlKHNoYXBlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNoYXBlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZlYXR1cmUuX2xhdGxuZ3M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZm9ybWF0U2hhcGU6IGZ1bmN0aW9uIChzaGFwZSkge1xuICAgICAgICAgICAgICAgIGlmIChpc0ZsYXQoc2hhcGUpKSByZXR1cm4gc2hhcGU7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2hhcGVbMF0pIHJldHVybiB0aGlzLmZvcm1hdFNoYXBlKHNoYXBlWzBdKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIPCfjYJtZXRob2Qgc3BsaXRTaGFwZShsYXRsbmdzPzogQXJyYXksIGluZGV4OiBpbnQpXG4gICAgICAgICAgICAvLyBTcGxpdCB0aGUgZ2l2ZW4gYGxhdGxuZ3NgIHNoYXBlIGF0IGluZGV4IGBpbmRleGAgYW5kIGludGVncmF0ZSBuZXcgc2hhcGUgaW4gaW5zdGFuY2UgYGxhdGxuZ3NgLlxuICAgICAgICAgICAgc3BsaXRTaGFwZTogZnVuY3Rpb24gKHNoYXBlLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIGlmICghaW5kZXggfHwgaW5kZXggPj0gc2hhcGUubGVuZ3RoIC0gMSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHRoaXMuZW5zdXJlTXVsdGkoKTtcbiAgICAgICAgICAgICAgICB2YXIgc2hhcGVJbmRleCA9IHRoaXMuZmVhdHVyZS5fbGF0bG5ncy5pbmRleE9mKHNoYXBlKTtcbiAgICAgICAgICAgICAgICBpZiAoc2hhcGVJbmRleCA9PT0gLTEpIHJldHVybjtcbiAgICAgICAgICAgICAgICB2YXIgZmlyc3QgPSBzaGFwZS5zbGljZSgwLCBpbmRleCArIDEpLFxuICAgICAgICAgICAgICAgICAgICBzZWNvbmQgPSBzaGFwZS5zbGljZShpbmRleCk7XG4gICAgICAgICAgICAgICAgLy8gV2UgZGVhbCB3aXRoIHJlZmVyZW5jZSwgd2UgZG9uJ3Qgd2FudCB0d2ljZSB0aGUgc2FtZSBsYXRsbmcgYXJvdW5kLlxuICAgICAgICAgICAgICAgIHNlY29uZFswXSA9IEwubGF0TG5nKHNlY29uZFswXS5sYXQsIHNlY29uZFswXS5sbmcsIHNlY29uZFswXS5hbHQpO1xuICAgICAgICAgICAgICAgIHRoaXMuZmVhdHVyZS5fbGF0bG5ncy5zcGxpY2Uoc2hhcGVJbmRleCwgMSwgZmlyc3QsIHNlY29uZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIPCfjYJuYW1lc3BhY2UgRWRpdGFibGU7IPCfjYJjbGFzcyBQb2x5Z29uRWRpdG9yOyDwn42CYWthIEwuRWRpdGFibGUuUG9seWdvbkVkaXRvclxuICAgICAgICAvLyDwn42CaW5oZXJpdHMgUGF0aEVkaXRvclxuICAgICAgICBMLkVkaXRhYmxlLlBvbHlnb25FZGl0b3IgPSBMLkVkaXRhYmxlLlBhdGhFZGl0b3IuZXh0ZW5kKHtcblxuICAgICAgICAgICAgQ0xPU0VEOiB0cnVlLFxuICAgICAgICAgICAgTUlOX1ZFUlRFWDogMyxcblxuICAgICAgICAgICAgbmV3UG9pbnRGb3J3YXJkOiBmdW5jdGlvbiAobGF0bG5nKSB7XG4gICAgICAgICAgICAgICAgTC5FZGl0YWJsZS5QYXRoRWRpdG9yLnByb3RvdHlwZS5uZXdQb2ludEZvcndhcmQuY2FsbCh0aGlzLCBsYXRsbmcpO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy50b29scy5iYWNrd2FyZExpbmVHdWlkZS5fbGF0bG5ncy5sZW5ndGgpIHRoaXMudG9vbHMuYW5jaG9yQmFja3dhcmRMaW5lR3VpZGUobGF0bG5nKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZHJhd25MYXRMbmdzLmxlbmd0aCA9PT0gMikgdGhpcy50b29scy5hdHRhY2hCYWNrd2FyZExpbmVHdWlkZSgpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgYWRkTmV3RW1wdHlIb2xlOiBmdW5jdGlvbiAobGF0bG5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbnN1cmVOb3RGbGF0KCk7XG4gICAgICAgICAgICAgICAgdmFyIGxhdGxuZ3MgPSB0aGlzLmZlYXR1cmUuc2hhcGVBdChsYXRsbmcpO1xuICAgICAgICAgICAgICAgIGlmICghbGF0bG5ncykgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHZhciBob2xlcyA9IFtdO1xuICAgICAgICAgICAgICAgIGxhdGxuZ3MucHVzaChob2xlcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhvbGVzO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8g8J+Ngm1ldGhvZCBuZXdIb2xlKGxhdGxuZz86IEwuTGF0TG5nLCBpbmRleDogaW50KVxuICAgICAgICAgICAgLy8gU2V0IHVwIGRyYXdpbmcgdG9vbHMgZm9yIGNyZWF0aW5nIGEgbmV3IGhvbGUgb24gdGhlIFBvbHlnb24uIElmIHRoZSBgbGF0bG5nYCBwYXJhbSBpcyBnaXZlbiwgYSBmaXJzdCBwb2ludCBpcyBjcmVhdGVkLlxuICAgICAgICAgICAgbmV3SG9sZTogZnVuY3Rpb24gKGxhdGxuZykge1xuICAgICAgICAgICAgICAgIHZhciBob2xlcyA9IHRoaXMuYWRkTmV3RW1wdHlIb2xlKGxhdGxuZyk7XG4gICAgICAgICAgICAgICAgaWYgKCFob2xlcykgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0RHJhd25MYXRMbmdzKGhvbGVzKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0RHJhd2luZ0ZvcndhcmQoKTtcbiAgICAgICAgICAgICAgICBpZiAobGF0bG5nKSB0aGlzLm5ld1BvaW50Rm9yd2FyZChsYXRsbmcpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgYWRkTmV3RW1wdHlTaGFwZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZlYXR1cmUuX2xhdGxuZ3MubGVuZ3RoICYmIHRoaXMuZmVhdHVyZS5fbGF0bG5nc1swXS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNoYXBlID0gW107XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kU2hhcGUoc2hhcGUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2hhcGU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmVhdHVyZS5fbGF0bG5ncztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBlbnN1cmVNdWx0aTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZlYXR1cmUuX2xhdGxuZ3MubGVuZ3RoICYmIGlzRmxhdCh0aGlzLmZlYXR1cmUuX2xhdGxuZ3NbMF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmVhdHVyZS5fbGF0bG5ncyA9IFt0aGlzLmZlYXR1cmUuX2xhdGxuZ3NdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGVuc3VyZU5vdEZsYXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZmVhdHVyZS5fbGF0bG5ncy5sZW5ndGggfHwgaXNGbGF0KHRoaXMuZmVhdHVyZS5fbGF0bG5ncykpIHRoaXMuZmVhdHVyZS5fbGF0bG5ncyA9IFt0aGlzLmZlYXR1cmUuX2xhdGxuZ3NdO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgdmVydGV4Q2FuQmVEZWxldGVkOiBmdW5jdGlvbiAodmVydGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMuZmVhdHVyZS5wYXJlbnRTaGFwZSh2ZXJ0ZXgubGF0bG5ncyksXG4gICAgICAgICAgICAgICAgICAgIGlkeCA9IEwuVXRpbC5pbmRleE9mKHBhcmVudCwgdmVydGV4LmxhdGxuZ3MpO1xuICAgICAgICAgICAgICAgIGlmIChpZHggPiAwKSByZXR1cm4gdHJ1ZTsgIC8vIEhvbGVzIGNhbiBiZSB0b3RhbGx5IGRlbGV0ZWQgd2l0aG91dCByZW1vdmluZyB0aGUgbGF5ZXIgaXRzZWxmLlxuICAgICAgICAgICAgICAgIHJldHVybiBMLkVkaXRhYmxlLlBhdGhFZGl0b3IucHJvdG90eXBlLnZlcnRleENhbkJlRGVsZXRlZC5jYWxsKHRoaXMsIHZlcnRleCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBnZXREZWZhdWx0TGF0TG5nczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5mZWF0dXJlLl9sYXRsbmdzLmxlbmd0aCkgdGhpcy5mZWF0dXJlLl9sYXRsbmdzLnB1c2goW10pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZlYXR1cmUuX2xhdGxuZ3NbMF07XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBmb3JtYXRTaGFwZTogZnVuY3Rpb24gKHNoYXBlKSB7XG4gICAgICAgICAgICAgICAgLy8gW1sxLCAyXSwgWzMsIDRdXSA9PiBtdXN0IGJlIG5lc3RlZFxuICAgICAgICAgICAgICAgIC8vIFtdID0+IG11c3QgYmUgbmVzdGVkXG4gICAgICAgICAgICAgICAgLy8gW1tdXSA9PiBpcyBhbHJlYWR5IG5lc3RlZFxuICAgICAgICAgICAgICAgIGlmIChpc0ZsYXQoc2hhcGUpICYmICghc2hhcGVbMF0gfHwgc2hhcGVbMF0ubGVuZ3RoICE9PSAwKSkgcmV0dXJuIFtzaGFwZV07XG4gICAgICAgICAgICAgICAgZWxzZSByZXR1cm4gc2hhcGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8g8J+Ngm5hbWVzcGFjZSBFZGl0YWJsZTsg8J+NgmNsYXNzIFJlY3RhbmdsZUVkaXRvcjsg8J+NgmFrYSBMLkVkaXRhYmxlLlJlY3RhbmdsZUVkaXRvclxuICAgICAgICAvLyDwn42CaW5oZXJpdHMgUGF0aEVkaXRvclxuICAgICAgICBMLkVkaXRhYmxlLlJlY3RhbmdsZUVkaXRvciA9IEwuRWRpdGFibGUuUGF0aEVkaXRvci5leHRlbmQoe1xuXG4gICAgICAgICAgICBDTE9TRUQ6IHRydWUsXG4gICAgICAgICAgICBNSU5fVkVSVEVYOiA0LFxuXG4gICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgc2tpcE1pZGRsZU1hcmtlcnM6IHRydWVcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGV4dGVuZEJvdW5kczogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBlLnZlcnRleC5nZXRJbmRleCgpLFxuICAgICAgICAgICAgICAgICAgICBuZXh0ID0gZS52ZXJ0ZXguZ2V0TmV4dCgpLFxuICAgICAgICAgICAgICAgICAgICBwcmV2aW91cyA9IGUudmVydGV4LmdldFByZXZpb3VzKCksXG4gICAgICAgICAgICAgICAgICAgIG9wcG9zaXRlSW5kZXggPSAoaW5kZXggKyAyKSAlIDQsXG4gICAgICAgICAgICAgICAgICAgIG9wcG9zaXRlID0gZS52ZXJ0ZXgubGF0bG5nc1tvcHBvc2l0ZUluZGV4XSxcbiAgICAgICAgICAgICAgICAgICAgYm91bmRzID0gbmV3IEwuTGF0TG5nQm91bmRzKGUubGF0bG5nLCBvcHBvc2l0ZSk7XG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIGxhdGxuZ3MgYnkgaGFuZCB0byBwcmVzZXJ2ZSBvcmRlci5cbiAgICAgICAgICAgICAgICBwcmV2aW91cy5sYXRsbmcudXBkYXRlKFtlLmxhdGxuZy5sYXQsIG9wcG9zaXRlLmxuZ10pO1xuICAgICAgICAgICAgICAgIG5leHQubGF0bG5nLnVwZGF0ZShbb3Bwb3NpdGUubGF0LCBlLmxhdGxuZy5sbmddKTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUJvdW5kcyhib3VuZHMpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaFZlcnRleE1hcmtlcnMoKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIG9uRHJhd2luZ01vdXNlRG93bjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBMLkVkaXRhYmxlLlBhdGhFZGl0b3IucHJvdG90eXBlLm9uRHJhd2luZ01vdXNlRG93bi5jYWxsKHRoaXMsIGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIHZhciBsYXRsbmdzID0gdGhpcy5nZXREZWZhdWx0TGF0TG5ncygpO1xuICAgICAgICAgICAgICAgIC8vIEwuUG9seWdvbi5fY29udmVydExhdExuZ3MgcmVtb3ZlcyBsYXN0IGxhdGxuZyBpZiBpdCBlcXVhbHMgZmlyc3QgcG9pbnQsXG4gICAgICAgICAgICAgICAgLy8gd2hpY2ggaXMgdGhlIGNhc2UgaGVyZSBhcyBhbGwgbGF0bG5ncyBhcmUgWzAsIDBdXG4gICAgICAgICAgICAgICAgaWYgKGxhdGxuZ3MubGVuZ3RoID09PSAzKSBsYXRsbmdzLnB1c2goZS5sYXRsbmcpO1xuICAgICAgICAgICAgICAgIHZhciBib3VuZHMgPSBuZXcgTC5MYXRMbmdCb3VuZHMoZS5sYXRsbmcsIGUubGF0bG5nKTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUJvdW5kcyhib3VuZHMpO1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlTGF0TG5ncyhib3VuZHMpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaCgpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgICAgICAgICAvLyBTdG9wIGRyYWdnaW5nIG1hcC5cbiAgICAgICAgICAgICAgICAvLyBMLkRyYWdnYWJsZSBoYXMgdHdvIHdvcmtmbG93czpcbiAgICAgICAgICAgICAgICAvLyAtIG1vdXNlZG93biA9PiBtb3VzZW1vdmUgPT4gbW91c2V1cFxuICAgICAgICAgICAgICAgIC8vIC0gdG91Y2hzdGFydCA9PiB0b3VjaG1vdmUgPT4gdG91Y2hlbmRcbiAgICAgICAgICAgICAgICAvLyBQcm9ibGVtOiBMLk1hcC5UYXAgZG9lcyBub3QgYWxsb3cgdXMgdG8gbGlzdGVuIHRvIHRvdWNoc3RhcnQsIHNvIHdlIG9ubHlcbiAgICAgICAgICAgICAgICAvLyBjYW4gZGVhbCB3aXRoIG1vdXNlZG93biwgYnV0IHRoZW4gd2hlbiBpbiBhIHRvdWNoIGRldmljZSwgd2UgYXJlIGRlYWxpbmcgd2l0aFxuICAgICAgICAgICAgICAgIC8vIHNpbXVsYXRlZCBldmVudHMgKGFjdHVhbGx5IHNpbXVsYXRlZCBieSBMLk1hcC5UYXApLCB3aGljaCBhcmUgbm8gbW9yZSB0YWtlblxuICAgICAgICAgICAgICAgIC8vIGludG8gYWNjb3VudCBieSBMLkRyYWdnYWJsZS5cbiAgICAgICAgICAgICAgICAvLyBSZWYuOiBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0LkVkaXRhYmxlL2lzc3Vlcy8xMDNcbiAgICAgICAgICAgICAgICBlLm9yaWdpbmFsRXZlbnQuX3NpbXVsYXRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMubWFwLmRyYWdnaW5nLl9kcmFnZ2FibGUuX29uVXAoZS5vcmlnaW5hbEV2ZW50KTtcbiAgICAgICAgICAgICAgICAvLyBOb3cgdHJhbnNmZXIgb25nb2luZyBkcmFnIGFjdGlvbiB0byB0aGUgYm90dG9tIHJpZ2h0IGNvcm5lci5cbiAgICAgICAgICAgICAgICAvLyBTaG91bGQgd2UgcmVmaW5lIHdoaWNoIGNvcm5lciB3aWxsIGhhbmRsZSB0aGUgZHJhZyBhY2NvcmRpbmcgdG9cbiAgICAgICAgICAgICAgICAvLyBkcmFnIGRpcmVjdGlvbj9cbiAgICAgICAgICAgICAgICBsYXRsbmdzWzNdLl9fdmVydGV4LmRyYWdnaW5nLl9kcmFnZ2FibGUuX29uRG93bihlLm9yaWdpbmFsRXZlbnQpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgb25EcmF3aW5nTW91c2VVcDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbW1pdERyYXdpbmcoZSk7XG4gICAgICAgICAgICAgICAgZS5vcmlnaW5hbEV2ZW50Ll9zaW11bGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBMLkVkaXRhYmxlLlBhdGhFZGl0b3IucHJvdG90eXBlLm9uRHJhd2luZ01vdXNlVXAuY2FsbCh0aGlzLCBlKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIG9uRHJhd2luZ01vdXNlTW92ZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBlLm9yaWdpbmFsRXZlbnQuX3NpbXVsYXRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIEwuRWRpdGFibGUuUGF0aEVkaXRvci5wcm90b3R5cGUub25EcmF3aW5nTW91c2VNb3ZlLmNhbGwodGhpcywgZSk7XG4gICAgICAgICAgICB9LFxuXG5cbiAgICAgICAgICAgIGdldERlZmF1bHRMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuICAgICAgICAgICAgICAgIHJldHVybiBsYXRsbmdzIHx8IHRoaXMuZmVhdHVyZS5fbGF0bG5nc1swXTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHVwZGF0ZUJvdW5kczogZnVuY3Rpb24gKGJvdW5kcykge1xuICAgICAgICAgICAgICAgIHRoaXMuZmVhdHVyZS5fYm91bmRzID0gYm91bmRzO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgdXBkYXRlTGF0TG5nczogZnVuY3Rpb24gKGJvdW5kcykge1xuICAgICAgICAgICAgICAgIHZhciBsYXRsbmdzID0gdGhpcy5nZXREZWZhdWx0TGF0TG5ncygpLFxuICAgICAgICAgICAgICAgICAgICBuZXdMYXRsbmdzID0gdGhpcy5mZWF0dXJlLl9ib3VuZHNUb0xhdExuZ3MoYm91bmRzKTtcbiAgICAgICAgICAgICAgICAvLyBLZWVwIHJlZmVyZW5jZXMuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXRsbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhdGxuZ3NbaV0udXBkYXRlKG5ld0xhdGxuZ3NbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9KTtcblxuICAgICAgICAvLyDwn42CbmFtZXNwYWNlIEVkaXRhYmxlOyDwn42CY2xhc3MgQ2lyY2xlRWRpdG9yOyDwn42CYWthIEwuRWRpdGFibGUuQ2lyY2xlRWRpdG9yXG4gICAgICAgIC8vIPCfjYJpbmhlcml0cyBQYXRoRWRpdG9yXG4gICAgICAgIEwuRWRpdGFibGUuQ2lyY2xlRWRpdG9yID0gTC5FZGl0YWJsZS5QYXRoRWRpdG9yLmV4dGVuZCh7XG5cbiAgICAgICAgICAgIE1JTl9WRVJURVg6IDIsXG5cbiAgICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICBza2lwTWlkZGxlTWFya2VyczogdHJ1ZVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcCwgZmVhdHVyZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIEwuRWRpdGFibGUuUGF0aEVkaXRvci5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIG1hcCwgZmVhdHVyZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzaXplTGF0TG5nID0gdGhpcy5jb21wdXRlUmVzaXplTGF0TG5nKCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBjb21wdXRlUmVzaXplTGF0TG5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgLy8gV2hpbGUgY2lyY2xlIGlzIG5vdCBhZGRlZCB0byB0aGUgbWFwLCBfcmFkaXVzIGlzIG5vdCBzZXQuXG4gICAgICAgICAgICAgICAgdmFyIGRlbHRhID0gKHRoaXMuZmVhdHVyZS5fcmFkaXVzIHx8IHRoaXMuZmVhdHVyZS5fbVJhZGl1cykgKiBNYXRoLmNvcyhNYXRoLlBJIC8gNCksXG4gICAgICAgICAgICAgICAgICAgIHBvaW50ID0gdGhpcy5tYXAucHJvamVjdCh0aGlzLmZlYXR1cmUuX2xhdGxuZyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFwLnVucHJvamVjdChbcG9pbnQueCArIGRlbHRhLCBwb2ludC55IC0gZGVsdGFdKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHVwZGF0ZVJlc2l6ZUxhdExuZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc2l6ZUxhdExuZy51cGRhdGUodGhpcy5jb21wdXRlUmVzaXplTGF0TG5nKCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc2l6ZUxhdExuZy5fX3ZlcnRleC51cGRhdGUoKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGdldExhdExuZ3M6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3RoaXMuZmVhdHVyZS5fbGF0bG5nLCB0aGlzLl9yZXNpemVMYXRMbmddO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgZ2V0RGVmYXVsdExhdExuZ3M6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRMYXRMbmdzKCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBvblZlcnRleE1hcmtlckRyYWc6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUudmVydGV4LmdldEluZGV4KCkgPT09IDEpIHRoaXMucmVzaXplKGUpO1xuICAgICAgICAgICAgICAgIGVsc2UgdGhpcy51cGRhdGVSZXNpemVMYXRMbmcoZSk7XG4gICAgICAgICAgICAgICAgTC5FZGl0YWJsZS5QYXRoRWRpdG9yLnByb3RvdHlwZS5vblZlcnRleE1hcmtlckRyYWcuY2FsbCh0aGlzLCBlKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHJlc2l6ZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmFkaXVzID0gdGhpcy5mZWF0dXJlLl9sYXRsbmcuZGlzdGFuY2VUbyhlLmxhdGxuZyk7XG4gICAgICAgICAgICAgICAgdGhpcy5mZWF0dXJlLnNldFJhZGl1cyhyYWRpdXMpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgb25EcmF3aW5nTW91c2VEb3duOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIEwuRWRpdGFibGUuUGF0aEVkaXRvci5wcm90b3R5cGUub25EcmF3aW5nTW91c2VEb3duLmNhbGwodGhpcywgZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzaXplTGF0TG5nLnVwZGF0ZShlLmxhdGxuZyk7XG4gICAgICAgICAgICAgICAgdGhpcy5mZWF0dXJlLl9sYXRsbmcudXBkYXRlKGUubGF0bG5nKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICAvLyBTdG9wIGRyYWdnaW5nIG1hcC5cbiAgICAgICAgICAgICAgICBlLm9yaWdpbmFsRXZlbnQuX3NpbXVsYXRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMubWFwLmRyYWdnaW5nLl9kcmFnZ2FibGUuX29uVXAoZS5vcmlnaW5hbEV2ZW50KTtcbiAgICAgICAgICAgICAgICAvLyBOb3cgdHJhbnNmZXIgb25nb2luZyBkcmFnIGFjdGlvbiB0byB0aGUgcmFkaXVzIGhhbmRsZXIuXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzaXplTGF0TG5nLl9fdmVydGV4LmRyYWdnaW5nLl9kcmFnZ2FibGUuX29uRG93bihlLm9yaWdpbmFsRXZlbnQpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgb25EcmF3aW5nTW91c2VVcDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbW1pdERyYXdpbmcoZSk7XG4gICAgICAgICAgICAgICAgZS5vcmlnaW5hbEV2ZW50Ll9zaW11bGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBMLkVkaXRhYmxlLlBhdGhFZGl0b3IucHJvdG90eXBlLm9uRHJhd2luZ01vdXNlVXAuY2FsbCh0aGlzLCBlKTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIG9uRHJhd2luZ01vdXNlTW92ZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBlLm9yaWdpbmFsRXZlbnQuX3NpbXVsYXRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIEwuRWRpdGFibGUuUGF0aEVkaXRvci5wcm90b3R5cGUub25EcmF3aW5nTW91c2VNb3ZlLmNhbGwodGhpcywgZSk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBvbkRyYWc6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgTC5FZGl0YWJsZS5QYXRoRWRpdG9yLnByb3RvdHlwZS5vbkRyYWcuY2FsbCh0aGlzLCBlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmZlYXR1cmUuZHJhZ2dpbmcudXBkYXRlTGF0TG5nKHRoaXMuX3Jlc2l6ZUxhdExuZyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8g8J+Ngm5hbWVzcGFjZSBFZGl0YWJsZTsg8J+NgmNsYXNzIEVkaXRhYmxlTWl4aW5cbiAgICAgICAgLy8gYEVkaXRhYmxlTWl4aW5gIGlzIGluY2x1ZGVkIHRvIGBMLlBvbHlsaW5lYCwgYEwuUG9seWdvbmAsIGBMLlJlY3RhbmdsZWAsIGBMLkNpcmNsZWBcbiAgICAgICAgLy/CoGFuZCBgTC5NYXJrZXJgLiBJdCBhZGRzIHNvbWUgbWV0aG9kcyB0byB0aGVtLlxuICAgICAgICAvLyAqV2hlbiBlZGl0aW5nIGlzIGVuYWJsZWQsIHRoZSBlZGl0b3IgaXMgYWNjZXNzaWJsZSBvbiB0aGUgaW5zdGFuY2Ugd2l0aCB0aGVcbiAgICAgICAgLy8gYGVkaXRvcmAgcHJvcGVydHkuKlxuICAgICAgICB2YXIgRWRpdGFibGVNaXhpbiA9IHtcblxuICAgICAgICAgICAgY3JlYXRlRWRpdG9yOiBmdW5jdGlvbiAobWFwKSB7XG4gICAgICAgICAgICAgICAgbWFwID0gbWFwIHx8IHRoaXMuX21hcDtcbiAgICAgICAgICAgICAgICB2YXIgdG9vbHMgPSAodGhpcy5vcHRpb25zLmVkaXRPcHRpb25zIHx8IHt9KS5lZGl0VG9vbHMgfHwgbWFwLmVkaXRUb29scztcbiAgICAgICAgICAgICAgICBpZiAoIXRvb2xzKSB0aHJvdyBFcnJvcignVW5hYmxlIHRvIGRldGVjdCBFZGl0YWJsZSBpbnN0YW5jZS4nKTtcbiAgICAgICAgICAgICAgICB2YXIgS2xhc3MgPSB0aGlzLm9wdGlvbnMuZWRpdG9yQ2xhc3MgfHwgdGhpcy5nZXRFZGl0b3JDbGFzcyh0b29scyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBLbGFzcyhtYXAsIHRoaXMsIHRoaXMub3B0aW9ucy5lZGl0T3B0aW9ucyk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyDwn42CbWV0aG9kIGVuYWJsZUVkaXQobWFwPzogTC5NYXApOiB0aGlzLmVkaXRvclxuICAgICAgICAgICAgLy8gRW5hYmxlIGVkaXRpbmcsIGJ5IGNyZWF0aW5nIGFuIGVkaXRvciBpZiBub3QgZXhpc3RpbmcsIGFuZCB0aGVuIGNhbGxpbmcgYGVuYWJsZWAgb24gaXQuXG4gICAgICAgICAgICBlbmFibGVFZGl0OiBmdW5jdGlvbiAobWFwKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmVkaXRvcikgdGhpcy5jcmVhdGVFZGl0b3IobWFwKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVkaXRvci5lbmFibGUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5lZGl0b3I7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyDwn42CbWV0aG9kIGVkaXRFbmFibGVkKCk6IGJvb2xlYW5cbiAgICAgICAgICAgIC8vIFJldHVybiB0cnVlIGlmIGN1cnJlbnQgaW5zdGFuY2UgaGFzIGFuIGVkaXRvciBhdHRhY2hlZCwgYW5kIHRoaXMgZWRpdG9yIGlzIGVuYWJsZWQuXG4gICAgICAgICAgICBlZGl0RW5hYmxlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVkaXRvciAmJiB0aGlzLmVkaXRvci5lbmFibGVkKCk7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyDwn42CbWV0aG9kIGRpc2FibGVFZGl0KClcbiAgICAgICAgICAgIC8vIERpc2FibGUgZWRpdGluZywgYWxzbyByZW1vdmUgdGhlIGVkaXRvciBwcm9wZXJ0eSByZWZlcmVuY2UuXG4gICAgICAgICAgICBkaXNhYmxlRWRpdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmVkaXRvcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVkaXRvci5kaXNhYmxlKCk7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmVkaXRvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyDwn42CbWV0aG9kIHRvZ2dsZUVkaXQoKVxuICAgICAgICAgICAgLy8gRW5hYmxlIG9yIGRpc2FibGUgZWRpdGluZywgYWNjb3JkaW5nIHRvIGN1cnJlbnQgc3RhdHVzLlxuICAgICAgICAgICAgdG9nZ2xlRWRpdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmVkaXRFbmFibGVkKCkpIHRoaXMuZGlzYWJsZUVkaXQoKTtcbiAgICAgICAgICAgICAgICBlbHNlIHRoaXMuZW5hYmxlRWRpdCgpO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgX29uRWRpdGFibGVBZGQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5lZGl0b3IpIHRoaXMuZW5hYmxlRWRpdCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIFBvbHlsaW5lTWl4aW4gPSB7XG5cbiAgICAgICAgICAgIGdldEVkaXRvckNsYXNzOiBmdW5jdGlvbiAodG9vbHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHRvb2xzICYmIHRvb2xzLm9wdGlvbnMucG9seWxpbmVFZGl0b3JDbGFzcykgPyB0b29scy5vcHRpb25zLnBvbHlsaW5lRWRpdG9yQ2xhc3MgOiBMLkVkaXRhYmxlLlBvbHlsaW5lRWRpdG9yO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2hhcGVBdDogZnVuY3Rpb24gKGxhdGxuZywgbGF0bG5ncykge1xuICAgICAgICAgICAgICAgIC8vIFdlIGNhbiBoYXZlIHRob3NlIGNhc2VzOlxuICAgICAgICAgICAgICAgIC8vIC0gbGF0bG5ncyBhcmUganVzdCBhIGZsYXQgYXJyYXkgb2YgbGF0bG5ncywgdXNlIHRoaXNcbiAgICAgICAgICAgICAgICAvLyAtIGxhdGxuZ3MgaXMgYW4gYXJyYXkgb2YgYXJyYXlzIG9mIGxhdGxuZ3MsIGxvb3Agb3ZlclxuICAgICAgICAgICAgICAgIHZhciBzaGFwZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgbGF0bG5ncyA9IGxhdGxuZ3MgfHwgdGhpcy5fbGF0bG5ncztcbiAgICAgICAgICAgICAgICBpZiAoIWxhdGxuZ3MubGVuZ3RoKSByZXR1cm4gc2hhcGU7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNGbGF0KGxhdGxuZ3MpICYmIHRoaXMuaXNJbkxhdExuZ3MobGF0bG5nLCBsYXRsbmdzKSkgc2hhcGUgPSBsYXRsbmdzO1xuICAgICAgICAgICAgICAgIGVsc2UgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXRsbmdzLmxlbmd0aDsgaSsrKSBpZiAodGhpcy5pc0luTGF0TG5ncyhsYXRsbmcsIGxhdGxuZ3NbaV0pKSByZXR1cm4gbGF0bG5nc1tpXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2hhcGU7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBpc0luTGF0TG5nczogZnVuY3Rpb24gKGwsIGxhdGxuZ3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWxhdGxuZ3MpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB2YXIgaSwgaywgbGVuLCBwYXJ0ID0gW10sIHAsXG4gICAgICAgICAgICAgICAgICAgIHcgPSB0aGlzLl9jbGlja1RvbGVyYW5jZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3Byb2plY3RMYXRsbmdzKGxhdGxuZ3MsIHBhcnQsIHRoaXMuX3B4Qm91bmRzKTtcbiAgICAgICAgICAgICAgICBwYXJ0ID0gcGFydFswXTtcbiAgICAgICAgICAgICAgICBwID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludChsKTtcblxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fcHhCb3VuZHMuY29udGFpbnMocCkpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMSwgbGVuID0gcGFydC5sZW5ndGgsIGsgPSAwOyBpIDwgbGVuOyBrID0gaSsrKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKEwuTGluZVV0aWwucG9pbnRUb1NlZ21lbnREaXN0YW5jZShwLCBwYXJ0W2tdLCBwYXJ0W2ldKSA8PSB3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgUG9seWdvbk1peGluID0ge1xuXG4gICAgICAgICAgICBnZXRFZGl0b3JDbGFzczogZnVuY3Rpb24gKHRvb2xzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0b29scyAmJiB0b29scy5vcHRpb25zLnBvbHlnb25FZGl0b3JDbGFzcykgPyB0b29scy5vcHRpb25zLnBvbHlnb25FZGl0b3JDbGFzcyA6IEwuRWRpdGFibGUuUG9seWdvbkVkaXRvcjtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIHNoYXBlQXQ6IGZ1bmN0aW9uIChsYXRsbmcsIGxhdGxuZ3MpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBjYW4gaGF2ZSB0aG9zZSBjYXNlczpcbiAgICAgICAgICAgICAgICAvLyAtIGxhdGxuZ3MgYXJlIGp1c3QgYSBmbGF0IGFycmF5IG9mIGxhdGxuZ3MsIHVzZSB0aGlzXG4gICAgICAgICAgICAgICAgLy8gLSBsYXRsbmdzIGlzIGFuIGFycmF5IG9mIGFycmF5cyBvZiBsYXRsbmdzLCB0aGlzIGlzIGEgc2ltcGxlIHBvbHlnb24gKG1heWJlIHdpdGggaG9sZXMpLCB1c2UgdGhlIGZpcnN0XG4gICAgICAgICAgICAgICAgLy8gLSBsYXRsbmdzIGlzIGFuIGFycmF5IG9mIGFycmF5cyBvZiBhcnJheXMsIHRoaXMgaXMgYSBtdWx0aSwgbG9vcCBvdmVyXG4gICAgICAgICAgICAgICAgdmFyIHNoYXBlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBsYXRsbmdzID0gbGF0bG5ncyB8fCB0aGlzLl9sYXRsbmdzO1xuICAgICAgICAgICAgICAgIGlmICghbGF0bG5ncy5sZW5ndGgpIHJldHVybiBzaGFwZTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0ZsYXQobGF0bG5ncykgJiYgdGhpcy5pc0luTGF0TG5ncyhsYXRsbmcsIGxhdGxuZ3MpKSBzaGFwZSA9IGxhdGxuZ3M7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNGbGF0KGxhdGxuZ3NbMF0pICYmIHRoaXMuaXNJbkxhdExuZ3MobGF0bG5nLCBsYXRsbmdzWzBdKSkgc2hhcGUgPSBsYXRsbmdzO1xuICAgICAgICAgICAgICAgIGVsc2UgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXRsbmdzLmxlbmd0aDsgaSsrKSBpZiAodGhpcy5pc0luTGF0TG5ncyhsYXRsbmcsIGxhdGxuZ3NbaV1bMF0pKSByZXR1cm4gbGF0bG5nc1tpXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2hhcGU7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBpc0luTGF0TG5nczogZnVuY3Rpb24gKGwsIGxhdGxuZ3MpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5zaWRlID0gZmFsc2UsIGwxLCBsMiwgaiwgaywgbGVuMjtcblxuICAgICAgICAgICAgICAgIGZvciAoaiA9IDAsIGxlbjIgPSBsYXRsbmdzLmxlbmd0aCwgayA9IGxlbjIgLSAxOyBqIDwgbGVuMjsgayA9IGorKykge1xuICAgICAgICAgICAgICAgICAgICBsMSA9IGxhdGxuZ3Nbal07XG4gICAgICAgICAgICAgICAgICAgIGwyID0gbGF0bG5nc1trXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoKChsMS5sYXQgPiBsLmxhdCkgIT09IChsMi5sYXQgPiBsLmxhdCkpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAobC5sbmcgPCAobDIubG5nIC0gbDEubG5nKSAqIChsLmxhdCAtIGwxLmxhdCkgLyAobDIubGF0IC0gbDEubGF0KSArIGwxLmxuZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc2lkZSA9ICFpbnNpZGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gaW5zaWRlO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgcGFyZW50U2hhcGU6IGZ1bmN0aW9uIChzaGFwZSwgbGF0bG5ncykge1xuICAgICAgICAgICAgICAgIGxhdGxuZ3MgPSBsYXRsbmdzIHx8IHRoaXMuX2xhdGxuZ3M7XG4gICAgICAgICAgICAgICAgaWYgKCFsYXRsbmdzKSByZXR1cm47XG4gICAgICAgICAgICAgICAgdmFyIGlkeCA9IEwuVXRpbC5pbmRleE9mKGxhdGxuZ3MsIHNoYXBlKTtcbiAgICAgICAgICAgICAgICBpZiAoaWR4ICE9PSAtMSkgcmV0dXJuIGxhdGxuZ3M7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXRsbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlkeCA9IEwuVXRpbC5pbmRleE9mKGxhdGxuZ3NbaV0sIHNoYXBlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlkeCAhPT0gLTEpIHJldHVybiBsYXRsbmdzW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9O1xuXG5cbiAgICAgICAgdmFyIE1hcmtlck1peGluID0ge1xuXG4gICAgICAgICAgICBnZXRFZGl0b3JDbGFzczogZnVuY3Rpb24gKHRvb2xzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0b29scyAmJiB0b29scy5vcHRpb25zLm1hcmtlckVkaXRvckNsYXNzKSA/IHRvb2xzLm9wdGlvbnMubWFya2VyRWRpdG9yQ2xhc3MgOiBMLkVkaXRhYmxlLk1hcmtlckVkaXRvcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBSZWN0YW5nbGVNaXhpbiA9IHtcblxuICAgICAgICAgICAgZ2V0RWRpdG9yQ2xhc3M6IGZ1bmN0aW9uICh0b29scykge1xuICAgICAgICAgICAgICAgIHJldHVybiAodG9vbHMgJiYgdG9vbHMub3B0aW9ucy5yZWN0YW5nbGVFZGl0b3JDbGFzcykgPyB0b29scy5vcHRpb25zLnJlY3RhbmdsZUVkaXRvckNsYXNzIDogTC5FZGl0YWJsZS5SZWN0YW5nbGVFZGl0b3I7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgQ2lyY2xlTWl4aW4gPSB7XG5cbiAgICAgICAgICAgIGdldEVkaXRvckNsYXNzOiBmdW5jdGlvbiAodG9vbHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHRvb2xzICYmIHRvb2xzLm9wdGlvbnMuY2lyY2xlRWRpdG9yQ2xhc3MpID8gdG9vbHMub3B0aW9ucy5jaXJjbGVFZGl0b3JDbGFzcyA6IEwuRWRpdGFibGUuQ2lyY2xlRWRpdG9yO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGtlZXBFZGl0YWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB5b3UgY2FuIHJlbW92ZS9yZWFkZCBhbiBlZGl0YWJsZSBsYXllci5cbiAgICAgICAgICAgIHRoaXMub24oJ2FkZCcsIHRoaXMuX29uRWRpdGFibGVBZGQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBpc0ZsYXQgPSBMLkxpbmVVdGlsLmlzRmxhdCB8fCBMLkxpbmVVdGlsLl9mbGF0IHx8IEwuUG9seWxpbmUuX2ZsYXQ7ICAvLyA8PT4gMS4xIGNvbXBhdC5cblxuXG4gICAgICAgIGlmIChMLlBvbHlsaW5lKSB7XG4gICAgICAgICAgICBMLlBvbHlsaW5lLmluY2x1ZGUoRWRpdGFibGVNaXhpbik7XG4gICAgICAgICAgICBMLlBvbHlsaW5lLmluY2x1ZGUoUG9seWxpbmVNaXhpbik7XG4gICAgICAgICAgICBMLlBvbHlsaW5lLmFkZEluaXRIb29rKGtlZXBFZGl0YWJsZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEwuUG9seWdvbikge1xuICAgICAgICAgICAgTC5Qb2x5Z29uLmluY2x1ZGUoRWRpdGFibGVNaXhpbik7XG4gICAgICAgICAgICBMLlBvbHlnb24uaW5jbHVkZShQb2x5Z29uTWl4aW4pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChMLk1hcmtlcikge1xuICAgICAgICAgICAgTC5NYXJrZXIuaW5jbHVkZShFZGl0YWJsZU1peGluKTtcbiAgICAgICAgICAgIEwuTWFya2VyLmluY2x1ZGUoTWFya2VyTWl4aW4pO1xuICAgICAgICAgICAgTC5NYXJrZXIuYWRkSW5pdEhvb2soa2VlcEVkaXRhYmxlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoTC5SZWN0YW5nbGUpIHtcbiAgICAgICAgICAgIEwuUmVjdGFuZ2xlLmluY2x1ZGUoRWRpdGFibGVNaXhpbik7XG4gICAgICAgICAgICBMLlJlY3RhbmdsZS5pbmNsdWRlKFJlY3RhbmdsZU1peGluKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoTC5DaXJjbGUpIHtcbiAgICAgICAgICAgIEwuQ2lyY2xlLmluY2x1ZGUoRWRpdGFibGVNaXhpbik7XG4gICAgICAgICAgICBMLkNpcmNsZS5pbmNsdWRlKENpcmNsZU1peGluKTtcbiAgICAgICAgfVxuXG4gICAgICAgIEwuTGF0TG5nLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAobGF0bG5nKSB7XG4gICAgICAgICAgICBsYXRsbmcgPSBMLmxhdExuZyhsYXRsbmcpO1xuICAgICAgICAgICAgdGhpcy5sYXQgPSBsYXRsbmcubGF0O1xuICAgICAgICAgICAgdGhpcy5sbmcgPSBsYXRsbmcubG5nO1xuICAgICAgICB9XG4gICAgfVxufVxuIl19\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(0);\n\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// Vue2LeafletEditablePlugin.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap b31ff26b210a6292af03","export default {\n    install(){\n        this.init(window.L)\n    },\n    init(L){\n        // 🍂miniclass CancelableEvent (Event objects)\n        // 🍂method cancel()\n        // Cancel any subsequent action.\n\n        // 🍂miniclass VertexEvent (Event objects)\n        // 🍂property vertex: VertexMarker\n        // The vertex that fires the event.\n\n        // 🍂miniclass ShapeEvent (Event objects)\n        // 🍂property shape: Array\n        // The shape (LatLngs array) subject of the action.\n\n        // 🍂miniclass CancelableVertexEvent (Event objects)\n        // 🍂inherits VertexEvent\n        // 🍂inherits CancelableEvent\n\n        // 🍂miniclass CancelableShapeEvent (Event objects)\n        // 🍂inherits ShapeEvent\n        // 🍂inherits CancelableEvent\n\n        // 🍂miniclass LayerEvent (Event objects)\n        // 🍂property layer: object\n        // The Layer (Marker, Polyline…) subject of the action.\n\n        // 🍂namespace Editable; 🍂class Editable; 🍂aka L.Editable\n        // Main edition handler. By default, it is attached to the map\n        // as `map.editTools` property.\n        // Leaflet.Editable is made to be fully extendable. You have three ways to customize\n        // the behaviour: using options, listening to events, or extending.\n        L.Editable = L.Evented.extend({\n\n            statics: {\n                FORWARD: 1,\n                BACKWARD: -1\n            },\n\n            options: {\n\n                // You can pass them when creating a map using the `editOptions` key.\n                // 🍂option zIndex: int = 1000\n                // The default zIndex of the editing tools.\n                zIndex: 1000,\n\n                // 🍂option polygonClass: class = L.Polygon\n                // Class to be used when creating a new Polygon.\n                polygonClass: L.Polygon,\n\n                // 🍂option polylineClass: class = L.Polyline\n                // Class to be used when creating a new Polyline.\n                polylineClass: L.Polyline,\n\n                // 🍂option markerClass: class = L.Marker\n                // Class to be used when creating a new Marker.\n                markerClass: L.Marker,\n\n                // 🍂option rectangleClass: class = L.Rectangle\n                // Class to be used when creating a new Rectangle.\n                rectangleClass: L.Rectangle,\n\n                // 🍂option circleClass: class = L.Circle\n                // Class to be used when creating a new Circle.\n                circleClass: L.Circle,\n\n                // 🍂option drawingCSSClass: string = 'leaflet-editable-drawing'\n                // CSS class to be added to the map container while drawing.\n                drawingCSSClass: 'leaflet-editable-drawing',\n\n                // 🍂option drawingCursor: const = 'crosshair'\n                // Cursor mode set to the map while drawing.\n                drawingCursor: 'crosshair',\n\n                // 🍂option editLayer: Layer = new L.LayerGroup()\n                // Layer used to store edit tools (vertex, line guide…).\n                editLayer: undefined,\n\n                // 🍂option featuresLayer: Layer = new L.LayerGroup()\n                // Default layer used to store drawn features (Marker, Polyline…).\n                featuresLayer: undefined,\n\n                // 🍂option polylineEditorClass: class = PolylineEditor\n                // Class to be used as Polyline editor.\n                polylineEditorClass: undefined,\n\n                // 🍂option polygonEditorClass: class = PolygonEditor\n                // Class to be used as Polygon editor.\n                polygonEditorClass: undefined,\n\n                // 🍂option markerEditorClass: class = MarkerEditor\n                // Class to be used as Marker editor.\n                markerEditorClass: undefined,\n\n                // 🍂option rectangleEditorClass: class = RectangleEditor\n                // Class to be used as Rectangle editor.\n                rectangleEditorClass: undefined,\n\n                // 🍂option circleEditorClass: class = CircleEditor\n                // Class to be used as Circle editor.\n                circleEditorClass: undefined,\n\n                // 🍂option lineGuideOptions: hash = {}\n                // Options to be passed to the line guides.\n                lineGuideOptions: {},\n\n                // 🍂option skipMiddleMarkers: boolean = false\n                // Set this to true if you don't want middle markers.\n                skipMiddleMarkers: false\n\n            },\n\n            initialize: function (map, options) {\n                L.setOptions(this, options);\n                this._lastZIndex = this.options.zIndex;\n                this.map = map;\n                this.editLayer = this.createEditLayer();\n                this.featuresLayer = this.createFeaturesLayer();\n                this.forwardLineGuide = this.createLineGuide();\n                this.backwardLineGuide = this.createLineGuide();\n            },\n\n            fireAndForward: function (type, e) {\n                e = e || {};\n                e.editTools = this;\n                this.fire(type, e);\n                this.map.fire(type, e);\n            },\n\n            createLineGuide: function () {\n                var options = L.extend({dashArray: '5,10', weight: 1, interactive: false}, this.options.lineGuideOptions);\n                return L.polyline([], options);\n            },\n\n            createVertexIcon: function (options) {\n                return L.Browser.mobile && L.Browser.touch ? new L.Editable.TouchVertexIcon(options) : new L.Editable.VertexIcon(options);\n            },\n\n            createEditLayer: function () {\n                return this.options.editLayer || new L.LayerGroup().addTo(this.map);\n            },\n\n            createFeaturesLayer: function () {\n                return this.options.featuresLayer || new L.LayerGroup().addTo(this.map);\n            },\n\n            moveForwardLineGuide: function (latlng) {\n                if (this.forwardLineGuide._latlngs.length) {\n                    this.forwardLineGuide._latlngs[1] = latlng;\n                    this.forwardLineGuide._bounds.extend(latlng);\n                    this.forwardLineGuide.redraw();\n                }\n            },\n\n            moveBackwardLineGuide: function (latlng) {\n                if (this.backwardLineGuide._latlngs.length) {\n                    this.backwardLineGuide._latlngs[1] = latlng;\n                    this.backwardLineGuide._bounds.extend(latlng);\n                    this.backwardLineGuide.redraw();\n                }\n            },\n\n            anchorForwardLineGuide: function (latlng) {\n                this.forwardLineGuide._latlngs[0] = latlng;\n                this.forwardLineGuide._bounds.extend(latlng);\n                this.forwardLineGuide.redraw();\n            },\n\n            anchorBackwardLineGuide: function (latlng) {\n                this.backwardLineGuide._latlngs[0] = latlng;\n                this.backwardLineGuide._bounds.extend(latlng);\n                this.backwardLineGuide.redraw();\n            },\n\n            attachForwardLineGuide: function () {\n                this.editLayer.addLayer(this.forwardLineGuide);\n            },\n\n            attachBackwardLineGuide: function () {\n                this.editLayer.addLayer(this.backwardLineGuide);\n            },\n\n            detachForwardLineGuide: function () {\n                this.forwardLineGuide.setLatLngs([]);\n                this.editLayer.removeLayer(this.forwardLineGuide);\n            },\n\n            detachBackwardLineGuide: function () {\n                this.backwardLineGuide.setLatLngs([]);\n                this.editLayer.removeLayer(this.backwardLineGuide);\n            },\n\n            blockEvents: function () {\n                // Hack: force map not to listen to other layers events while drawing.\n                if (!this._oldTargets) {\n                    this._oldTargets = this.map._targets;\n                    this.map._targets = {};\n                }\n            },\n\n            unblockEvents: function () {\n                if (this._oldTargets) {\n                    // Reset, but keep targets created while drawing.\n                    this.map._targets = L.extend(this.map._targets, this._oldTargets);\n                    delete this._oldTargets;\n                }\n            },\n\n            registerForDrawing: function (editor) {\n                if (this._drawingEditor) this.unregisterForDrawing(this._drawingEditor);\n                this.blockEvents();\n                editor.reset();  // Make sure editor tools still receive events.\n                this._drawingEditor = editor;\n                this.map.on('mousemove touchmove', editor.onDrawingMouseMove, editor);\n                this.map.on('mousedown', this.onMousedown, this);\n                this.map.on('mouseup', this.onMouseup, this);\n                L.DomUtil.addClass(this.map._container, this.options.drawingCSSClass);\n                this.defaultMapCursor = this.map._container.style.cursor;\n                this.map._container.style.cursor = this.options.drawingCursor;\n            },\n\n            unregisterForDrawing: function (editor) {\n                this.unblockEvents();\n                L.DomUtil.removeClass(this.map._container, this.options.drawingCSSClass);\n                this.map._container.style.cursor = this.defaultMapCursor;\n                editor = editor || this._drawingEditor;\n                if (!editor) return;\n                this.map.off('mousemove touchmove', editor.onDrawingMouseMove, editor);\n                this.map.off('mousedown', this.onMousedown, this);\n                this.map.off('mouseup', this.onMouseup, this);\n                if (editor !== this._drawingEditor) return;\n                delete this._drawingEditor;\n                if (editor._drawing) editor.cancelDrawing();\n            },\n\n            onMousedown: function (e) {\n                if (e.originalEvent.which != 1) return;\n                this._mouseDown = e;\n                this._drawingEditor.onDrawingMouseDown(e);\n            },\n\n            onMouseup: function (e) {\n                if (this._mouseDown) {\n                    var editor = this._drawingEditor,\n                        mouseDown = this._mouseDown;\n                    this._mouseDown = null;\n                    editor.onDrawingMouseUp(e);\n                    if (this._drawingEditor !== editor) return;  // onDrawingMouseUp may call unregisterFromDrawing.\n                    var origin = L.point(mouseDown.originalEvent.clientX, mouseDown.originalEvent.clientY);\n                    var distance = L.point(e.originalEvent.clientX, e.originalEvent.clientY).distanceTo(origin);\n                    if (Math.abs(distance) < 9 * (window.devicePixelRatio || 1)) this._drawingEditor.onDrawingClick(e);\n                }\n            },\n\n            // 🍂section Public methods\n            // You will generally access them by the `map.editTools`\n            // instance:\n            //\n            // `map.editTools.startPolyline();`\n\n            // 🍂method drawing(): boolean\n            // Return true if any drawing action is ongoing.\n            drawing: function () {\n                return this._drawingEditor && this._drawingEditor.drawing();\n            },\n\n            // 🍂method stopDrawing()\n            // When you need to stop any ongoing drawing, without needing to know which editor is active.\n            stopDrawing: function () {\n                this.unregisterForDrawing();\n            },\n\n            // 🍂method commitDrawing()\n            // When you need to commit any ongoing drawing, without needing to know which editor is active.\n            commitDrawing: function (e) {\n                if (!this._drawingEditor) return;\n                this._drawingEditor.commitDrawing(e);\n            },\n\n            connectCreatedToMap: function (layer) {\n                return this.featuresLayer.addLayer(layer);\n            },\n\n            // 🍂method startPolyline(latlng: L.LatLng, options: hash): L.Polyline\n            // Start drawing a Polyline. If `latlng` is given, a first point will be added. In any case, continuing on user click.\n            // If `options` is given, it will be passed to the Polyline class constructor.\n            startPolyline: function (latlng, options) {\n                var line = this.createPolyline([], options);\n                line.enableEdit(this.map).newShape(latlng);\n                return line;\n            },\n\n            // 🍂method startPolygon(latlng: L.LatLng, options: hash): L.Polygon\n            // Start drawing a Polygon. If `latlng` is given, a first point will be added. In any case, continuing on user click.\n            // If `options` is given, it will be passed to the Polygon class constructor.\n            startPolygon: function (latlng, options) {\n                var polygon = this.createPolygon([], options);\n                polygon.enableEdit(this.map).newShape(latlng);\n                return polygon;\n            },\n\n            // 🍂method startMarker(latlng: L.LatLng, options: hash): L.Marker\n            // Start adding a Marker. If `latlng` is given, the Marker will be shown first at this point.\n            // In any case, it will follow the user mouse, and will have a final `latlng` on next click (or touch).\n            // If `options` is given, it will be passed to the Marker class constructor.\n            startMarker: function (latlng, options) {\n                latlng = latlng || this.map.getCenter().clone();\n                var marker = this.createMarker(latlng, options);\n                marker.enableEdit(this.map).startDrawing();\n                return marker;\n            },\n\n            // 🍂method startRectangle(latlng: L.LatLng, options: hash): L.Rectangle\n            // Start drawing a Rectangle. If `latlng` is given, the Rectangle anchor will be added. In any case, continuing on user drag.\n            // If `options` is given, it will be passed to the Rectangle class constructor.\n            startRectangle: function(latlng, options) {\n                var corner = latlng || L.latLng([0, 0]);\n                var bounds = new L.LatLngBounds(corner, corner);\n                var rectangle = this.createRectangle(bounds, options);\n                rectangle.enableEdit(this.map).startDrawing();\n                return rectangle;\n            },\n\n            // 🍂method startCircle(latlng: L.LatLng, options: hash): L.Circle\n            // Start drawing a Circle. If `latlng` is given, the Circle anchor will be added. In any case, continuing on user drag.\n            // If `options` is given, it will be passed to the Circle class constructor.\n            startCircle: function (latlng, options) {\n                latlng = latlng || this.map.getCenter().clone();\n                var circle = this.createCircle(latlng, options);\n                circle.enableEdit(this.map).startDrawing();\n                return circle;\n            },\n\n            startHole: function (editor, latlng) {\n                editor.newHole(latlng);\n            },\n\n            createLayer: function (klass, latlngs, options) {\n                options = L.Util.extend({editOptions: {editTools: this}}, options);\n                var layer = new klass(latlngs, options);\n                // 🍂namespace Editable\n                // 🍂event editable:created: LayerEvent\n                // Fired when a new feature (Marker, Polyline…) is created.\n                this.fireAndForward('editable:created', {layer: layer});\n                return layer;\n            },\n\n            createPolyline: function (latlngs, options) {\n                return this.createLayer(options && options.polylineClass || this.options.polylineClass, latlngs, options);\n            },\n\n            createPolygon: function (latlngs, options) {\n                return this.createLayer(options && options.polygonClass || this.options.polygonClass, latlngs, options);\n            },\n\n            createMarker: function (latlng, options) {\n                return this.createLayer(options && options.markerClass || this.options.markerClass, latlng, options);\n            },\n\n            createRectangle: function (bounds, options) {\n                return this.createLayer(options && options.rectangleClass || this.options.rectangleClass, bounds, options);\n            },\n\n            createCircle: function (latlng, options) {\n                return this.createLayer(options && options.circleClass || this.options.circleClass, latlng, options);\n            }\n\n        });\n\n        L.extend(L.Editable, {\n\n            makeCancellable: function (e) {\n                e.cancel = function () {\n                    e._cancelled = true;\n                };\n            }\n\n        });\n\n        // 🍂namespace Map; 🍂class Map\n        // Leaflet.Editable add options and events to the `L.Map` object.\n        // See `Editable` events for the list of events fired on the Map.\n        // 🍂example\n        //\n        // ```js\n        // var map = L.map('map', {\n        //  editable: true,\n        //  editOptions: {\n        //    …\n        // }\n        // });\n        // ```\n        // 🍂section Editable Map Options\n        L.Map.mergeOptions({\n\n            // 🍂namespace Map\n            // 🍂section Map Options\n            // 🍂option editToolsClass: class = L.Editable\n            // Class to be used as vertex, for path editing.\n            editToolsClass: L.Editable,\n\n            // 🍂option editable: boolean = false\n            // Whether to create a L.Editable instance at map init.\n            editable: false,\n\n            // 🍂option editOptions: hash = {}\n            // Options to pass to L.Editable when instantiating.\n            editOptions: {}\n\n        });\n\n        L.Map.addInitHook(function () {\n\n            this.whenReady(function () {\n                if (this.options.editable) {\n                    this.editTools = new this.options.editToolsClass(this, this.options.editOptions);\n                }\n            });\n\n        });\n\n        L.Editable.VertexIcon = L.DivIcon.extend({\n\n            options: {\n                iconSize: new L.Point(8, 8)\n            }\n\n        });\n\n        L.Editable.TouchVertexIcon = L.Editable.VertexIcon.extend({\n\n            options: {\n                iconSize: new L.Point(20, 20)\n            }\n\n        });\n\n\n        // 🍂namespace Editable; 🍂class VertexMarker; Handler for dragging path vertices.\n        L.Editable.VertexMarker = L.Marker.extend({\n\n            options: {\n                draggable: true,\n                className: 'leaflet-div-icon leaflet-vertex-icon'\n            },\n\n\n            // 🍂section Public methods\n            // The marker used to handle path vertex. You will usually interact with a `VertexMarker`\n            // instance when listening for events like `editable:vertex:ctrlclick`.\n\n            initialize: function (latlng, latlngs, editor, options) {\n                // We don't use this._latlng, because on drag Leaflet replace it while\n                // we want to keep reference.\n                this.latlng = latlng;\n                this.latlngs = latlngs;\n                this.editor = editor;\n                L.Marker.prototype.initialize.call(this, latlng, options);\n                this.options.icon = this.editor.tools.createVertexIcon({className: this.options.className});\n                this.latlng.__vertex = this;\n                this.editor.editLayer.addLayer(this);\n                this.setZIndexOffset(editor.tools._lastZIndex + 1);\n            },\n\n            onAdd: function (map) {\n                L.Marker.prototype.onAdd.call(this, map);\n                this.on('drag', this.onDrag);\n                this.on('dragstart', this.onDragStart);\n                this.on('dragend', this.onDragEnd);\n                this.on('mouseup', this.onMouseup);\n                this.on('click', this.onClick);\n                this.on('contextmenu', this.onContextMenu);\n                this.on('mousedown touchstart', this.onMouseDown);\n                this.on('mouseover', this.onMouseOver);\n                this.on('mouseout', this.onMouseOut);\n                this.addMiddleMarkers();\n            },\n\n            onRemove: function (map) {\n                if (this.middleMarker) this.middleMarker.delete();\n                delete this.latlng.__vertex;\n                this.off('drag', this.onDrag);\n                this.off('dragstart', this.onDragStart);\n                this.off('dragend', this.onDragEnd);\n                this.off('mouseup', this.onMouseup);\n                this.off('click', this.onClick);\n                this.off('contextmenu', this.onContextMenu);\n                this.off('mousedown touchstart', this.onMouseDown);\n                this.off('mouseover', this.onMouseOver);\n                this.off('mouseout', this.onMouseOut);\n                L.Marker.prototype.onRemove.call(this, map);\n            },\n\n            onDrag: function (e) {\n                e.vertex = this;\n                this.editor.onVertexMarkerDrag(e);\n                var iconPos = L.DomUtil.getPosition(this._icon),\n                    latlng = this._map.layerPointToLatLng(iconPos);\n                this.latlng.update(latlng);\n                this._latlng = this.latlng;  // Push back to Leaflet our reference.\n                this.editor.refresh();\n                if (this.middleMarker) this.middleMarker.updateLatLng();\n                var next = this.getNext();\n                if (next && next.middleMarker) next.middleMarker.updateLatLng();\n            },\n\n            onDragStart: function (e) {\n                e.vertex = this;\n                this.editor.onVertexMarkerDragStart(e);\n            },\n\n            onDragEnd: function (e) {\n                e.vertex = this;\n                this.editor.onVertexMarkerDragEnd(e);\n            },\n\n            onClick: function (e) {\n                e.vertex = this;\n                this.editor.onVertexMarkerClick(e);\n            },\n\n            onMouseup: function (e) {\n                L.DomEvent.stop(e);\n                e.vertex = this;\n                this.editor.map.fire('mouseup', e);\n            },\n\n            onContextMenu: function (e) {\n                e.vertex = this;\n                this.editor.onVertexMarkerContextMenu(e);\n            },\n\n            onMouseDown: function (e) {\n                e.vertex = this;\n                this.editor.onVertexMarkerMouseDown(e);\n            },\n\n            onMouseOver: function (e) {\n                e.vertex = this;\n                this.editor.onVertexMarkerMouseOver(e);\n            },\n\n            onMouseOut: function (e) {\n                e.vertex = this;\n                this.editor.onVertexMarkerMouseOut(e);\n            },\n\n            // 🍂method delete()\n            // Delete a vertex and the related LatLng.\n            delete: function () {\n                var next = this.getNext();  // Compute before changing latlng\n                this.latlngs.splice(this.getIndex(), 1);\n                this.editor.editLayer.removeLayer(this);\n                this.editor.onVertexDeleted({latlng: this.latlng, vertex: this});\n                if (!this.latlngs.length) this.editor.deleteShape(this.latlngs);\n                if (next) next.resetMiddleMarker();\n                this.editor.refresh();\n            },\n\n            // 🍂method getIndex(): int\n            // Get the index of the current vertex among others of the same LatLngs group.\n            getIndex: function () {\n                return this.latlngs.indexOf(this.latlng);\n            },\n\n            // 🍂method getLastIndex(): int\n            // Get last vertex index of the LatLngs group of the current vertex.\n            getLastIndex: function () {\n                return this.latlngs.length - 1;\n            },\n\n            // 🍂method getPrevious(): VertexMarker\n            // Get the previous VertexMarker in the same LatLngs group.\n            getPrevious: function () {\n                if (this.latlngs.length < 2) return;\n                var index = this.getIndex(),\n                    previousIndex = index - 1;\n                if (index === 0 && this.editor.CLOSED) previousIndex = this.getLastIndex();\n                var previous = this.latlngs[previousIndex];\n                if (previous) return previous.__vertex;\n            },\n\n            // 🍂method getNext(): VertexMarker\n            // Get the next VertexMarker in the same LatLngs group.\n            getNext: function () {\n                if (this.latlngs.length < 2) return;\n                var index = this.getIndex(),\n                    nextIndex = index + 1;\n                if (index === this.getLastIndex() && this.editor.CLOSED) nextIndex = 0;\n                var next = this.latlngs[nextIndex];\n                if (next) return next.__vertex;\n            },\n\n            addMiddleMarker: function (previous) {\n                if (!this.editor.hasMiddleMarkers()) return;\n                previous = previous || this.getPrevious();\n                if (previous && !this.middleMarker) this.middleMarker = this.editor.addMiddleMarker(previous, this, this.latlngs, this.editor);\n            },\n\n            addMiddleMarkers: function () {\n                if (!this.editor.hasMiddleMarkers()) return;\n                var previous = this.getPrevious();\n                if (previous) this.addMiddleMarker(previous);\n                var next = this.getNext();\n                if (next) next.resetMiddleMarker();\n            },\n\n            resetMiddleMarker: function () {\n                if (this.middleMarker) this.middleMarker.delete();\n                this.addMiddleMarker();\n            },\n\n            // 🍂method split()\n            // Split the vertex LatLngs group at its index, if possible.\n            split: function () {\n                if (!this.editor.splitShape) return;  // Only for PolylineEditor\n                this.editor.splitShape(this.latlngs, this.getIndex());\n            },\n\n            // 🍂method continue()\n            // Continue the vertex LatLngs from this vertex. Only active for first and last vertices of a Polyline.\n            continue: function () {\n                if (!this.editor.continueBackward) return;  // Only for PolylineEditor\n                var index = this.getIndex();\n                if (index === 0) this.editor.continueBackward(this.latlngs);\n                else if (index === this.getLastIndex()) this.editor.continueForward(this.latlngs);\n            }\n\n        });\n\n        L.Editable.mergeOptions({\n\n            // 🍂namespace Editable\n            // 🍂option vertexMarkerClass: class = VertexMarker\n            // Class to be used as vertex, for path editing.\n            vertexMarkerClass: L.Editable.VertexMarker\n\n        });\n\n        L.Editable.MiddleMarker = L.Marker.extend({\n\n            options: {\n                opacity: 0.5,\n                className: 'leaflet-div-icon leaflet-middle-icon',\n                draggable: true\n            },\n\n            initialize: function (left, right, latlngs, editor, options) {\n                this.left = left;\n                this.right = right;\n                this.editor = editor;\n                this.latlngs = latlngs;\n                L.Marker.prototype.initialize.call(this, this.computeLatLng(), options);\n                this._opacity = this.options.opacity;\n                this.options.icon = this.editor.tools.createVertexIcon({className: this.options.className});\n                this.editor.editLayer.addLayer(this);\n                this.setVisibility();\n            },\n\n            setVisibility: function () {\n                var leftPoint = this._map.latLngToContainerPoint(this.left.latlng),\n                    rightPoint = this._map.latLngToContainerPoint(this.right.latlng),\n                    size = L.point(this.options.icon.options.iconSize);\n                if (leftPoint.distanceTo(rightPoint) < size.x * 3) this.hide();\n                else this.show();\n            },\n\n            show: function () {\n                this.setOpacity(this._opacity);\n            },\n\n            hide: function () {\n                this.setOpacity(0);\n            },\n\n            updateLatLng: function () {\n                this.setLatLng(this.computeLatLng());\n                this.setVisibility();\n            },\n\n            computeLatLng: function () {\n                var leftPoint = this.editor.map.latLngToContainerPoint(this.left.latlng),\n                    rightPoint = this.editor.map.latLngToContainerPoint(this.right.latlng),\n                    y = (leftPoint.y + rightPoint.y) / 2,\n                    x = (leftPoint.x + rightPoint.x) / 2;\n                return this.editor.map.containerPointToLatLng([x, y]);\n            },\n\n            onAdd: function (map) {\n                L.Marker.prototype.onAdd.call(this, map);\n                L.DomEvent.on(this._icon, 'mousedown touchstart', this.onMouseDown, this);\n                map.on('zoomend', this.setVisibility, this);\n            },\n\n            onRemove: function (map) {\n                delete this.right.middleMarker;\n                L.DomEvent.off(this._icon, 'mousedown touchstart', this.onMouseDown, this);\n                map.off('zoomend', this.setVisibility, this);\n                L.Marker.prototype.onRemove.call(this, map);\n            },\n\n            onMouseDown: function (e) {\n                var iconPos = L.DomUtil.getPosition(this._icon),\n                    latlng = this.editor.map.layerPointToLatLng(iconPos);\n                e = {\n                    originalEvent: e,\n                    latlng: latlng\n                };\n                if (this.options.opacity === 0) return;\n                L.Editable.makeCancellable(e);\n                this.editor.onMiddleMarkerMouseDown(e);\n                if (e._cancelled) return;\n                this.latlngs.splice(this.index(), 0, e.latlng);\n                this.editor.refresh();\n                var icon = this._icon;\n                var marker = this.editor.addVertexMarker(e.latlng, this.latlngs);\n                this.editor.onNewVertex(marker);\n                /* Hack to workaround browser not firing touchend when element is no more on DOM */\n                var parent = marker._icon.parentNode;\n                parent.removeChild(marker._icon);\n                marker._icon = icon;\n                parent.appendChild(marker._icon);\n                marker._initIcon();\n                marker._initInteraction();\n                marker.setOpacity(1);\n                /* End hack */\n                // Transfer ongoing dragging to real marker\n                L.Draggable._dragging = false;\n                marker.dragging._draggable._onDown(e.originalEvent);\n                this.delete();\n            },\n\n            delete: function () {\n                this.editor.editLayer.removeLayer(this);\n            },\n\n            index: function () {\n                return this.latlngs.indexOf(this.right.latlng);\n            }\n\n        });\n\n        L.Editable.mergeOptions({\n\n            // 🍂namespace Editable\n            // 🍂option middleMarkerClass: class = VertexMarker\n            // Class to be used as middle vertex, pulled by the user to create a new point in the middle of a path.\n            middleMarkerClass: L.Editable.MiddleMarker\n\n        });\n\n        // 🍂namespace Editable; 🍂class BaseEditor; 🍂aka L.Editable.BaseEditor\n        // When editing a feature (Marker, Polyline…), an editor is attached to it. This\n        // editor basically knows how to handle the edition.\n        L.Editable.BaseEditor = L.Handler.extend({\n\n            initialize: function (map, feature, options) {\n                L.setOptions(this, options);\n                this.map = map;\n                this.feature = feature;\n                this.feature.editor = this;\n                this.editLayer = new L.LayerGroup();\n                this.tools = this.options.editTools || map.editTools;\n            },\n\n            // 🍂method enable(): this\n            // Set up the drawing tools for the feature to be editable.\n            addHooks: function () {\n                if (this.isConnected()) this.onFeatureAdd();\n                else this.feature.once('add', this.onFeatureAdd, this);\n                this.onEnable();\n                this.feature.on(this._getEvents(), this);\n            },\n\n            // 🍂method disable(): this\n            // Remove the drawing tools for the feature.\n            removeHooks: function () {\n                this.feature.off(this._getEvents(), this);\n                if (this.feature.dragging) this.feature.dragging.disable();\n                this.editLayer.clearLayers();\n                this.tools.editLayer.removeLayer(this.editLayer);\n                this.onDisable();\n                if (this._drawing) this.cancelDrawing();\n            },\n\n            // 🍂method drawing(): boolean\n            // Return true if any drawing action is ongoing with this editor.\n            drawing: function () {\n                return !!this._drawing;\n            },\n\n            reset: function () {},\n\n            onFeatureAdd: function () {\n                this.tools.editLayer.addLayer(this.editLayer);\n                if (this.feature.dragging) this.feature.dragging.enable();\n            },\n\n            hasMiddleMarkers: function () {\n                return !this.options.skipMiddleMarkers && !this.tools.options.skipMiddleMarkers;\n            },\n\n            fireAndForward: function (type, e) {\n                e = e || {};\n                e.layer = this.feature;\n                this.feature.fire(type, e);\n                this.tools.fireAndForward(type, e);\n            },\n\n            onEnable: function () {\n                // 🍂namespace Editable\n                // 🍂event editable:enable: Event\n                // Fired when an existing feature is ready to be edited.\n                this.fireAndForward('editable:enable');\n            },\n\n            onDisable: function () {\n                // 🍂namespace Editable\n                // 🍂event editable:disable: Event\n                // Fired when an existing feature is not ready anymore to be edited.\n                this.fireAndForward('editable:disable');\n            },\n\n            onEditing: function () {\n                // 🍂namespace Editable\n                // 🍂event editable:editing: Event\n                // Fired as soon as any change is made to the feature geometry.\n                this.fireAndForward('editable:editing');\n            },\n\n            onStartDrawing: function () {\n                // 🍂namespace Editable\n                // 🍂section Drawing events\n                // 🍂event editable:drawing:start: Event\n                // Fired when a feature is to be drawn.\n                this.fireAndForward('editable:drawing:start');\n            },\n\n            onEndDrawing: function () {\n                // 🍂namespace Editable\n                // 🍂section Drawing events\n                // 🍂event editable:drawing:end: Event\n                // Fired when a feature is not drawn anymore.\n                this.fireAndForward('editable:drawing:end');\n            },\n\n            onCancelDrawing: function () {\n                // 🍂namespace Editable\n                // 🍂section Drawing events\n                // 🍂event editable:drawing:cancel: Event\n                // Fired when user cancel drawing while a feature is being drawn.\n                this.fireAndForward('editable:drawing:cancel');\n            },\n\n            onCommitDrawing: function (e) {\n                // 🍂namespace Editable\n                // 🍂section Drawing events\n                // 🍂event editable:drawing:commit: Event\n                // Fired when user finish drawing a feature.\n                this.fireAndForward('editable:drawing:commit', e);\n            },\n\n            onDrawingMouseDown: function (e) {\n                // 🍂namespace Editable\n                // 🍂section Drawing events\n                // 🍂event editable:drawing:mousedown: Event\n                // Fired when user `mousedown` while drawing.\n                this.fireAndForward('editable:drawing:mousedown', e);\n            },\n\n            onDrawingMouseUp: function (e) {\n                // 🍂namespace Editable\n                // 🍂section Drawing events\n                // 🍂event editable:drawing:mouseup: Event\n                // Fired when user `mouseup` while drawing.\n                this.fireAndForward('editable:drawing:mouseup', e);\n            },\n\n            startDrawing: function () {\n                if (!this._drawing) this._drawing = L.Editable.FORWARD;\n                this.tools.registerForDrawing(this);\n                this.onStartDrawing();\n            },\n\n            commitDrawing: function (e) {\n                this.onCommitDrawing(e);\n                this.endDrawing();\n            },\n\n            cancelDrawing: function () {\n                // If called during a vertex drag, the vertex will be removed before\n                // the mouseup fires on it. This is a workaround. Maybe better fix is\n                // To have L.Draggable reset it's status on disable (Leaflet side).\n                L.Draggable._dragging = false;\n                this.onCancelDrawing();\n                this.endDrawing();\n            },\n\n            endDrawing: function () {\n                this._drawing = false;\n                this.tools.unregisterForDrawing(this);\n                this.onEndDrawing();\n            },\n\n            onDrawingClick: function (e) {\n                if (!this.drawing()) return;\n                L.Editable.makeCancellable(e);\n                // 🍂namespace Editable\n                // 🍂section Drawing events\n                // 🍂event editable:drawing:click: CancelableEvent\n                // Fired when user `click` while drawing, before any internal action is being processed.\n                this.fireAndForward('editable:drawing:click', e);\n                if (e._cancelled) return;\n                if (!this.isConnected()) this.connect(e);\n                this.processDrawingClick(e);\n            },\n\n            isConnected: function () {\n                return this.map.hasLayer(this.feature);\n            },\n\n            connect: function () {\n                this.tools.connectCreatedToMap(this.feature);\n                this.tools.editLayer.addLayer(this.editLayer);\n            },\n\n            onMove: function (e) {\n                // 🍂namespace Editable\n                // 🍂section Drawing events\n                // 🍂event editable:drawing:move: Event\n                // Fired when `move` mouse while drawing, while dragging a marker, and while dragging a vertex.\n                this.fireAndForward('editable:drawing:move', e);\n            },\n\n            onDrawingMouseMove: function (e) {\n                this.onMove(e);\n            },\n\n            _getEvents: function () {\n                return {\n                    dragstart: this.onDragStart,\n                    drag: this.onDrag,\n                    dragend: this.onDragEnd,\n                    remove: this.disable\n                };\n            },\n\n            onDragStart: function (e) {\n                this.onEditing();\n                // 🍂namespace Editable\n                // 🍂event editable:dragstart: Event\n                // Fired before a path feature is dragged.\n                this.fireAndForward('editable:dragstart', e);\n            },\n\n            onDrag: function (e) {\n                this.onMove(e);\n                // 🍂namespace Editable\n                // 🍂event editable:drag: Event\n                // Fired when a path feature is being dragged.\n                this.fireAndForward('editable:drag', e);\n            },\n\n            onDragEnd: function (e) {\n                // 🍂namespace Editable\n                // 🍂event editable:dragend: Event\n                // Fired after a path feature has been dragged.\n                this.fireAndForward('editable:dragend', e);\n            }\n\n        });\n\n        // 🍂namespace Editable; 🍂class MarkerEditor; 🍂aka L.Editable.MarkerEditor\n        // 🍂inherits BaseEditor\n        // Editor for Marker.\n        L.Editable.MarkerEditor = L.Editable.BaseEditor.extend({\n\n            onDrawingMouseMove: function (e) {\n                L.Editable.BaseEditor.prototype.onDrawingMouseMove.call(this, e);\n                if (this._drawing) this.feature.setLatLng(e.latlng);\n            },\n\n            processDrawingClick: function (e) {\n                // 🍂namespace Editable\n                // 🍂section Drawing events\n                // 🍂event editable:drawing:clicked: Event\n                // Fired when user `click` while drawing, after all internal actions.\n                this.fireAndForward('editable:drawing:clicked', e);\n                this.commitDrawing(e);\n            },\n\n            connect: function (e) {\n                // On touch, the latlng has not been updated because there is\n                // no mousemove.\n                if (e) this.feature._latlng = e.latlng;\n                L.Editable.BaseEditor.prototype.connect.call(this, e);\n            }\n\n        });\n\n        // 🍂namespace Editable; 🍂class PathEditor; 🍂aka L.Editable.PathEditor\n        // 🍂inherits BaseEditor\n        // Base class for all path editors.\n        L.Editable.PathEditor = L.Editable.BaseEditor.extend({\n\n            CLOSED: false,\n            MIN_VERTEX: 2,\n\n            addHooks: function () {\n                L.Editable.BaseEditor.prototype.addHooks.call(this);\n                if (this.feature) this.initVertexMarkers();\n                return this;\n            },\n\n            initVertexMarkers: function (latlngs) {\n                if (!this.enabled()) return;\n                latlngs = latlngs || this.getLatLngs();\n                if (isFlat(latlngs)) this.addVertexMarkers(latlngs);\n                else for (var i = 0; i < latlngs.length; i++) this.initVertexMarkers(latlngs[i]);\n            },\n\n            getLatLngs: function () {\n                return this.feature.getLatLngs();\n            },\n\n            // 🍂method reset()\n            // Rebuild edit elements (Vertex, MiddleMarker, etc.).\n            reset: function () {\n                this.editLayer.clearLayers();\n                this.initVertexMarkers();\n            },\n\n            addVertexMarker: function (latlng, latlngs) {\n                return new this.tools.options.vertexMarkerClass(latlng, latlngs, this);\n            },\n\n            onNewVertex: function (vertex) {\n                // 🍂namespace Editable\n                // 🍂section Vertex events\n                // 🍂event editable:vertex:new: VertexEvent\n                // Fired when a new vertex is created.\n                this.fireAndForward('editable:vertex:new', {latlng: vertex.latlng, vertex: vertex});\n            },\n\n            addVertexMarkers: function (latlngs) {\n                for (var i = 0; i < latlngs.length; i++) {\n                    this.addVertexMarker(latlngs[i], latlngs);\n                }\n            },\n\n            refreshVertexMarkers: function (latlngs) {\n                latlngs = latlngs || this.getDefaultLatLngs();\n                for (var i = 0; i < latlngs.length; i++) {\n                    latlngs[i].__vertex.update();\n                }\n            },\n\n            addMiddleMarker: function (left, right, latlngs) {\n                return new this.tools.options.middleMarkerClass(left, right, latlngs, this);\n            },\n\n            onVertexMarkerClick: function (e) {\n                L.Editable.makeCancellable(e);\n                // 🍂namespace Editable\n                // 🍂section Vertex events\n                // 🍂event editable:vertex:click: CancelableVertexEvent\n                // Fired when a `click` is issued on a vertex, before any internal action is being processed.\n                this.fireAndForward('editable:vertex:click', e);\n                if (e._cancelled) return;\n                if (this.tools.drawing() && this.tools._drawingEditor !== this) return;\n                var index = e.vertex.getIndex(), commit;\n                if (e.originalEvent.ctrlKey) {\n                    this.onVertexMarkerCtrlClick(e);\n                } else if (e.originalEvent.altKey) {\n                    this.onVertexMarkerAltClick(e);\n                } else if (e.originalEvent.shiftKey) {\n                    this.onVertexMarkerShiftClick(e);\n                } else if (e.originalEvent.metaKey) {\n                    this.onVertexMarkerMetaKeyClick(e);\n                } else if (index === e.vertex.getLastIndex() && this._drawing === L.Editable.FORWARD) {\n                    if (index >= this.MIN_VERTEX - 1) commit = true;\n                } else if (index === 0 && this._drawing === L.Editable.BACKWARD && this._drawnLatLngs.length >= this.MIN_VERTEX) {\n                    commit = true;\n                } else if (index === 0 && this._drawing === L.Editable.FORWARD && this._drawnLatLngs.length >= this.MIN_VERTEX && this.CLOSED) {\n                    commit = true;  // Allow to close on first point also for polygons\n                } else {\n                    this.onVertexRawMarkerClick(e);\n                }\n                // 🍂namespace Editable\n                // 🍂section Vertex events\n                // 🍂event editable:vertex:clicked: VertexEvent\n                // Fired when a `click` is issued on a vertex, after all internal actions.\n                this.fireAndForward('editable:vertex:clicked', e);\n                if (commit) this.commitDrawing(e);\n            },\n\n            onVertexRawMarkerClick: function (e) {\n                // 🍂namespace Editable\n                // 🍂section Vertex events\n                // 🍂event editable:vertex:rawclick: CancelableVertexEvent\n                // Fired when a `click` is issued on a vertex without any special key and without being in drawing mode.\n                this.fireAndForward('editable:vertex:rawclick', e);\n                if (e._cancelled) return;\n                if (!this.vertexCanBeDeleted(e.vertex)) return;\n                e.vertex.delete();\n            },\n\n            vertexCanBeDeleted: function (vertex) {\n                return vertex.latlngs.length > this.MIN_VERTEX;\n            },\n\n            onVertexDeleted: function (e) {\n                // 🍂namespace Editable\n                // 🍂section Vertex events\n                // 🍂event editable:vertex:deleted: VertexEvent\n                // Fired after a vertex has been deleted by user.\n                this.fireAndForward('editable:vertex:deleted', e);\n            },\n\n            onVertexMarkerCtrlClick: function (e) {\n                // 🍂namespace Editable\n                // 🍂section Vertex events\n                // 🍂event editable:vertex:ctrlclick: VertexEvent\n                // Fired when a `click` with `ctrlKey` is issued on a vertex.\n                this.fireAndForward('editable:vertex:ctrlclick', e);\n            },\n\n            onVertexMarkerShiftClick: function (e) {\n                // 🍂namespace Editable\n                // 🍂section Vertex events\n                // 🍂event editable:vertex:shiftclick: VertexEvent\n                // Fired when a `click` with `shiftKey` is issued on a vertex.\n                this.fireAndForward('editable:vertex:shiftclick', e);\n            },\n\n            onVertexMarkerMetaKeyClick: function (e) {\n                // 🍂namespace Editable\n                // 🍂section Vertex events\n                // 🍂event editable:vertex:metakeyclick: VertexEvent\n                // Fired when a `click` with `metaKey` is issued on a vertex.\n                this.fireAndForward('editable:vertex:metakeyclick', e);\n            },\n\n            onVertexMarkerAltClick: function (e) {\n                // 🍂namespace Editable\n                // 🍂section Vertex events\n                // 🍂event editable:vertex:altclick: VertexEvent\n                // Fired when a `click` with `altKey` is issued on a vertex.\n                this.fireAndForward('editable:vertex:altclick', e);\n            },\n\n            onVertexMarkerContextMenu: function (e) {\n                // 🍂namespace Editable\n                // 🍂section Vertex events\n                // 🍂event editable:vertex:contextmenu: VertexEvent\n                // Fired when a `contextmenu` is issued on a vertex.\n                this.fireAndForward('editable:vertex:contextmenu', e);\n            },\n\n            onVertexMarkerMouseDown: function (e) {\n                // 🍂namespace Editable\n                // 🍂section Vertex events\n                // 🍂event editable:vertex:mousedown: VertexEvent\n                // Fired when user `mousedown` a vertex.\n                this.fireAndForward('editable:vertex:mousedown', e);\n            },\n\n            onVertexMarkerMouseOver: function (e) {\n                // 🍂namespace Editable\n                // 🍂section Vertex events\n                // 🍂event editable:vertex:mouseover: VertexEvent\n                // Fired when a user's mouse enters the vertex\n                this.fireAndForward('editable:vertex:mouseover', e);\n            },\n\n            onVertexMarkerMouseOut: function (e) {\n                // 🍂namespace Editable\n                // 🍂section Vertex events\n                // 🍂event editable:vertex:mouseout: VertexEvent\n                // Fired when a user's mouse leaves the vertex\n                this.fireAndForward('editable:vertex:mouseout', e);\n            },\n\n            onMiddleMarkerMouseDown: function (e) {\n                // 🍂namespace Editable\n                // 🍂section MiddleMarker events\n                // 🍂event editable:middlemarker:mousedown: VertexEvent\n                // Fired when user `mousedown` a middle marker.\n                this.fireAndForward('editable:middlemarker:mousedown', e);\n            },\n\n            onVertexMarkerDrag: function (e) {\n                this.onMove(e);\n                if (this.feature._bounds) this.extendBounds(e);\n                // 🍂namespace Editable\n                // 🍂section Vertex events\n                // 🍂event editable:vertex:drag: VertexEvent\n                // Fired when a vertex is dragged by user.\n                this.fireAndForward('editable:vertex:drag', e);\n            },\n\n            onVertexMarkerDragStart: function (e) {\n                // 🍂namespace Editable\n                // 🍂section Vertex events\n                // 🍂event editable:vertex:dragstart: VertexEvent\n                // Fired before a vertex is dragged by user.\n                this.fireAndForward('editable:vertex:dragstart', e);\n            },\n\n            onVertexMarkerDragEnd: function (e) {\n                // 🍂namespace Editable\n                // 🍂section Vertex events\n                // 🍂event editable:vertex:dragend: VertexEvent\n                // Fired after a vertex is dragged by user.\n                this.fireAndForward('editable:vertex:dragend', e);\n            },\n\n            setDrawnLatLngs: function (latlngs) {\n                this._drawnLatLngs = latlngs || this.getDefaultLatLngs();\n            },\n\n            startDrawing: function () {\n                if (!this._drawnLatLngs) this.setDrawnLatLngs();\n                L.Editable.BaseEditor.prototype.startDrawing.call(this);\n            },\n\n            startDrawingForward: function () {\n                this.startDrawing();\n            },\n\n            endDrawing: function () {\n                this.tools.detachForwardLineGuide();\n                this.tools.detachBackwardLineGuide();\n                if (this._drawnLatLngs && this._drawnLatLngs.length < this.MIN_VERTEX) this.deleteShape(this._drawnLatLngs);\n                L.Editable.BaseEditor.prototype.endDrawing.call(this);\n                delete this._drawnLatLngs;\n            },\n\n            addLatLng: function (latlng) {\n                if (this._drawing === L.Editable.FORWARD) this._drawnLatLngs.push(latlng);\n                else this._drawnLatLngs.unshift(latlng);\n                this.feature._bounds.extend(latlng);\n                var vertex = this.addVertexMarker(latlng, this._drawnLatLngs);\n                this.onNewVertex(vertex);\n                this.refresh();\n            },\n\n            newPointForward: function (latlng) {\n                this.addLatLng(latlng);\n                this.tools.attachForwardLineGuide();\n                this.tools.anchorForwardLineGuide(latlng);\n            },\n\n            newPointBackward: function (latlng) {\n                this.addLatLng(latlng);\n                this.tools.anchorBackwardLineGuide(latlng);\n            },\n\n            // 🍂namespace PathEditor\n            // 🍂method push()\n            // Programmatically add a point while drawing.\n            push: function (latlng) {\n                if (!latlng) return console.error('L.Editable.PathEditor.push expect a valid latlng as parameter');\n                if (this._drawing === L.Editable.FORWARD) this.newPointForward(latlng);\n                else this.newPointBackward(latlng);\n            },\n\n            removeLatLng: function (latlng) {\n                latlng.__vertex.delete();\n                this.refresh();\n            },\n\n            // 🍂method pop(): L.LatLng or null\n            // Programmatically remove last point (if any) while drawing.\n            pop: function () {\n                if (this._drawnLatLngs.length <= 1) return;\n                var latlng;\n                if (this._drawing === L.Editable.FORWARD) latlng = this._drawnLatLngs[this._drawnLatLngs.length - 1];\n                else latlng = this._drawnLatLngs[0];\n                this.removeLatLng(latlng);\n                if (this._drawing === L.Editable.FORWARD) this.tools.anchorForwardLineGuide(this._drawnLatLngs[this._drawnLatLngs.length - 1]);\n                else this.tools.anchorForwardLineGuide(this._drawnLatLngs[0]);\n                return latlng;\n            },\n\n            processDrawingClick: function (e) {\n                if (e.vertex && e.vertex.editor === this) return;\n                if (this._drawing === L.Editable.FORWARD) this.newPointForward(e.latlng);\n                else this.newPointBackward(e.latlng);\n                this.fireAndForward('editable:drawing:clicked', e);\n            },\n\n            onDrawingMouseMove: function (e) {\n                L.Editable.BaseEditor.prototype.onDrawingMouseMove.call(this, e);\n                if (this._drawing) {\n                    this.tools.moveForwardLineGuide(e.latlng);\n                    this.tools.moveBackwardLineGuide(e.latlng);\n                }\n            },\n\n            refresh: function () {\n                this.feature.redraw();\n                this.onEditing();\n            },\n\n            // 🍂namespace PathEditor\n            // 🍂method newShape(latlng?: L.LatLng)\n            // Add a new shape (Polyline, Polygon) in a multi, and setup up drawing tools to draw it;\n            // if optional `latlng` is given, start a path at this point.\n            newShape: function (latlng) {\n                var shape = this.addNewEmptyShape();\n                if (!shape) return;\n                this.setDrawnLatLngs(shape[0] || shape);  // Polygon or polyline\n                this.startDrawingForward();\n                // 🍂namespace Editable\n                // 🍂section Shape events\n                // 🍂event editable:shape:new: ShapeEvent\n                // Fired when a new shape is created in a multi (Polygon or Polyline).\n                this.fireAndForward('editable:shape:new', {shape: shape});\n                if (latlng) this.newPointForward(latlng);\n            },\n\n            deleteShape: function (shape, latlngs) {\n                var e = {shape: shape};\n                L.Editable.makeCancellable(e);\n                // 🍂namespace Editable\n                // 🍂section Shape events\n                // 🍂event editable:shape:delete: CancelableShapeEvent\n                // Fired before a new shape is deleted in a multi (Polygon or Polyline).\n                this.fireAndForward('editable:shape:delete', e);\n                if (e._cancelled) return;\n                shape = this._deleteShape(shape, latlngs);\n                if (this.ensureNotFlat) this.ensureNotFlat();  // Polygon.\n                this.feature.setLatLngs(this.getLatLngs());  // Force bounds reset.\n                this.refresh();\n                this.reset();\n                // 🍂namespace Editable\n                // 🍂section Shape events\n                // 🍂event editable:shape:deleted: ShapeEvent\n                // Fired after a new shape is deleted in a multi (Polygon or Polyline).\n                this.fireAndForward('editable:shape:deleted', {shape: shape});\n                return shape;\n            },\n\n            _deleteShape: function (shape, latlngs) {\n                latlngs = latlngs || this.getLatLngs();\n                if (!latlngs.length) return;\n                var self = this,\n                    inplaceDelete = function (latlngs, shape) {\n                        // Called when deleting a flat latlngs\n                        shape = latlngs.splice(0, Number.MAX_VALUE);\n                        return shape;\n                    },\n                    spliceDelete = function (latlngs, shape) {\n                        // Called when removing a latlngs inside an array\n                        latlngs.splice(latlngs.indexOf(shape), 1);\n                        if (!latlngs.length) self._deleteShape(latlngs);\n                        return shape;\n                    };\n                if (latlngs === shape) return inplaceDelete(latlngs, shape);\n                for (var i = 0; i < latlngs.length; i++) {\n                    if (latlngs[i] === shape) return spliceDelete(latlngs, shape);\n                    else if (latlngs[i].indexOf(shape) !== -1) return spliceDelete(latlngs[i], shape);\n                }\n            },\n\n            // 🍂namespace PathEditor\n            // 🍂method deleteShapeAt(latlng: L.LatLng): Array\n            // Remove a path shape at the given `latlng`.\n            deleteShapeAt: function (latlng) {\n                var shape = this.feature.shapeAt(latlng);\n                if (shape) return this.deleteShape(shape);\n            },\n\n            // 🍂method appendShape(shape: Array)\n            // Append a new shape to the Polygon or Polyline.\n            appendShape: function (shape) {\n                this.insertShape(shape);\n            },\n\n            // 🍂method prependShape(shape: Array)\n            // Prepend a new shape to the Polygon or Polyline.\n            prependShape: function (shape) {\n                this.insertShape(shape, 0);\n            },\n\n            // 🍂method insertShape(shape: Array, index: int)\n            // Insert a new shape to the Polygon or Polyline at given index (default is to append).\n            insertShape: function (shape, index) {\n                this.ensureMulti();\n                shape = this.formatShape(shape);\n                if (typeof index === 'undefined') index = this.feature._latlngs.length;\n                this.feature._latlngs.splice(index, 0, shape);\n                this.feature.redraw();\n                if (this._enabled) this.reset();\n            },\n\n            extendBounds: function (e) {\n                this.feature._bounds.extend(e.vertex.latlng);\n            },\n\n            onDragStart: function (e) {\n                this.editLayer.clearLayers();\n                L.Editable.BaseEditor.prototype.onDragStart.call(this, e);\n            },\n\n            onDragEnd: function (e) {\n                this.initVertexMarkers();\n                L.Editable.BaseEditor.prototype.onDragEnd.call(this, e);\n            }\n\n        });\n\n        // 🍂namespace Editable; 🍂class PolylineEditor; 🍂aka L.Editable.PolylineEditor\n        // 🍂inherits PathEditor\n        L.Editable.PolylineEditor = L.Editable.PathEditor.extend({\n\n            startDrawingBackward: function () {\n                this._drawing = L.Editable.BACKWARD;\n                this.startDrawing();\n            },\n\n            // 🍂method continueBackward(latlngs?: Array)\n            // Set up drawing tools to continue the line backward.\n            continueBackward: function (latlngs) {\n                if (this.drawing()) return;\n                latlngs = latlngs || this.getDefaultLatLngs();\n                this.setDrawnLatLngs(latlngs);\n                if (latlngs.length > 0) {\n                    this.tools.attachBackwardLineGuide();\n                    this.tools.anchorBackwardLineGuide(latlngs[0]);\n                }\n                this.startDrawingBackward();\n            },\n\n            // 🍂method continueForward(latlngs?: Array)\n            // Set up drawing tools to continue the line forward.\n            continueForward: function (latlngs) {\n                if (this.drawing()) return;\n                latlngs = latlngs || this.getDefaultLatLngs();\n                this.setDrawnLatLngs(latlngs);\n                if (latlngs.length > 0) {\n                    this.tools.attachForwardLineGuide();\n                    this.tools.anchorForwardLineGuide(latlngs[latlngs.length - 1]);\n                }\n                this.startDrawingForward();\n            },\n\n            getDefaultLatLngs: function (latlngs) {\n                latlngs = latlngs || this.feature._latlngs;\n                if (!latlngs.length || latlngs[0] instanceof L.LatLng) return latlngs;\n                else return this.getDefaultLatLngs(latlngs[0]);\n            },\n\n            ensureMulti: function () {\n                if (this.feature._latlngs.length && isFlat(this.feature._latlngs)) {\n                    this.feature._latlngs = [this.feature._latlngs];\n                }\n            },\n\n            addNewEmptyShape: function () {\n                if (this.feature._latlngs.length) {\n                    var shape = [];\n                    this.appendShape(shape);\n                    return shape;\n                } else {\n                    return this.feature._latlngs;\n                }\n            },\n\n            formatShape: function (shape) {\n                if (isFlat(shape)) return shape;\n                else if (shape[0]) return this.formatShape(shape[0]);\n            },\n\n            // 🍂method splitShape(latlngs?: Array, index: int)\n            // Split the given `latlngs` shape at index `index` and integrate new shape in instance `latlngs`.\n            splitShape: function (shape, index) {\n                if (!index || index >= shape.length - 1) return;\n                this.ensureMulti();\n                var shapeIndex = this.feature._latlngs.indexOf(shape);\n                if (shapeIndex === -1) return;\n                var first = shape.slice(0, index + 1),\n                    second = shape.slice(index);\n                // We deal with reference, we don't want twice the same latlng around.\n                second[0] = L.latLng(second[0].lat, second[0].lng, second[0].alt);\n                this.feature._latlngs.splice(shapeIndex, 1, first, second);\n                this.refresh();\n                this.reset();\n            }\n\n        });\n\n        // 🍂namespace Editable; 🍂class PolygonEditor; 🍂aka L.Editable.PolygonEditor\n        // 🍂inherits PathEditor\n        L.Editable.PolygonEditor = L.Editable.PathEditor.extend({\n\n            CLOSED: true,\n            MIN_VERTEX: 3,\n\n            newPointForward: function (latlng) {\n                L.Editable.PathEditor.prototype.newPointForward.call(this, latlng);\n                if (!this.tools.backwardLineGuide._latlngs.length) this.tools.anchorBackwardLineGuide(latlng);\n                if (this._drawnLatLngs.length === 2) this.tools.attachBackwardLineGuide();\n            },\n\n            addNewEmptyHole: function (latlng) {\n                this.ensureNotFlat();\n                var latlngs = this.feature.shapeAt(latlng);\n                if (!latlngs) return;\n                var holes = [];\n                latlngs.push(holes);\n                return holes;\n            },\n\n            // 🍂method newHole(latlng?: L.LatLng, index: int)\n            // Set up drawing tools for creating a new hole on the Polygon. If the `latlng` param is given, a first point is created.\n            newHole: function (latlng) {\n                var holes = this.addNewEmptyHole(latlng);\n                if (!holes) return;\n                this.setDrawnLatLngs(holes);\n                this.startDrawingForward();\n                if (latlng) this.newPointForward(latlng);\n            },\n\n            addNewEmptyShape: function () {\n                if (this.feature._latlngs.length && this.feature._latlngs[0].length) {\n                    var shape = [];\n                    this.appendShape(shape);\n                    return shape;\n                } else {\n                    return this.feature._latlngs;\n                }\n            },\n\n            ensureMulti: function () {\n                if (this.feature._latlngs.length && isFlat(this.feature._latlngs[0])) {\n                    this.feature._latlngs = [this.feature._latlngs];\n                }\n            },\n\n            ensureNotFlat: function () {\n                if (!this.feature._latlngs.length || isFlat(this.feature._latlngs)) this.feature._latlngs = [this.feature._latlngs];\n            },\n\n            vertexCanBeDeleted: function (vertex) {\n                var parent = this.feature.parentShape(vertex.latlngs),\n                    idx = L.Util.indexOf(parent, vertex.latlngs);\n                if (idx > 0) return true;  // Holes can be totally deleted without removing the layer itself.\n                return L.Editable.PathEditor.prototype.vertexCanBeDeleted.call(this, vertex);\n            },\n\n            getDefaultLatLngs: function () {\n                if (!this.feature._latlngs.length) this.feature._latlngs.push([]);\n                return this.feature._latlngs[0];\n            },\n\n            formatShape: function (shape) {\n                // [[1, 2], [3, 4]] => must be nested\n                // [] => must be nested\n                // [[]] => is already nested\n                if (isFlat(shape) && (!shape[0] || shape[0].length !== 0)) return [shape];\n                else return shape;\n            }\n\n        });\n\n        // 🍂namespace Editable; 🍂class RectangleEditor; 🍂aka L.Editable.RectangleEditor\n        // 🍂inherits PathEditor\n        L.Editable.RectangleEditor = L.Editable.PathEditor.extend({\n\n            CLOSED: true,\n            MIN_VERTEX: 4,\n\n            options: {\n                skipMiddleMarkers: true\n            },\n\n            extendBounds: function (e) {\n                var index = e.vertex.getIndex(),\n                    next = e.vertex.getNext(),\n                    previous = e.vertex.getPrevious(),\n                    oppositeIndex = (index + 2) % 4,\n                    opposite = e.vertex.latlngs[oppositeIndex],\n                    bounds = new L.LatLngBounds(e.latlng, opposite);\n                // Update latlngs by hand to preserve order.\n                previous.latlng.update([e.latlng.lat, opposite.lng]);\n                next.latlng.update([opposite.lat, e.latlng.lng]);\n                this.updateBounds(bounds);\n                this.refreshVertexMarkers();\n            },\n\n            onDrawingMouseDown: function (e) {\n                L.Editable.PathEditor.prototype.onDrawingMouseDown.call(this, e);\n                this.connect();\n                var latlngs = this.getDefaultLatLngs();\n                // L.Polygon._convertLatLngs removes last latlng if it equals first point,\n                // which is the case here as all latlngs are [0, 0]\n                if (latlngs.length === 3) latlngs.push(e.latlng);\n                var bounds = new L.LatLngBounds(e.latlng, e.latlng);\n                this.updateBounds(bounds);\n                this.updateLatLngs(bounds);\n                this.refresh();\n                this.reset();\n                // Stop dragging map.\n                // L.Draggable has two workflows:\n                // - mousedown => mousemove => mouseup\n                // - touchstart => touchmove => touchend\n                // Problem: L.Map.Tap does not allow us to listen to touchstart, so we only\n                // can deal with mousedown, but then when in a touch device, we are dealing with\n                // simulated events (actually simulated by L.Map.Tap), which are no more taken\n                // into account by L.Draggable.\n                // Ref.: https://github.com/Leaflet/Leaflet.Editable/issues/103\n                e.originalEvent._simulated = false;\n                this.map.dragging._draggable._onUp(e.originalEvent);\n                // Now transfer ongoing drag action to the bottom right corner.\n                // Should we refine which corner will handle the drag according to\n                // drag direction?\n                latlngs[3].__vertex.dragging._draggable._onDown(e.originalEvent);\n            },\n\n            onDrawingMouseUp: function (e) {\n                this.commitDrawing(e);\n                e.originalEvent._simulated = false;\n                L.Editable.PathEditor.prototype.onDrawingMouseUp.call(this, e);\n            },\n\n            onDrawingMouseMove: function (e) {\n                e.originalEvent._simulated = false;\n                L.Editable.PathEditor.prototype.onDrawingMouseMove.call(this, e);\n            },\n\n\n            getDefaultLatLngs: function (latlngs) {\n                return latlngs || this.feature._latlngs[0];\n            },\n\n            updateBounds: function (bounds) {\n                this.feature._bounds = bounds;\n            },\n\n            updateLatLngs: function (bounds) {\n                var latlngs = this.getDefaultLatLngs(),\n                    newLatlngs = this.feature._boundsToLatLngs(bounds);\n                // Keep references.\n                for (var i = 0; i < latlngs.length; i++) {\n                    latlngs[i].update(newLatlngs[i]);\n                }\n            }\n\n        });\n\n        // 🍂namespace Editable; 🍂class CircleEditor; 🍂aka L.Editable.CircleEditor\n        // 🍂inherits PathEditor\n        L.Editable.CircleEditor = L.Editable.PathEditor.extend({\n\n            MIN_VERTEX: 2,\n\n            options: {\n                skipMiddleMarkers: true\n            },\n\n            initialize: function (map, feature, options) {\n                L.Editable.PathEditor.prototype.initialize.call(this, map, feature, options);\n                this._resizeLatLng = this.computeResizeLatLng();\n            },\n\n            computeResizeLatLng: function () {\n                // While circle is not added to the map, _radius is not set.\n                var delta = (this.feature._radius || this.feature._mRadius) * Math.cos(Math.PI / 4),\n                    point = this.map.project(this.feature._latlng);\n                return this.map.unproject([point.x + delta, point.y - delta]);\n            },\n\n            updateResizeLatLng: function () {\n                this._resizeLatLng.update(this.computeResizeLatLng());\n                this._resizeLatLng.__vertex.update();\n            },\n\n            getLatLngs: function () {\n                return [this.feature._latlng, this._resizeLatLng];\n            },\n\n            getDefaultLatLngs: function () {\n                return this.getLatLngs();\n            },\n\n            onVertexMarkerDrag: function (e) {\n                if (e.vertex.getIndex() === 1) this.resize(e);\n                else this.updateResizeLatLng(e);\n                L.Editable.PathEditor.prototype.onVertexMarkerDrag.call(this, e);\n            },\n\n            resize: function (e) {\n                var radius = this.feature._latlng.distanceTo(e.latlng);\n                this.feature.setRadius(radius);\n            },\n\n            onDrawingMouseDown: function (e) {\n                L.Editable.PathEditor.prototype.onDrawingMouseDown.call(this, e);\n                this._resizeLatLng.update(e.latlng);\n                this.feature._latlng.update(e.latlng);\n                this.connect();\n                // Stop dragging map.\n                e.originalEvent._simulated = false;\n                this.map.dragging._draggable._onUp(e.originalEvent);\n                // Now transfer ongoing drag action to the radius handler.\n                this._resizeLatLng.__vertex.dragging._draggable._onDown(e.originalEvent);\n            },\n\n            onDrawingMouseUp: function (e) {\n                this.commitDrawing(e);\n                e.originalEvent._simulated = false;\n                L.Editable.PathEditor.prototype.onDrawingMouseUp.call(this, e);\n            },\n\n            onDrawingMouseMove: function (e) {\n                e.originalEvent._simulated = false;\n                L.Editable.PathEditor.prototype.onDrawingMouseMove.call(this, e);\n            },\n\n            onDrag: function (e) {\n                L.Editable.PathEditor.prototype.onDrag.call(this, e);\n                this.feature.dragging.updateLatLng(this._resizeLatLng);\n            }\n\n        });\n\n        // 🍂namespace Editable; 🍂class EditableMixin\n        // `EditableMixin` is included to `L.Polyline`, `L.Polygon`, `L.Rectangle`, `L.Circle`\n        // and `L.Marker`. It adds some methods to them.\n        // *When editing is enabled, the editor is accessible on the instance with the\n        // `editor` property.*\n        var EditableMixin = {\n\n            createEditor: function (map) {\n                map = map || this._map;\n                var tools = (this.options.editOptions || {}).editTools || map.editTools;\n                if (!tools) throw Error('Unable to detect Editable instance.');\n                var Klass = this.options.editorClass || this.getEditorClass(tools);\n                return new Klass(map, this, this.options.editOptions);\n            },\n\n            // 🍂method enableEdit(map?: L.Map): this.editor\n            // Enable editing, by creating an editor if not existing, and then calling `enable` on it.\n            enableEdit: function (map) {\n                if (!this.editor) this.createEditor(map);\n                this.editor.enable();\n                return this.editor;\n            },\n\n            // 🍂method editEnabled(): boolean\n            // Return true if current instance has an editor attached, and this editor is enabled.\n            editEnabled: function () {\n                return this.editor && this.editor.enabled();\n            },\n\n            // 🍂method disableEdit()\n            // Disable editing, also remove the editor property reference.\n            disableEdit: function () {\n                if (this.editor) {\n                    this.editor.disable();\n                    delete this.editor;\n                }\n            },\n\n            // 🍂method toggleEdit()\n            // Enable or disable editing, according to current status.\n            toggleEdit: function () {\n                if (this.editEnabled()) this.disableEdit();\n                else this.enableEdit();\n            },\n\n            _onEditableAdd: function () {\n                if (this.editor) this.enableEdit();\n            }\n\n        };\n\n        var PolylineMixin = {\n\n            getEditorClass: function (tools) {\n                return (tools && tools.options.polylineEditorClass) ? tools.options.polylineEditorClass : L.Editable.PolylineEditor;\n            },\n\n            shapeAt: function (latlng, latlngs) {\n                // We can have those cases:\n                // - latlngs are just a flat array of latlngs, use this\n                // - latlngs is an array of arrays of latlngs, loop over\n                var shape = null;\n                latlngs = latlngs || this._latlngs;\n                if (!latlngs.length) return shape;\n                else if (isFlat(latlngs) && this.isInLatLngs(latlng, latlngs)) shape = latlngs;\n                else for (var i = 0; i < latlngs.length; i++) if (this.isInLatLngs(latlng, latlngs[i])) return latlngs[i];\n                return shape;\n            },\n\n            isInLatLngs: function (l, latlngs) {\n                if (!latlngs) return false;\n                var i, k, len, part = [], p,\n                    w = this._clickTolerance();\n                this._projectLatlngs(latlngs, part, this._pxBounds);\n                part = part[0];\n                p = this._map.latLngToLayerPoint(l);\n\n                if (!this._pxBounds.contains(p)) { return false; }\n                for (i = 1, len = part.length, k = 0; i < len; k = i++) {\n\n                    if (L.LineUtil.pointToSegmentDistance(p, part[k], part[i]) <= w) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n\n        };\n\n        var PolygonMixin = {\n\n            getEditorClass: function (tools) {\n                return (tools && tools.options.polygonEditorClass) ? tools.options.polygonEditorClass : L.Editable.PolygonEditor;\n            },\n\n            shapeAt: function (latlng, latlngs) {\n                // We can have those cases:\n                // - latlngs are just a flat array of latlngs, use this\n                // - latlngs is an array of arrays of latlngs, this is a simple polygon (maybe with holes), use the first\n                // - latlngs is an array of arrays of arrays, this is a multi, loop over\n                var shape = null;\n                latlngs = latlngs || this._latlngs;\n                if (!latlngs.length) return shape;\n                else if (isFlat(latlngs) && this.isInLatLngs(latlng, latlngs)) shape = latlngs;\n                else if (isFlat(latlngs[0]) && this.isInLatLngs(latlng, latlngs[0])) shape = latlngs;\n                else for (var i = 0; i < latlngs.length; i++) if (this.isInLatLngs(latlng, latlngs[i][0])) return latlngs[i];\n                return shape;\n            },\n\n            isInLatLngs: function (l, latlngs) {\n                var inside = false, l1, l2, j, k, len2;\n\n                for (j = 0, len2 = latlngs.length, k = len2 - 1; j < len2; k = j++) {\n                    l1 = latlngs[j];\n                    l2 = latlngs[k];\n\n                    if (((l1.lat > l.lat) !== (l2.lat > l.lat)) &&\n                        (l.lng < (l2.lng - l1.lng) * (l.lat - l1.lat) / (l2.lat - l1.lat) + l1.lng)) {\n                        inside = !inside;\n                    }\n                }\n\n                return inside;\n            },\n\n            parentShape: function (shape, latlngs) {\n                latlngs = latlngs || this._latlngs;\n                if (!latlngs) return;\n                var idx = L.Util.indexOf(latlngs, shape);\n                if (idx !== -1) return latlngs;\n                for (var i = 0; i < latlngs.length; i++) {\n                    idx = L.Util.indexOf(latlngs[i], shape);\n                    if (idx !== -1) return latlngs[i];\n                }\n            }\n\n        };\n\n\n        var MarkerMixin = {\n\n            getEditorClass: function (tools) {\n                return (tools && tools.options.markerEditorClass) ? tools.options.markerEditorClass : L.Editable.MarkerEditor;\n            }\n\n        };\n\n        var RectangleMixin = {\n\n            getEditorClass: function (tools) {\n                return (tools && tools.options.rectangleEditorClass) ? tools.options.rectangleEditorClass : L.Editable.RectangleEditor;\n            }\n\n        };\n\n        var CircleMixin = {\n\n            getEditorClass: function (tools) {\n                return (tools && tools.options.circleEditorClass) ? tools.options.circleEditorClass : L.Editable.CircleEditor;\n            }\n\n        };\n\n        var keepEditable = function () {\n            // Make sure you can remove/readd an editable layer.\n            this.on('add', this._onEditableAdd);\n        };\n\n        var isFlat = L.LineUtil.isFlat || L.LineUtil._flat || L.Polyline._flat;  // <=> 1.1 compat.\n\n\n        if (L.Polyline) {\n            L.Polyline.include(EditableMixin);\n            L.Polyline.include(PolylineMixin);\n            L.Polyline.addInitHook(keepEditable);\n        }\n        if (L.Polygon) {\n            L.Polygon.include(EditableMixin);\n            L.Polygon.include(PolygonMixin);\n        }\n        if (L.Marker) {\n            L.Marker.include(EditableMixin);\n            L.Marker.include(MarkerMixin);\n            L.Marker.addInitHook(keepEditable);\n        }\n        if (L.Rectangle) {\n            L.Rectangle.include(EditableMixin);\n            L.Rectangle.include(RectangleMixin);\n        }\n        if (L.Circle) {\n            L.Circle.include(EditableMixin);\n            L.Circle.include(CircleMixin);\n        }\n\n        L.LatLng.prototype.update = function (latlng) {\n            latlng = L.latLng(latlng);\n            this.lat = latlng.lat;\n            this.lng = latlng.lng;\n        }\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./Vue2LeafletEditablePlugin.js"],"sourceRoot":""}