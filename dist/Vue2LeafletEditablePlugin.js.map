{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///Vue2LeafletEditablePlugin.js","webpack:///webpack/bootstrap fc5a58050f4a70b48c6e","webpack:///./Vue2LeafletEditablePlugin.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","L","Editable","Evented","extend","statics","FORWARD","BACKWARD","options","zIndex","polygonClass","Polygon","polylineClass","Polyline","markerClass","Marker","rectangleClass","Rectangle","circleClass","Circle","drawingCSSClass","drawingCursor","editLayer","undefined","featuresLayer","polylineEditorClass","polygonEditorClass","markerEditorClass","rectangleEditorClass","circleEditorClass","lineGuideOptions","skipMiddleMarkers","initialize","map","setOptions","_lastZIndex","createEditLayer","createFeaturesLayer","forwardLineGuide","createLineGuide","backwardLineGuide","fireAndForward","type","e","editTools","fire","dashArray","weight","interactive","polyline","createVertexIcon","Browser","mobile","touch","TouchVertexIcon","VertexIcon","LayerGroup","addTo","moveForwardLineGuide","latlng","_latlngs","length","_bounds","redraw","moveBackwardLineGuide","anchorForwardLineGuide","anchorBackwardLineGuide","attachForwardLineGuide","addLayer","attachBackwardLineGuide","detachForwardLineGuide","setLatLngs","removeLayer","detachBackwardLineGuide","blockEvents","_oldTargets","_targets","unblockEvents","registerForDrawing","editor","_drawingEditor","unregisterForDrawing","reset","on","onDrawingMouseMove","onMousedown","onMouseup","DomUtil","addClass","_container","defaultMapCursor","style","cursor","removeClass","off","_drawing","cancelDrawing","originalEvent","which","_mouseDown","onDrawingMouseDown","mouseDown","onDrawingMouseUp","origin","point","clientX","clientY","distance","distanceTo","Math","abs","window","devicePixelRatio","onDrawingClick","drawing","stopDrawing","commitDrawing","connectCreatedToMap","layer","startPolyline","line","createPolyline","enableEdit","newShape","startPolygon","polygon","createPolygon","startMarker","getCenter","clone","marker","createMarker","startDrawing","startRectangle","corner","latLng","bounds","LatLngBounds","rectangle","createRectangle","startCircle","circle","createCircle","startHole","newHole","createLayer","klass","latlngs","Util","editOptions","makeCancellable","cancel","_cancelled","Map","mergeOptions","editToolsClass","editable","addInitHook","whenReady","DivIcon","iconSize","Point","VertexMarker","draggable","className","icon","tools","__vertex","setZIndexOffset","onAdd","onDrag","onDragStart","onDragEnd","onClick","onContextMenu","onMouseDown","onMouseOver","onMouseOut","addMiddleMarkers","onRemove","middleMarker","delete","vertex","onVertexMarkerDrag","iconPos","getPosition","_icon","_map","layerPointToLatLng","update","_latlng","refresh","updateLatLng","next","getNext","onVertexMarkerDragStart","onVertexMarkerDragEnd","onVertexMarkerClick","DomEvent","stop","onVertexMarkerContextMenu","onVertexMarkerMouseDown","onVertexMarkerMouseOver","onVertexMarkerMouseOut","splice","getIndex","onVertexDeleted","deleteShape","resetMiddleMarker","indexOf","getLastIndex","getPrevious","index","previousIndex","CLOSED","previous","nextIndex","addMiddleMarker","hasMiddleMarkers","split","splitShape","continue","continueBackward","continueForward","vertexMarkerClass","MiddleMarker","opacity","left","right","computeLatLng","_opacity","setVisibility","leftPoint","latLngToContainerPoint","rightPoint","size","x","hide","show","setOpacity","setLatLng","y","containerPointToLatLng","onMiddleMarkerMouseDown","addVertexMarker","onNewVertex","parent","parentNode","removeChild","appendChild","_initIcon","_initInteraction","Draggable","_dragging","dragging","_draggable","_onDown","middleMarkerClass","BaseEditor","Handler","feature","addHooks","isConnected","onFeatureAdd","once","onEnable","_getEvents","removeHooks","disable","clearLayers","onDisable","enable","onEditing","onStartDrawing","onEndDrawing","onCancelDrawing","onCommitDrawing","endDrawing","connect","processDrawingClick","hasLayer","onMove","dragstart","drag","dragend","remove","MarkerEditor","PathEditor","MIN_VERTEX","initVertexMarkers","enabled","getLatLngs","isFlat","addVertexMarkers","refreshVertexMarkers","getDefaultLatLngs","commit","ctrlKey","onVertexMarkerCtrlClick","altKey","onVertexMarkerAltClick","shiftKey","onVertexMarkerShiftClick","metaKey","onVertexMarkerMetaKeyClick","_drawnLatLngs","onVertexRawMarkerClick","vertexCanBeDeleted","extendBounds","setDrawnLatLngs","startDrawingForward","addLatLng","push","unshift","newPointForward","newPointBackward","console","error","removeLatLng","pop","shape","addNewEmptyShape","_deleteShape","ensureNotFlat","self","spliceDelete","Number","MAX_VALUE","deleteShapeAt","shapeAt","appendShape","insertShape","prependShape","ensureMulti","formatShape","_enabled","PolylineEditor","startDrawingBackward","LatLng","shapeIndex","first","slice","second","lat","lng","alt","PolygonEditor","addNewEmptyHole","holes","parentShape","RectangleEditor","oppositeIndex","opposite","updateBounds","updateLatLngs","_simulated","_onUp","newLatlngs","_boundsToLatLngs","CircleEditor","_resizeLatLng","computeResizeLatLng","delta","_radius","_mRadius","cos","PI","project","unproject","updateResizeLatLng","resize","radius","setRadius","EditableMixin","createEditor","Error","editorClass","getEditorClass","editEnabled","disableEdit","toggleEdit","_onEditableAdd","PolylineMixin","isInLatLngs","k","len","part","w","_clickTolerance","_projectLatlngs","_pxBounds","latLngToLayerPoint","contains","LineUtil","pointToSegmentDistance","PolygonMixin","l1","l2","j","len2","inside","idx","MarkerMixin","RectangleMixin","CircleMixin","keepEditable","_flat","include"],"mappings":"CAAA,SAAAA,EAAAC,GACA,gBAAAC,UAAA,gBAAAC,QACAA,OAAAD,QAAAD,IACA,kBAAAG,gBAAAC,IACAD,UAAAH,GACA,gBAAAC,SACAA,QAAA,0BAAAD,IAEAD,EAAA,0BAAAC,MACCK,KAAA,WACD,MCAgB,UAAUC,GCN1B,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAP,OAGA,IAAAC,GAAAO,EAAAD,IACAE,EAAAF,EACAG,GAAA,EACAV,WAUA,OANAK,GAAAE,GAAAI,KAAAV,EAAAD,QAAAC,IAAAD,QAAAM,GAGAL,EAAAS,GAAA,EAGAT,EAAAD,QAvBA,GAAAQ,KA+DA,OAnCAF,GAAAM,EAAAP,EAGAC,EAAAO,EAAAL,EAGAF,EAAAG,EAAA,SAAAK,GAA2C,MAAAA,IAG3CR,EAAAS,EAAA,SAAAf,EAAAgB,EAAAC,GACAX,EAAAY,EAAAlB,EAAAgB,IACAG,OAAAC,eAAApB,EAAAgB,GACAK,cAAA,EACAC,YAAA,EACAC,IAAAN,KAMAX,EAAAkB,EAAA,SAAAvB,GACA,GAAAgB,GAAAhB,KAAAwB,WACA,WAA2B,MAAAxB,GAAA,SAC3B,WAAiC,MAAAA,GAEjC,OADAK,GAAAS,EAAAE,EAAA,IAAAA,GACAA,GAIAX,EAAAY,EAAA,SAAAQ,EAAAC,GAAsD,MAAAR,QAAAS,UAAAC,eAAAlB,KAAAe,EAAAC,IAGtDrB,EAAAwB,EAAA,IAGAxB,IAAAyB,EAAA,KDgBM,SAAU9B,EAAQD,IEhFxB,SAAcgC,GA8BVA,EAAEC,SAAWD,EAAEE,QAAQC,QAEnBC,SACIC,QAAS,EACTC,UAAW,GAGfC,SAKIC,OAAQ,IAIRC,aAAcT,EAAEU,QAIhBC,cAAeX,EAAEY,SAIjBC,YAAab,EAAEc,OAIfC,eAAgBf,EAAEgB,UAIlBC,YAAajB,EAAEkB,OAIfC,gBAAiB,2BAIjBC,cAAe,YAIfC,cAAWC,GAIXC,kBAAeD,GAIfE,wBAAqBF,GAIrBG,uBAAoBH,GAIpBI,sBAAmBJ,GAInBK,yBAAsBL,GAItBM,sBAAmBN,GAInBO,oBAIAC,mBAAmB,GAIvBC,WAAY,SAAUC,EAAKzB,GACvBP,EAAEiC,WAAW7D,KAAMmC,GACnBnC,KAAK8D,YAAc9D,KAAKmC,QAAQC,OAChCpC,KAAK4D,IAAMA,EACX5D,KAAKiD,UAAYjD,KAAK+D,kBACtB/D,KAAKmD,cAAgBnD,KAAKgE,sBAC1BhE,KAAKiE,iBAAmBjE,KAAKkE,kBAC7BlE,KAAKmE,kBAAoBnE,KAAKkE,mBAGlCE,eAAgB,SAAUC,EAAMC,GAC5BA,EAAIA,MACJA,EAAEC,UAAYvE,KACdA,KAAKwE,KAAKH,EAAMC,GAChBtE,KAAK4D,IAAIY,KAAKH,EAAMC,IAGxBJ,gBAAiB,WACb,GAAI/B,GAAUP,EAAEG,QAAQ0C,UAAW,OAAQC,OAAQ,EAAGC,aAAa,GAAQ3E,KAAKmC,QAAQsB,iBACxF,OAAO7B,GAAEgD,YAAazC,IAG1B0C,iBAAkB,SAAU1C,GACxB,MAAOP,GAAEkD,QAAQC,QAAUnD,EAAEkD,QAAQE,MAAQ,GAAIpD,GAAEC,SAASoD,gBAAgB9C,GAAW,GAAIP,GAAEC,SAASqD,WAAW/C,IAGrH4B,gBAAiB,WACb,MAAO/D,MAAKmC,QAAQc,YAAa,GAAIrB,GAAEuD,YAAaC,MAAMpF,KAAK4D,MAGnEI,oBAAqB,WACjB,MAAOhE,MAAKmC,QAAQgB,gBAAiB,GAAIvB,GAAEuD,YAAaC,MAAMpF,KAAK4D,MAGvEyB,qBAAsB,SAAUC,GACxBtF,KAAKiE,iBAAiBsB,SAASC,SAC/BxF,KAAKiE,iBAAiBsB,SAAS,GAAKD,EACpCtF,KAAKiE,iBAAiBwB,QAAQ1D,OAAOuD,GACrCtF,KAAKiE,iBAAiByB,WAI9BC,sBAAuB,SAAUL,GACzBtF,KAAKmE,kBAAkBoB,SAASC,SAChCxF,KAAKmE,kBAAkBoB,SAAS,GAAKD,EACrCtF,KAAKmE,kBAAkBsB,QAAQ1D,OAAOuD,GACtCtF,KAAKmE,kBAAkBuB,WAI/BE,uBAAwB,SAAUN,GAC9BtF,KAAKiE,iBAAiBsB,SAAS,GAAKD,EACpCtF,KAAKiE,iBAAiBwB,QAAQ1D,OAAOuD,GACrCtF,KAAKiE,iBAAiByB,UAG1BG,wBAAyB,SAAUP,GAC/BtF,KAAKmE,kBAAkBoB,SAAS,GAAKD,EACrCtF,KAAKmE,kBAAkBsB,QAAQ1D,OAAOuD,GACtCtF,KAAKmE,kBAAkBuB,UAG3BI,uBAAwB,WACpB9F,KAAKiD,UAAU8C,SAAS/F,KAAKiE,mBAGjC+B,wBAAyB,WACrBhG,KAAKiD,UAAU8C,SAAS/F,KAAKmE,oBAGjC8B,uBAAwB,WACpBjG,KAAKiE,iBAAiBiC,eACtBlG,KAAKiD,UAAUkD,YAAYnG,KAAKiE,mBAGpCmC,wBAAyB,WACrBpG,KAAKmE,kBAAkB+B,eACvBlG,KAAKiD,UAAUkD,YAAYnG,KAAKmE,oBAGpCkC,YAAa,WAEJrG,KAAKsG,cACNtG,KAAKsG,YAActG,KAAK4D,IAAI2C,SAC5BvG,KAAK4D,IAAI2C,cAIjBC,cAAe,WACPxG,KAAKsG,cAELtG,KAAK4D,IAAI2C,SAAW3E,EAAEG,OAAO/B,KAAK4D,IAAI2C,SAAUvG,KAAKsG,mBAC9CtG,MAAKsG,cAIpBG,mBAAoB,SAAUC,GACtB1G,KAAK2G,gBAAgB3G,KAAK4G,qBAAqB5G,KAAK2G,gBACxD3G,KAAKqG,cACLK,EAAOG,QACP7G,KAAK2G,eAAiBD,EACtB1G,KAAK4D,IAAIkD,GAAG,sBAAuBJ,EAAOK,mBAAoBL,GAC9D1G,KAAK4D,IAAIkD,GAAG,YAAa9G,KAAKgH,YAAahH,MAC3CA,KAAK4D,IAAIkD,GAAG,UAAW9G,KAAKiH,UAAWjH,MACvC4B,EAAEsF,QAAQC,SAASnH,KAAK4D,IAAIwD,WAAYpH,KAAKmC,QAAQY,iBACrD/C,KAAKqH,iBAAmBrH,KAAK4D,IAAIwD,WAAWE,MAAMC,OAClDvH,KAAK4D,IAAIwD,WAAWE,MAAMC,OAASvH,KAAKmC,QAAQa,eAGpD4D,qBAAsB,SAAUF,GAC5B1G,KAAKwG,gBACL5E,EAAEsF,QAAQM,YAAYxH,KAAK4D,IAAIwD,WAAYpH,KAAKmC,QAAQY,iBACxD/C,KAAK4D,IAAIwD,WAAWE,MAAMC,OAASvH,KAAKqH,kBACxCX,EAASA,GAAU1G,KAAK2G,kBAExB3G,KAAK4D,IAAI6D,IAAI,sBAAuBf,EAAOK,mBAAoBL,GAC/D1G,KAAK4D,IAAI6D,IAAI,YAAazH,KAAKgH,YAAahH,MAC5CA,KAAK4D,IAAI6D,IAAI,UAAWzH,KAAKiH,UAAWjH,MACpC0G,IAAW1G,KAAK2G,uBACb3G,MAAK2G,eACRD,EAAOgB,UAAUhB,EAAOiB,mBAGhCX,YAAa,SAAU1C,GACU,GAAzBA,EAAEsD,cAAcC,QACpB7H,KAAK8H,WAAaxD,EAClBtE,KAAK2G,eAAeoB,mBAAmBzD,KAG3C2C,UAAW,SAAU3C,GACjB,GAAItE,KAAK8H,WAAY,CACjB,GAAIpB,GAAS1G,KAAK2G,eACdqB,EAAYhI,KAAK8H,UAGrB,IAFA9H,KAAK8H,WAAa,KAClBpB,EAAOuB,iBAAiB3D,GACpBtE,KAAK2G,iBAAmBD,EAAQ,MACpC,IAAIwB,GAAStG,EAAEuG,MAAMH,EAAUJ,cAAcQ,QAASJ,EAAUJ,cAAcS,SAC1EC,EAAW1G,EAAEuG,MAAM7D,EAAEsD,cAAcQ,QAAS9D,EAAEsD,cAAcS,SAASE,WAAWL,EAChFM,MAAKC,IAAIH,GAAY,GAAKI,OAAOC,kBAAoB,IAAI3I,KAAK2G,eAAeiC,eAAetE,KAYxGuE,QAAS,WACL,MAAO7I,MAAK2G,gBAAkB3G,KAAK2G,eAAekC,WAKtDC,YAAa,WACT9I,KAAK4G,wBAKTmC,cAAe,SAAUzE,GAChBtE,KAAK2G,gBACV3G,KAAK2G,eAAeoC,cAAczE,IAGtC0E,oBAAqB,SAAUC,GAC3B,MAAOjJ,MAAKmD,cAAc4C,SAASkD,IAMvCC,cAAe,SAAU5D,EAAQnD,GAC7B,GAAIgH,GAAOnJ,KAAKoJ,kBAAmBjH,EAEnC,OADAgH,GAAKE,WAAWrJ,KAAK4D,KAAK0F,SAAShE,GAC5B6D,GAMXI,aAAc,SAAUjE,EAAQnD,GAC5B,GAAIqH,GAAUxJ,KAAKyJ,iBAAkBtH,EAErC,OADAqH,GAAQH,WAAWrJ,KAAK4D,KAAK0F,SAAShE,GAC/BkE,GAOXE,YAAa,SAAUpE,EAAQnD,GAC3BmD,EAASA,GAAUtF,KAAK4D,IAAI+F,YAAYC,OACxC,IAAIC,GAAS7J,KAAK8J,aAAaxE,EAAQnD,EAEvC,OADA0H,GAAOR,WAAWrJ,KAAK4D,KAAKmG,eACrBF,GAMXG,eAAgB,SAAS1E,EAAQnD,GAC7B,GAAI8H,GAAS3E,GAAU1D,EAAEsI,QAAQ,EAAG,IAChCC,EAAS,GAAIvI,GAAEwI,aAAaH,EAAQA,GACpCI,EAAYrK,KAAKsK,gBAAgBH,EAAQhI,EAE7C,OADAkI,GAAUhB,WAAWrJ,KAAK4D,KAAKmG,eACxBM,GAMXE,YAAa,SAAUjF,EAAQnD,GAC3BmD,EAASA,GAAUtF,KAAK4D,IAAI+F,YAAYC,OACxC,IAAIY,GAASxK,KAAKyK,aAAanF,EAAQnD,EAEvC,OADAqI,GAAOnB,WAAWrJ,KAAK4D,KAAKmG,eACrBS,GAGXE,UAAW,SAAUhE,EAAQpB,GACzBoB,EAAOiE,QAAQrF,IAGnBsF,YAAa,SAAUC,EAAOC,EAAS3I,GACnCA,EAAUP,EAAEmJ,KAAKhJ,QAAQiJ,aAAczG,UAAWvE,OAAQmC,EAC1D,IAAI8G,GAAQ,GAAI4B,GAAMC,EAAS3I,EAK/B,OADAnC,MAAKoE,eAAe,oBAAqB6E,MAAOA,IACzCA,GAGXG,eAAgB,SAAU0B,EAAS3I,GAC/B,MAAOnC,MAAK4K,YAAYzI,GAAWA,EAAQI,eAAiBvC,KAAKmC,QAAQI,cAAeuI,EAAS3I,IAGrGsH,cAAe,SAAUqB,EAAS3I,GAC9B,MAAOnC,MAAK4K,YAAYzI,GAAWA,EAAQE,cAAgBrC,KAAKmC,QAAQE,aAAcyI,EAAS3I,IAGnG2H,aAAc,SAAUxE,EAAQnD,GAC5B,MAAOnC,MAAK4K,YAAYzI,GAAWA,EAAQM,aAAezC,KAAKmC,QAAQM,YAAa6C,EAAQnD,IAGhGmI,gBAAiB,SAAUH,EAAQhI,GAC/B,MAAOnC,MAAK4K,YAAYzI,GAAWA,EAAQQ,gBAAkB3C,KAAKmC,QAAQQ,eAAgBwH,EAAQhI,IAGtGsI,aAAc,SAAUnF,EAAQnD,GAC5B,MAAOnC,MAAK4K,YAAYzI,GAAWA,EAAQU,aAAe7C,KAAKmC,QAAQU,YAAayC,EAAQnD,MAKpGP,EAAEG,OAAOH,EAAEC,UAEPoJ,gBAAiB,SAAU3G,GACvBA,EAAE4G,OAAS,WACP5G,EAAE6G,YAAa,MAoB3BvJ,EAAEwJ,IAAIC,cAMFC,eAAgB1J,EAAEC,SAIlB0J,UAAU,EAIVP,iBAIJpJ,EAAEwJ,IAAII,YAAY,WAEdxL,KAAKyL,UAAU,WACPzL,KAAKmC,QAAQoJ,WACbvL,KAAKuE,UAAY,GAAIvE,MAAKmC,QAAQmJ,eAAetL,KAAMA,KAAKmC,QAAQ6I,kBAMhFpJ,EAAEC,SAASqD,WAAatD,EAAE8J,QAAQ3J,QAE9BI,SACIwJ,SAAU,GAAI/J,GAAEgK,MAAM,EAAG,MAKjChK,EAAEC,SAASoD,gBAAkBrD,EAAEC,SAASqD,WAAWnD,QAE/CI,SACIwJ,SAAU,GAAI/J,GAAEgK,MAAM,GAAI,OAOlChK,EAAEC,SAASgK,aAAejK,EAAEc,OAAOX,QAE/BI,SACI2J,WAAW,EACXC,UAAW,wCAQfpI,WAAY,SAAU2B,EAAQwF,EAASpE,EAAQvE,GAG3CnC,KAAKsF,OAASA,EACdtF,KAAK8K,QAAUA,EACf9K,KAAK0G,OAASA,EACd9E,EAAEc,OAAOlB,UAAUmC,WAAWpD,KAAKP,KAAMsF,EAAQnD,GACjDnC,KAAKmC,QAAQ6J,KAAOhM,KAAK0G,OAAOuF,MAAMpH,kBAAkBkH,UAAW/L,KAAKmC,QAAQ4J,YAChF/L,KAAKsF,OAAO4G,SAAWlM,KACvBA,KAAK0G,OAAOzD,UAAU8C,SAAS/F,MAC/BA,KAAKmM,gBAAgBzF,EAAOuF,MAAMnI,YAAc,IAGpDsI,MAAO,SAAUxI,GACbhC,EAAEc,OAAOlB,UAAU4K,MAAM7L,KAAKP,KAAM4D,GACpC5D,KAAK8G,GAAG,OAAQ9G,KAAKqM,QACrBrM,KAAK8G,GAAG,YAAa9G,KAAKsM,aAC1BtM,KAAK8G,GAAG,UAAW9G,KAAKuM,WACxBvM,KAAK8G,GAAG,UAAW9G,KAAKiH,WACxBjH,KAAK8G,GAAG,QAAS9G,KAAKwM,SACtBxM,KAAK8G,GAAG,cAAe9G,KAAKyM,eAC5BzM,KAAK8G,GAAG,uBAAwB9G,KAAK0M,aACrC1M,KAAK8G,GAAG,YAAa9G,KAAK2M,aAC1B3M,KAAK8G,GAAG,WAAY9G,KAAK4M,YACzB5M,KAAK6M,oBAGTC,SAAU,SAAUlJ,GACZ5D,KAAK+M,cAAc/M,KAAK+M,aAAaC,eAClChN,MAAKsF,OAAO4G,SACnBlM,KAAKyH,IAAI,OAAQzH,KAAKqM,QACtBrM,KAAKyH,IAAI,YAAazH,KAAKsM,aAC3BtM,KAAKyH,IAAI,UAAWzH,KAAKuM,WACzBvM,KAAKyH,IAAI,UAAWzH,KAAKiH,WACzBjH,KAAKyH,IAAI,QAASzH,KAAKwM,SACvBxM,KAAKyH,IAAI,cAAezH,KAAKyM,eAC7BzM,KAAKyH,IAAI,uBAAwBzH,KAAK0M,aACtC1M,KAAKyH,IAAI,YAAazH,KAAK2M,aAC3B3M,KAAKyH,IAAI,WAAYzH,KAAK4M,YAC1BhL,EAAEc,OAAOlB,UAAUsL,SAASvM,KAAKP,KAAM4D,IAG3CyI,OAAQ,SAAU/H,GACdA,EAAE2I,OAASjN,KACXA,KAAK0G,OAAOwG,mBAAmB5I,EAC/B,IAAI6I,GAAUvL,EAAEsF,QAAQkG,YAAYpN,KAAKqN,OACrC/H,EAAStF,KAAKsN,KAAKC,mBAAmBJ,EAC1CnN,MAAKsF,OAAOkI,OAAOlI,GACnBtF,KAAKyN,QAAUzN,KAAKsF,OACpBtF,KAAK0G,OAAOgH,UACR1N,KAAK+M,cAAc/M,KAAK+M,aAAaY,cACzC,IAAIC,GAAO5N,KAAK6N,SACZD,IAAQA,EAAKb,cAAca,EAAKb,aAAaY,gBAGrDrB,YAAa,SAAUhI,GACnBA,EAAE2I,OAASjN,KACXA,KAAK0G,OAAOoH,wBAAwBxJ,IAGxCiI,UAAW,SAAUjI,GACjBA,EAAE2I,OAASjN,KACXA,KAAK0G,OAAOqH,sBAAsBzJ,IAGtCkI,QAAS,SAAUlI,GACfA,EAAE2I,OAASjN,KACXA,KAAK0G,OAAOsH,oBAAoB1J,IAGpC2C,UAAW,SAAU3C,GACjB1C,EAAEqM,SAASC,KAAK5J,GAChBA,EAAE2I,OAASjN,KACXA,KAAK0G,OAAO9C,IAAIY,KAAK,UAAWF,IAGpCmI,cAAe,SAAUnI,GACrBA,EAAE2I,OAASjN,KACXA,KAAK0G,OAAOyH,0BAA0B7J,IAG1CoI,YAAa,SAAUpI,GACnBA,EAAE2I,OAASjN,KACXA,KAAK0G,OAAO0H,wBAAwB9J,IAGxCqI,YAAa,SAAUrI,GACnBA,EAAE2I,OAASjN,KACXA,KAAK0G,OAAO2H,wBAAwB/J,IAGxCsI,WAAY,SAAUtI,GAClBA,EAAE2I,OAASjN,KACXA,KAAK0G,OAAO4H,uBAAuBhK,IAKvC0I,OAAQ,WACJ,GAAIY,GAAO5N,KAAK6N,SAChB7N,MAAK8K,QAAQyD,OAAOvO,KAAKwO,WAAY,GACrCxO,KAAK0G,OAAOzD,UAAUkD,YAAYnG,MAClCA,KAAK0G,OAAO+H,iBAAiBnJ,OAAQtF,KAAKsF,OAAQ2H,OAAQjN,OACrDA,KAAK8K,QAAQtF,QAAQxF,KAAK0G,OAAOgI,YAAY1O,KAAK8K,SACnD8C,GAAMA,EAAKe,oBACf3O,KAAK0G,OAAOgH,WAKhBc,SAAU,WACN,MAAOxO,MAAK8K,QAAQ8D,QAAQ5O,KAAKsF,SAKrCuJ,aAAc,WACV,MAAO7O,MAAK8K,QAAQtF,OAAS,GAKjCsJ,YAAa,WACT,KAAI9O,KAAK8K,QAAQtF,OAAS,GAA1B,CACA,GAAIuJ,GAAQ/O,KAAKwO,WACbQ,EAAgBD,EAAQ,CACd,KAAVA,GAAe/O,KAAK0G,OAAOuI,SAAQD,EAAgBhP,KAAK6O,eAC5D,IAAIK,GAAWlP,KAAK8K,QAAQkE,EAC5B,OAAIE,GAAiBA,EAAShD,aAA9B,KAKJ2B,QAAS,WACL,KAAI7N,KAAK8K,QAAQtF,OAAS,GAA1B,CACA,GAAIuJ,GAAQ/O,KAAKwO,WACbW,EAAYJ,EAAQ,CACpBA,KAAU/O,KAAK6O,gBAAkB7O,KAAK0G,OAAOuI,SAAQE,EAAY,EACrE,IAAIvB,GAAO5N,KAAK8K,QAAQqE,EACxB,OAAIvB,GAAaA,EAAK1B,aAAtB,KAGJkD,gBAAiB,SAAUF,GAClBlP,KAAK0G,OAAO2I,qBACjBH,EAAWA,GAAYlP,KAAK8O,iBACX9O,KAAK+M,eAAc/M,KAAK+M,aAAe/M,KAAK0G,OAAO0I,gBAAgBF,EAAUlP,KAAMA,KAAK8K,QAAS9K,KAAK0G,UAG3HmG,iBAAkB,WACd,GAAK7M,KAAK0G,OAAO2I,mBAAjB,CACA,GAAIH,GAAWlP,KAAK8O,aAChBI,IAAUlP,KAAKoP,gBAAgBF,EACnC,IAAItB,GAAO5N,KAAK6N,SACZD,IAAMA,EAAKe,sBAGnBA,kBAAmB,WACX3O,KAAK+M,cAAc/M,KAAK+M,aAAaC,SACzChN,KAAKoP,mBAKTE,MAAO,WACEtP,KAAK0G,OAAO6I,YACjBvP,KAAK0G,OAAO6I,WAAWvP,KAAK8K,QAAS9K,KAAKwO,aAK9CgB,SAAU,WACN,GAAKxP,KAAK0G,OAAO+I,iBAAjB,CACA,GAAIV,GAAQ/O,KAAKwO,UACH,KAAVO,EAAa/O,KAAK0G,OAAO+I,iBAAiBzP,KAAK8K,SAC1CiE,IAAU/O,KAAK6O,gBAAgB7O,KAAK0G,OAAOgJ,gBAAgB1P,KAAK8K,aAKjFlJ,EAAEC,SAASwJ,cAKPsE,kBAAmB/N,EAAEC,SAASgK,eAIlCjK,EAAEC,SAAS+N,aAAehO,EAAEc,OAAOX,QAE/BI,SACI0N,QAAS,GACT9D,UAAW,uCACXD,WAAW,GAGfnI,WAAY,SAAUmM,EAAMC,EAAOjF,EAASpE,EAAQvE,GAChDnC,KAAK8P,KAAOA,EACZ9P,KAAK+P,MAAQA,EACb/P,KAAK0G,OAASA,EACd1G,KAAK8K,QAAUA,EACflJ,EAAEc,OAAOlB,UAAUmC,WAAWpD,KAAKP,KAAMA,KAAKgQ,gBAAiB7N,GAC/DnC,KAAKiQ,SAAWjQ,KAAKmC,QAAQ0N,QAC7B7P,KAAKmC,QAAQ6J,KAAOhM,KAAK0G,OAAOuF,MAAMpH,kBAAkBkH,UAAW/L,KAAKmC,QAAQ4J,YAChF/L,KAAK0G,OAAOzD,UAAU8C,SAAS/F,MAC/BA,KAAKkQ,iBAGTA,cAAe,WACX,GAAIC,GAAYnQ,KAAKsN,KAAK8C,uBAAuBpQ,KAAK8P,KAAKxK,QACvD+K,EAAarQ,KAAKsN,KAAK8C,uBAAuBpQ,KAAK+P,MAAMzK,QACzDgL,EAAO1O,EAAEuG,MAAMnI,KAAKmC,QAAQ6J,KAAK7J,QAAQwJ,SACzCwE,GAAU5H,WAAW8H,GAAuB,EAATC,EAAKC,EAAOvQ,KAAKwQ,OACnDxQ,KAAKyQ,QAGdA,KAAM,WACFzQ,KAAK0Q,WAAW1Q,KAAKiQ,WAGzBO,KAAM,WACFxQ,KAAK0Q,WAAW,IAGpB/C,aAAc,WACV3N,KAAK2Q,UAAU3Q,KAAKgQ,iBACpBhQ,KAAKkQ,iBAGTF,cAAe,WACX,GAAIG,GAAYnQ,KAAK0G,OAAO9C,IAAIwM,uBAAuBpQ,KAAK8P,KAAKxK,QAC7D+K,EAAarQ,KAAK0G,OAAO9C,IAAIwM,uBAAuBpQ,KAAK+P,MAAMzK,QAC/DsL,GAAKT,EAAUS,EAAIP,EAAWO,GAAK,EACnCL,GAAKJ,EAAUI,EAAIF,EAAWE,GAAK,CACvC,OAAOvQ,MAAK0G,OAAO9C,IAAIiN,wBAAwBN,EAAGK,KAGtDxE,MAAO,SAAUxI,GACbhC,EAAEc,OAAOlB,UAAU4K,MAAM7L,KAAKP,KAAM4D,GACpChC,EAAEqM,SAASnH,GAAG9G,KAAKqN,MAAO,uBAAwBrN,KAAK0M,YAAa1M,MACpE4D,EAAIkD,GAAG,UAAW9G,KAAKkQ,cAAelQ,OAG1C8M,SAAU,SAAUlJ,SACT5D,MAAK+P,MAAMhD,aAClBnL,EAAEqM,SAASxG,IAAIzH,KAAKqN,MAAO,uBAAwBrN,KAAK0M,YAAa1M,MACrE4D,EAAI6D,IAAI,UAAWzH,KAAKkQ,cAAelQ,MACvC4B,EAAEc,OAAOlB,UAAUsL,SAASvM,KAAKP,KAAM4D,IAG3C8I,YAAa,SAAUpI,GACnB,GAAI6I,GAAUvL,EAAEsF,QAAQkG,YAAYpN,KAAKqN,MAMzC,IAJA/I,GACIsD,cAAetD,EACfgB,OAHStF,KAAK0G,OAAO9C,IAAI2J,mBAAmBJ,IAKnB,IAAzBnN,KAAKmC,QAAQ0N,UACjBjO,EAAEC,SAASoJ,gBAAgB3G,GAC3BtE,KAAK0G,OAAOoK,wBAAwBxM,IAChCA,EAAE6G,YAAN,CACAnL,KAAK8K,QAAQyD,OAAOvO,KAAK+O,QAAS,EAAGzK,EAAEgB,QACvCtF,KAAK0G,OAAOgH,SACZ,IAAI1B,GAAOhM,KAAKqN,MACZxD,EAAS7J,KAAK0G,OAAOqK,gBAAgBzM,EAAEgB,OAAQtF,KAAK8K,QACxD9K,MAAK0G,OAAOsK,YAAYnH,EAExB,IAAIoH,GAASpH,EAAOwD,MAAM6D,UAC1BD,GAAOE,YAAYtH,EAAOwD,OAC1BxD,EAAOwD,MAAQrB,EACfiF,EAAOG,YAAYvH,EAAOwD,OAC1BxD,EAAOwH,YACPxH,EAAOyH,mBACPzH,EAAO6G,WAAW,GAGlB9O,EAAE2P,UAAUC,WAAY,EACxB3H,EAAO4H,SAASC,WAAWC,QAAQrN,EAAEsD,eACrC5H,KAAKgN,WAGTA,OAAQ,WACJhN,KAAK0G,OAAOzD,UAAUkD,YAAYnG,OAGtC+O,MAAO,WACH,MAAO/O,MAAK8K,QAAQ8D,QAAQ5O,KAAK+P,MAAMzK,WAK/C1D,EAAEC,SAASwJ,cAKPuG,kBAAmBhQ,EAAEC,SAAS+N,eAOlChO,EAAEC,SAASgQ,WAAajQ,EAAEkQ,QAAQ/P,QAE9B4B,WAAY,SAAUC,EAAKmO,EAAS5P,GAChCP,EAAEiC,WAAW7D,KAAMmC,GACnBnC,KAAK4D,IAAMA,EACX5D,KAAK+R,QAAUA,EACf/R,KAAK+R,QAAQrL,OAAS1G,KACtBA,KAAKiD,UAAY,GAAIrB,GAAEuD,WACvBnF,KAAKiM,MAAQjM,KAAKmC,QAAQoC,WAAaX,EAAIW,WAK/CyN,SAAU,WACFhS,KAAKiS,cAAejS,KAAKkS,eACxBlS,KAAK+R,QAAQI,KAAK,MAAOnS,KAAKkS,aAAclS,MACjDA,KAAKoS,WACLpS,KAAK+R,QAAQjL,GAAG9G,KAAKqS,aAAcrS,OAKvCsS,YAAa,WACTtS,KAAK+R,QAAQtK,IAAIzH,KAAKqS,aAAcrS,MAChCA,KAAK+R,QAAQN,UAAUzR,KAAK+R,QAAQN,SAASc,UACjDvS,KAAKiD,UAAUuP,cACfxS,KAAKiM,MAAMhJ,UAAUkD,YAAYnG,KAAKiD,WACtCjD,KAAKyS,YACDzS,KAAK0H,UAAU1H,KAAK2H,iBAK5BkB,QAAS,WACL,QAAS7I,KAAK0H,UAGlBb,MAAO,aAEPqL,aAAc,WACVlS,KAAKiM,MAAMhJ,UAAU8C,SAAS/F,KAAKiD,WAC/BjD,KAAK+R,QAAQN,UAAUzR,KAAK+R,QAAQN,SAASiB,UAGrDrD,iBAAkB,WACd,OAAQrP,KAAKmC,QAAQuB,oBAAsB1D,KAAKiM,MAAM9J,QAAQuB,mBAGlEU,eAAgB,SAAUC,EAAMC,GAC5BA,EAAIA,MACJA,EAAE2E,MAAQjJ,KAAK+R,QACf/R,KAAK+R,QAAQvN,KAAKH,EAAMC,GACxBtE,KAAKiM,MAAM7H,eAAeC,EAAMC,IAGpC8N,SAAU,WAINpS,KAAKoE,eAAe,oBAGxBqO,UAAW,WAIPzS,KAAKoE,eAAe,qBAGxBuO,UAAW,WAIP3S,KAAKoE,eAAe,qBAGxBwO,eAAgB,WAKZ5S,KAAKoE,eAAe,2BAGxByO,aAAc,WAKV7S,KAAKoE,eAAe,yBAGxB0O,gBAAiB,WAKb9S,KAAKoE,eAAe,4BAGxB2O,gBAAiB,SAAUzO,GAKvBtE,KAAKoE,eAAe,0BAA2BE,IAGnDyD,mBAAoB,SAAUzD,GAK1BtE,KAAKoE,eAAe,6BAA8BE,IAGtD2D,iBAAkB,SAAU3D,GAKxBtE,KAAKoE,eAAe,2BAA4BE,IAGpDyF,aAAc,WACL/J,KAAK0H,WAAU1H,KAAK0H,SAAW9F,EAAEC,SAASI,SAC/CjC,KAAKiM,MAAMxF,mBAAmBzG,MAC9BA,KAAK4S,kBAGT7J,cAAe,SAAUzE,GACrBtE,KAAK+S,gBAAgBzO,GACrBtE,KAAKgT,cAGTrL,cAAe,WAIX/F,EAAE2P,UAAUC,WAAY,EACxBxR,KAAK8S,kBACL9S,KAAKgT,cAGTA,WAAY,WACRhT,KAAK0H,UAAW,EAChB1H,KAAKiM,MAAMrF,qBAAqB5G,MAChCA,KAAK6S,gBAGTjK,eAAgB,SAAUtE,GACjBtE,KAAK6I,YACVjH,EAAEC,SAASoJ,gBAAgB3G,GAK3BtE,KAAKoE,eAAe,yBAA0BE,GAC1CA,EAAE6G,aACDnL,KAAKiS,eAAejS,KAAKiT,QAAQ3O,GACtCtE,KAAKkT,oBAAoB5O,MAG7B2N,YAAa,WACT,MAAOjS,MAAK4D,IAAIuP,SAASnT,KAAK+R,UAGlCkB,QAAS,WACLjT,KAAKiM,MAAMjD,oBAAoBhJ,KAAK+R,SACpC/R,KAAKiM,MAAMhJ,UAAU8C,SAAS/F,KAAKiD,YAGvCmQ,OAAQ,SAAU9O,GAKdtE,KAAKoE,eAAe,wBAAyBE,IAGjDyC,mBAAoB,SAAUzC,GAC1BtE,KAAKoT,OAAO9O,IAGhB+N,WAAY,WACR,OACIgB,UAAWrT,KAAKsM,YAChBgH,KAAMtT,KAAKqM,OACXkH,QAASvT,KAAKuM,UACdiH,OAAQxT,KAAKuS,UAIrBjG,YAAa,SAAUhI,GACnBtE,KAAK2S,YAIL3S,KAAKoE,eAAe,qBAAsBE,IAG9C+H,OAAQ,SAAU/H,GACdtE,KAAKoT,OAAO9O,GAIZtE,KAAKoE,eAAe,gBAAiBE,IAGzCiI,UAAW,SAAUjI,GAIjBtE,KAAKoE,eAAe,mBAAoBE,MAQhD1C,EAAEC,SAAS4R,aAAe7R,EAAEC,SAASgQ,WAAW9P,QAE5CgF,mBAAoB,SAAUzC,GAC1B1C,EAAEC,SAASgQ,WAAWrQ,UAAUuF,mBAAmBxG,KAAKP,KAAMsE,GAC1DtE,KAAK0H,UAAU1H,KAAK+R,QAAQpB,UAAUrM,EAAEgB,SAGhD4N,oBAAqB,SAAU5O,GAK3BtE,KAAKoE,eAAe,2BAA4BE,GAChDtE,KAAK+I,cAAczE,IAGvB2O,QAAS,SAAU3O,GAGXA,IAAGtE,KAAK+R,QAAQtE,QAAUnJ,EAAEgB,QAChC1D,EAAEC,SAASgQ,WAAWrQ,UAAUyR,QAAQ1S,KAAKP,KAAMsE,MAQ3D1C,EAAEC,SAAS6R,WAAa9R,EAAEC,SAASgQ,WAAW9P,QAE1CkN,QAAQ,EACR0E,WAAY,EAEZ3B,SAAU,WAGN,MAFApQ,GAAEC,SAASgQ,WAAWrQ,UAAUwQ,SAASzR,KAAKP,MAC1CA,KAAK+R,SAAS/R,KAAK4T,oBAChB5T,MAGX4T,kBAAmB,SAAU9I,GACzB,GAAK9K,KAAK6T,UAEV,GADA/I,EAAUA,GAAW9K,KAAK8T,aACtBC,EAAOjJ,GAAU9K,KAAKgU,iBAAiBlJ,OACtC,KAAK,GAAIzK,GAAI,EAAGA,EAAIyK,EAAQtF,OAAQnF,IAAKL,KAAK4T,kBAAkB9I,EAAQzK,KAGjFyT,WAAY,WACR,MAAO9T,MAAK+R,QAAQ+B,cAKxBjN,MAAO,WACH7G,KAAKiD,UAAUuP,cACfxS,KAAK4T,qBAGT7C,gBAAiB,SAAUzL,EAAQwF,GAC/B,MAAO,IAAI9K,MAAKiM,MAAM9J,QAAQwN,kBAAkBrK,EAAQwF,EAAS9K,OAGrEgR,YAAa,SAAU/D,GAKnBjN,KAAKoE,eAAe,uBAAwBkB,OAAQ2H,EAAO3H,OAAQ2H,OAAQA,KAG/E+G,iBAAkB,SAAUlJ,GACxB,IAAK,GAAIzK,GAAI,EAAGA,EAAIyK,EAAQtF,OAAQnF,IAChCL,KAAK+Q,gBAAgBjG,EAAQzK,GAAIyK,IAIzCmJ,qBAAsB,SAAUnJ,GAC5BA,EAAUA,GAAW9K,KAAKkU,mBAC1B,KAAK,GAAI7T,GAAI,EAAGA,EAAIyK,EAAQtF,OAAQnF,IAChCyK,EAAQzK,GAAG6L,SAASsB,UAI5B4B,gBAAiB,SAAUU,EAAMC,EAAOjF,GACpC,MAAO,IAAI9K,MAAKiM,MAAM9J,QAAQyP,kBAAkB9B,EAAMC,EAAOjF,EAAS9K,OAG1EgO,oBAAqB,SAAU1J,GAO3B,GANA1C,EAAEC,SAASoJ,gBAAgB3G,GAK3BtE,KAAKoE,eAAe,wBAAyBE,KACzCA,EAAE6G,YACFnL,KAAKiM,MAAMpD,WAAa7I,KAAKiM,MAAMtF,iBAAmB3G,MAA1D,CACA,GAAiCmU,GAA7BpF,EAAQzK,EAAE2I,OAAOuB,UACjBlK,GAAEsD,cAAcwM,QAChBpU,KAAKqU,wBAAwB/P,GACtBA,EAAEsD,cAAc0M,OACvBtU,KAAKuU,uBAAuBjQ,GACrBA,EAAEsD,cAAc4M,SACvBxU,KAAKyU,yBAAyBnQ,GACvBA,EAAEsD,cAAc8M,QACvB1U,KAAK2U,2BAA2BrQ,GACzByK,IAAUzK,EAAE2I,OAAO4B,gBAAkB7O,KAAK0H,WAAa9F,EAAEC,SAASI,QACrE8M,GAAS/O,KAAK2T,WAAa,IAAGQ,GAAS,GAC1B,IAAVpF,GAAe/O,KAAK0H,WAAa9F,EAAEC,SAASK,UAAYlC,KAAK4U,cAAcpP,QAAUxF,KAAK2T,WACjGQ,GAAS,EACQ,IAAVpF,GAAe/O,KAAK0H,WAAa9F,EAAEC,SAASI,SAAWjC,KAAK4U,cAAcpP,QAAUxF,KAAK2T,YAAc3T,KAAKiP,OACnHkF,GAAS,EAETnU,KAAK6U,uBAAuBvQ,GAMhCtE,KAAKoE,eAAe,0BAA2BE,GAC3C6P,GAAQnU,KAAK+I,cAAczE,KAGnCuQ,uBAAwB,SAAUvQ,GAK9BtE,KAAKoE,eAAe,2BAA4BE,GAC5CA,EAAE6G,YACDnL,KAAK8U,mBAAmBxQ,EAAE2I,SAC/B3I,EAAE2I,OAAOD,UAGb8H,mBAAoB,SAAU7H,GAC1B,MAAOA,GAAOnC,QAAQtF,OAASxF,KAAK2T,YAGxClF,gBAAiB,SAAUnK,GAKvBtE,KAAKoE,eAAe,0BAA2BE,IAGnD+P,wBAAyB,SAAU/P,GAK/BtE,KAAKoE,eAAe,4BAA6BE,IAGrDmQ,yBAA0B,SAAUnQ,GAKhCtE,KAAKoE,eAAe,6BAA8BE,IAGtDqQ,2BAA4B,SAAUrQ,GAKlCtE,KAAKoE,eAAe,+BAAgCE,IAGxDiQ,uBAAwB,SAAUjQ,GAK9BtE,KAAKoE,eAAe,2BAA4BE,IAGpD6J,0BAA2B,SAAU7J,GAKjCtE,KAAKoE,eAAe,8BAA+BE,IAGvD8J,wBAAyB,SAAU9J,GAK/BtE,KAAKoE,eAAe,4BAA6BE,IAGrD+J,wBAAyB,SAAU/J,GAK/BtE,KAAKoE,eAAe,4BAA6BE,IAGrDgK,uBAAwB,SAAUhK,GAK9BtE,KAAKoE,eAAe,2BAA4BE,IAGpDwM,wBAAyB,SAAUxM,GAK/BtE,KAAKoE,eAAe,kCAAmCE,IAG3D4I,mBAAoB,SAAU5I,GAC1BtE,KAAKoT,OAAO9O,GACRtE,KAAK+R,QAAQtM,SAASzF,KAAK+U,aAAazQ,GAK5CtE,KAAKoE,eAAe,uBAAwBE,IAGhDwJ,wBAAyB,SAAUxJ,GAK/BtE,KAAKoE,eAAe,4BAA6BE,IAGrDyJ,sBAAuB,SAAUzJ,GAK7BtE,KAAKoE,eAAe,0BAA2BE,IAGnD0Q,gBAAiB,SAAUlK,GACvB9K,KAAK4U,cAAgB9J,GAAW9K,KAAKkU,qBAGzCnK,aAAc,WACL/J,KAAK4U,eAAe5U,KAAKgV,kBAC9BpT,EAAEC,SAASgQ,WAAWrQ,UAAUuI,aAAaxJ,KAAKP,OAGtDiV,oBAAqB,WACjBjV,KAAK+J,gBAGTiJ,WAAY,WACRhT,KAAKiM,MAAMhG,yBACXjG,KAAKiM,MAAM7F,0BACPpG,KAAK4U,eAAiB5U,KAAK4U,cAAcpP,OAASxF,KAAK2T,YAAY3T,KAAK0O,YAAY1O,KAAK4U,eAC7FhT,EAAEC,SAASgQ,WAAWrQ,UAAUwR,WAAWzS,KAAKP,YACzCA,MAAK4U,eAGhBM,UAAW,SAAU5P,GACbtF,KAAK0H,WAAa9F,EAAEC,SAASI,QAASjC,KAAK4U,cAAcO,KAAK7P,GAC7DtF,KAAK4U,cAAcQ,QAAQ9P,GAChCtF,KAAK+R,QAAQtM,QAAQ1D,OAAOuD,EAC5B,IAAI2H,GAASjN,KAAK+Q,gBAAgBzL,EAAQtF,KAAK4U,cAC/C5U,MAAKgR,YAAY/D,GACjBjN,KAAK0N,WAGT2H,gBAAiB,SAAU/P,GACvBtF,KAAKkV,UAAU5P,GACftF,KAAKiM,MAAMnG,yBACX9F,KAAKiM,MAAMrG,uBAAuBN,IAGtCgQ,iBAAkB,SAAUhQ,GACxBtF,KAAKkV,UAAU5P,GACftF,KAAKiM,MAAMpG,wBAAwBP,IAMvC6P,KAAM,SAAU7P,GACZ,IAAKA,EAAQ,MAAOiQ,SAAQC,MAAM,gEAC9BxV,MAAK0H,WAAa9F,EAAEC,SAASI,QAASjC,KAAKqV,gBAAgB/P,GAC1DtF,KAAKsV,iBAAiBhQ,IAG/BmQ,aAAc,SAAUnQ,GACpBA,EAAO4G,SAASc,SAChBhN,KAAK0N,WAKTgI,IAAK,WACD,KAAI1V,KAAK4U,cAAcpP,QAAU,GAAjC,CACA,GAAIF,EAMJ,OAL0CA,GAAtCtF,KAAK0H,WAAa9F,EAAEC,SAASI,QAAkBjC,KAAK4U,cAAc5U,KAAK4U,cAAcpP,OAAS,GACpFxF,KAAK4U,cAAc,GACjC5U,KAAKyV,aAAanQ,GACdtF,KAAK0H,WAAa9F,EAAEC,SAASI,QAASjC,KAAKiM,MAAMrG,uBAAuB5F,KAAK4U,cAAc5U,KAAK4U,cAAcpP,OAAS,IACtHxF,KAAKiM,MAAMrG,uBAAuB5F,KAAK4U,cAAc,IACnDtP,IAGX4N,oBAAqB,SAAU5O,GACvBA,EAAE2I,QAAU3I,EAAE2I,OAAOvG,SAAW1G,OAChCA,KAAK0H,WAAa9F,EAAEC,SAASI,QAASjC,KAAKqV,gBAAgB/Q,EAAEgB,QAC5DtF,KAAKsV,iBAAiBhR,EAAEgB,QAC7BtF,KAAKoE,eAAe,2BAA4BE,KAGpDyC,mBAAoB,SAAUzC,GAC1B1C,EAAEC,SAASgQ,WAAWrQ,UAAUuF,mBAAmBxG,KAAKP,KAAMsE,GAC1DtE,KAAK0H,WACL1H,KAAKiM,MAAM5G,qBAAqBf,EAAEgB,QAClCtF,KAAKiM,MAAMtG,sBAAsBrB,EAAEgB,UAI3CoI,QAAS,WACL1N,KAAK+R,QAAQrM,SACb1F,KAAK2S,aAOTrJ,SAAU,SAAUhE,GAChB,GAAIqQ,GAAQ3V,KAAK4V,kBACZD,KACL3V,KAAKgV,gBAAgBW,EAAM,IAAMA,GACjC3V,KAAKiV,sBAKLjV,KAAKoE,eAAe,sBAAuBuR,MAAOA,IAC9CrQ,GAAQtF,KAAKqV,gBAAgB/P,KAGrCoJ,YAAa,SAAUiH,EAAO7K,GAC1B,GAAIxG,IAAKqR,MAAOA,EAOhB,IANA/T,EAAEC,SAASoJ,gBAAgB3G,GAK3BtE,KAAKoE,eAAe,wBAAyBE,IACzCA,EAAE6G,WAWN,MAVAwK,GAAQ3V,KAAK6V,aAAaF,EAAO7K,GAC7B9K,KAAK8V,eAAe9V,KAAK8V,gBAC7B9V,KAAK+R,QAAQ7L,WAAWlG,KAAK8T,cAC7B9T,KAAK0N,UACL1N,KAAK6G,QAKL7G,KAAKoE,eAAe,0BAA2BuR,MAAOA,IAC/CA,GAGXE,aAAc,SAAUF,EAAO7K,GAE3B,GADAA,EAAUA,GAAW9K,KAAK8T,aACrBhJ,EAAQtF,OAAb,CACA,GAAIuQ,GAAO/V,KAMPgW,EAAe,SAAUlL,EAAS6K,GAI9B,MAFA7K,GAAQyD,OAAOzD,EAAQ8D,QAAQ+G,GAAQ,GAClC7K,EAAQtF,QAAQuQ,EAAKF,aAAa/K,GAChC6K,EAEf,IAAI7K,IAAY6K,EAAO,MAXH,UAAU7K,EAAS6K,GAG/B,MADQ7K,GAAQyD,OAAO,EAAG0H,OAAOC,YASGpL,EAC5C,KAAK,GAAIzK,GAAI,EAAGA,EAAIyK,EAAQtF,OAAQnF,IAAK,CACrC,GAAIyK,EAAQzK,KAAOsV,EAAO,MAAOK,GAAalL,EAAS6K,EAClD,KAAmC,IAA/B7K,EAAQzK,GAAGuO,QAAQ+G,GAAe,MAAOK,GAAalL,EAAQzK,GAAIsV,MAOnFQ,cAAe,SAAU7Q,GACrB,GAAIqQ,GAAQ3V,KAAK+R,QAAQqE,QAAQ9Q,EACjC,IAAIqQ,EAAO,MAAO3V,MAAK0O,YAAYiH,IAKvCU,YAAa,SAAUV,GACnB3V,KAAKsW,YAAYX,IAKrBY,aAAc,SAAUZ,GACpB3V,KAAKsW,YAAYX,EAAO,IAK5BW,YAAa,SAAUX,EAAO5G,GAC1B/O,KAAKwW,cACLb,EAAQ3V,KAAKyW,YAAYd,OACJ,KAAV5G,IAAuBA,EAAQ/O,KAAK+R,QAAQxM,SAASC,QAChExF,KAAK+R,QAAQxM,SAASgJ,OAAOQ,EAAO,EAAG4G,GACvC3V,KAAK+R,QAAQrM,SACT1F,KAAK0W,UAAU1W,KAAK6G,SAG5BkO,aAAc,SAAUzQ,GACpBtE,KAAK+R,QAAQtM,QAAQ1D,OAAOuC,EAAE2I,OAAO3H,SAGzCgH,YAAa,SAAUhI,GACnBtE,KAAKiD,UAAUuP,cACf5Q,EAAEC,SAASgQ,WAAWrQ,UAAU8K,YAAY/L,KAAKP,KAAMsE,IAG3DiI,UAAW,SAAUjI,GACjBtE,KAAK4T,oBACLhS,EAAEC,SAASgQ,WAAWrQ,UAAU+K,UAAUhM,KAAKP,KAAMsE,MAO7D1C,EAAEC,SAAS8U,eAAiB/U,EAAEC,SAAS6R,WAAW3R,QAE9C6U,qBAAsB,WAClB5W,KAAK0H,SAAW9F,EAAEC,SAASK,SAC3BlC,KAAK+J,gBAKT0F,iBAAkB,SAAU3E,GACpB9K,KAAK6I,YACTiC,EAAUA,GAAW9K,KAAKkU,oBAC1BlU,KAAKgV,gBAAgBlK,GACjBA,EAAQtF,OAAS,IACjBxF,KAAKiM,MAAMjG,0BACXhG,KAAKiM,MAAMpG,wBAAwBiF,EAAQ,KAE/C9K,KAAK4W,yBAKTlH,gBAAiB,SAAU5E,GACnB9K,KAAK6I,YACTiC,EAAUA,GAAW9K,KAAKkU,oBAC1BlU,KAAKgV,gBAAgBlK,GACjBA,EAAQtF,OAAS,IACjBxF,KAAKiM,MAAMnG,yBACX9F,KAAKiM,MAAMrG,uBAAuBkF,EAAQA,EAAQtF,OAAS,KAE/DxF,KAAKiV,wBAGTf,kBAAmB,SAAUpJ,GAEzB,MADAA,GAAUA,GAAW9K,KAAK+R,QAAQxM,UAC7BuF,EAAQtF,QAAUsF,EAAQ,YAAclJ,GAAEiV,OAAe/L,EAClD9K,KAAKkU,kBAAkBpJ,EAAQ,KAG/C0L,YAAa,WACLxW,KAAK+R,QAAQxM,SAASC,QAAUuO,EAAO/T,KAAK+R,QAAQxM,YACpDvF,KAAK+R,QAAQxM,UAAYvF,KAAK+R,QAAQxM,YAI9CqQ,iBAAkB,WACd,GAAI5V,KAAK+R,QAAQxM,SAASC,OAAQ,CAC9B,GAAImQ,KAEJ,OADA3V,MAAKqW,YAAYV,GACVA,EAEP,MAAO3V,MAAK+R,QAAQxM,UAI5BkR,YAAa,SAAUd,GACnB,MAAI5B,GAAO4B,GAAeA,EACjBA,EAAM,GAAW3V,KAAKyW,YAAYd,EAAM,QAA5C,IAKTpG,WAAY,SAAUoG,EAAO5G,GACzB,GAAKA,KAASA,GAAS4G,EAAMnQ,OAAS,GAAtC,CACAxF,KAAKwW,aACL,IAAIM,GAAa9W,KAAK+R,QAAQxM,SAASqJ,QAAQ+G,EAC/C,KAAoB,IAAhBmB,EAAJ,CACA,GAAIC,GAAQpB,EAAMqB,MAAM,EAAGjI,EAAQ,GAC/BkI,EAAStB,EAAMqB,MAAMjI,EAEzBkI,GAAO,GAAKrV,EAAEsI,OAAO+M,EAAO,GAAGC,IAAKD,EAAO,GAAGE,IAAKF,EAAO,GAAGG,KAC7DpX,KAAK+R,QAAQxM,SAASgJ,OAAOuI,EAAY,EAAGC,EAAOE,GACnDjX,KAAK0N,UACL1N,KAAK6G,aAObjF,EAAEC,SAASwV,cAAgBzV,EAAEC,SAAS6R,WAAW3R,QAE7CkN,QAAQ,EACR0E,WAAY,EAEZ0B,gBAAiB,SAAU/P,GACvB1D,EAAEC,SAAS6R,WAAWlS,UAAU6T,gBAAgB9U,KAAKP,KAAMsF,GACtDtF,KAAKiM,MAAM9H,kBAAkBoB,SAASC,QAAQxF,KAAKiM,MAAMpG,wBAAwBP,GACpD,IAA9BtF,KAAK4U,cAAcpP,QAAcxF,KAAKiM,MAAMjG,2BAGpDsR,gBAAiB,SAAUhS,GACvBtF,KAAK8V,eACL,IAAIhL,GAAU9K,KAAK+R,QAAQqE,QAAQ9Q,EACnC,IAAKwF,EAAL,CACA,GAAIyM,KAEJ,OADAzM,GAAQqK,KAAKoC,GACNA,IAKX5M,QAAS,SAAUrF,GACf,GAAIiS,GAAQvX,KAAKsX,gBAAgBhS,EAC5BiS,KACLvX,KAAKgV,gBAAgBuC,GACrBvX,KAAKiV,sBACD3P,GAAQtF,KAAKqV,gBAAgB/P,KAGrCsQ,iBAAkB,WACd,GAAI5V,KAAK+R,QAAQxM,SAASC,QAAUxF,KAAK+R,QAAQxM,SAAS,GAAGC,OAAQ,CACjE,GAAImQ,KAEJ,OADA3V,MAAKqW,YAAYV,GACVA,EAEP,MAAO3V,MAAK+R,QAAQxM,UAI5BiR,YAAa,WACLxW,KAAK+R,QAAQxM,SAASC,QAAUuO,EAAO/T,KAAK+R,QAAQxM,SAAS,MAC7DvF,KAAK+R,QAAQxM,UAAYvF,KAAK+R,QAAQxM,YAI9CuQ,cAAe,WACN9V,KAAK+R,QAAQxM,SAASC,SAAUuO,EAAO/T,KAAK+R,QAAQxM,YAAWvF,KAAK+R,QAAQxM,UAAYvF,KAAK+R,QAAQxM,YAG9GuP,mBAAoB,SAAU7H,GAC1B,GAAIgE,GAASjR,KAAK+R,QAAQyF,YAAYvK,EAAOnC,QAE7C,OADUlJ,GAAEmJ,KAAK6D,QAAQqC,EAAQhE,EAAOnC,SAC9B,GACHlJ,EAAEC,SAAS6R,WAAWlS,UAAUsT,mBAAmBvU,KAAKP,KAAMiN,IAGzEiH,kBAAmB,WAEf,MADKlU,MAAK+R,QAAQxM,SAASC,QAAQxF,KAAK+R,QAAQxM,SAAS4P,SAClDnV,KAAK+R,QAAQxM,SAAS,IAGjCkR,YAAa,SAAUd,GAInB,OAAI5B,EAAO4B,IAAYA,EAAM,IAA0B,IAApBA,EAAM,GAAGnQ,OAChCmQ,GADuDA,MAQ3E/T,EAAEC,SAAS4V,gBAAkB7V,EAAEC,SAAS6R,WAAW3R,QAE/CkN,QAAQ,EACR0E,WAAY,EAEZxR,SACIuB,mBAAmB,GAGvBqR,aAAc,SAAUzQ,GACpB,GAAIyK,GAAQzK,EAAE2I,OAAOuB,WACjBZ,EAAOtJ,EAAE2I,OAAOY,UAChBqB,EAAW5K,EAAE2I,OAAO6B,cACpB4I,GAAiB3I,EAAQ,GAAK,EAC9B4I,EAAWrT,EAAE2I,OAAOnC,QAAQ4M,GAC5BvN,EAAS,GAAIvI,GAAEwI,aAAa9F,EAAEgB,OAAQqS,EAE1CzI,GAAS5J,OAAOkI,QAAQlJ,EAAEgB,OAAO4R,IAAKS,EAASR,MAC/CvJ,EAAKtI,OAAOkI,QAAQmK,EAAST,IAAK5S,EAAEgB,OAAO6R,MAC3CnX,KAAK4X,aAAazN,GAClBnK,KAAKiU,wBAGTlM,mBAAoB,SAAUzD,GAC1B1C,EAAEC,SAAS6R,WAAWlS,UAAUuG,mBAAmBxH,KAAKP,KAAMsE,GAC9DtE,KAAKiT,SACL,IAAInI,GAAU9K,KAAKkU,mBAGI,KAAnBpJ,EAAQtF,QAAcsF,EAAQqK,KAAK7Q,EAAEgB,OACzC,IAAI6E,GAAS,GAAIvI,GAAEwI,aAAa9F,EAAEgB,OAAQhB,EAAEgB,OAC5CtF,MAAK4X,aAAazN,GAClBnK,KAAK6X,cAAc1N,GACnBnK,KAAK0N,UACL1N,KAAK6G,QAULvC,EAAEsD,cAAckQ,YAAa,EAC7B9X,KAAK4D,IAAI6N,SAASC,WAAWqG,MAAMzT,EAAEsD,eAIrCkD,EAAQ,GAAGoB,SAASuF,SAASC,WAAWC,QAAQrN,EAAEsD,gBAGtDK,iBAAkB,SAAU3D,GACxBtE,KAAK+I,cAAczE,GACnBA,EAAEsD,cAAckQ,YAAa,EAC7BlW,EAAEC,SAAS6R,WAAWlS,UAAUyG,iBAAiB1H,KAAKP,KAAMsE,IAGhEyC,mBAAoB,SAAUzC,GAC1BA,EAAEsD,cAAckQ,YAAa,EAC7BlW,EAAEC,SAAS6R,WAAWlS,UAAUuF,mBAAmBxG,KAAKP,KAAMsE,IAIlE4P,kBAAmB,SAAUpJ,GACzB,MAAOA,IAAW9K,KAAK+R,QAAQxM,SAAS,IAG5CqS,aAAc,SAAUzN,GACpBnK,KAAK+R,QAAQtM,QAAU0E,GAG3B0N,cAAe,SAAU1N,GAIrB,IAAK,GAHDW,GAAU9K,KAAKkU,oBACf8D,EAAahY,KAAK+R,QAAQkG,iBAAiB9N,GAEtC9J,EAAI,EAAGA,EAAIyK,EAAQtF,OAAQnF,IAChCyK,EAAQzK,GAAGmN,OAAOwK,EAAW3X,OAQzCuB,EAAEC,SAASqW,aAAetW,EAAEC,SAAS6R,WAAW3R,QAE5C4R,WAAY,EAEZxR,SACIuB,mBAAmB,GAGvBC,WAAY,SAAUC,EAAKmO,EAAS5P,GAChCP,EAAEC,SAAS6R,WAAWlS,UAAUmC,WAAWpD,KAAKP,KAAM4D,EAAKmO,EAAS5P,GACpEnC,KAAKmY,cAAgBnY,KAAKoY,uBAG9BA,oBAAqB,WAEjB,GAAIC,IAASrY,KAAK+R,QAAQuG,SAAWtY,KAAK+R,QAAQwG,UAAY/P,KAAKgQ,IAAIhQ,KAAKiQ,GAAK,GAC7EtQ,EAAQnI,KAAK4D,IAAI8U,QAAQ1Y,KAAK+R,QAAQtE,QAC1C,OAAOzN,MAAK4D,IAAI+U,WAAWxQ,EAAMoI,EAAI8H,EAAOlQ,EAAMyI,EAAIyH,KAG1DO,mBAAoB,WAChB5Y,KAAKmY,cAAc3K,OAAOxN,KAAKoY,uBAC/BpY,KAAKmY,cAAcjM,SAASsB,UAGhCsG,WAAY,WACR,OAAQ9T,KAAK+R,QAAQtE,QAASzN,KAAKmY,gBAGvCjE,kBAAmB,WACf,MAAOlU,MAAK8T,cAGhB5G,mBAAoB,SAAU5I,GACE,IAAxBA,EAAE2I,OAAOuB,WAAkBxO,KAAK6Y,OAAOvU,GACtCtE,KAAK4Y,mBAAmBtU,GAC7B1C,EAAEC,SAAS6R,WAAWlS,UAAU0L,mBAAmB3M,KAAKP,KAAMsE,IAGlEuU,OAAQ,SAAUvU,GACd,GAAIwU,GAAS9Y,KAAK+R,QAAQtE,QAAQlF,WAAWjE,EAAEgB,OAC/CtF,MAAK+R,QAAQgH,UAAUD,IAG3B/Q,mBAAoB,SAAUzD,GAC1B1C,EAAEC,SAAS6R,WAAWlS,UAAUuG,mBAAmBxH,KAAKP,KAAMsE,GAC9DtE,KAAKmY,cAAc3K,OAAOlJ,EAAEgB,QAC5BtF,KAAK+R,QAAQtE,QAAQD,OAAOlJ,EAAEgB,QAC9BtF,KAAKiT,UAEL3O,EAAEsD,cAAckQ,YAAa,EAC7B9X,KAAK4D,IAAI6N,SAASC,WAAWqG,MAAMzT,EAAEsD,eAErC5H,KAAKmY,cAAcjM,SAASuF,SAASC,WAAWC,QAAQrN,EAAEsD,gBAG9DK,iBAAkB,SAAU3D,GACxBtE,KAAK+I,cAAczE,GACnBA,EAAEsD,cAAckQ,YAAa,EAC7BlW,EAAEC,SAAS6R,WAAWlS,UAAUyG,iBAAiB1H,KAAKP,KAAMsE,IAGhEyC,mBAAoB,SAAUzC,GAC1BA,EAAEsD,cAAckQ,YAAa,EAC7BlW,EAAEC,SAAS6R,WAAWlS,UAAUuF,mBAAmBxG,KAAKP,KAAMsE,IAGlE+H,OAAQ,SAAU/H,GACd1C,EAAEC,SAAS6R,WAAWlS,UAAU6K,OAAO9L,KAAKP,KAAMsE,GAClDtE,KAAK+R,QAAQN,SAAS9D,aAAa3N,KAAKmY,iBAUhD,IAAIa,IAEAC,aAAc,SAAUrV,GACpBA,EAAMA,GAAO5D,KAAKsN,IAClB,IAAIrB,IAASjM,KAAKmC,QAAQ6I,iBAAmBzG,WAAaX,EAAIW,SAC9D,KAAK0H,EAAO,KAAMiN,OAAM,sCAExB,OAAO,KADKlZ,KAAKmC,QAAQgX,aAAenZ,KAAKoZ,eAAenN,IAC3CrI,EAAK5D,KAAMA,KAAKmC,QAAQ6I,cAK7C3B,WAAY,SAAUzF,GAGlB,MAFK5D,MAAK0G,QAAQ1G,KAAKiZ,aAAarV,GACpC5D,KAAK0G,OAAOgM,SACL1S,KAAK0G,QAKhB2S,YAAa,WACT,MAAOrZ,MAAK0G,QAAU1G,KAAK0G,OAAOmN,WAKtCyF,YAAa,WACLtZ,KAAK0G,SACL1G,KAAK0G,OAAO6L,gBACLvS,MAAK0G,SAMpB6S,WAAY,WACJvZ,KAAKqZ,cAAerZ,KAAKsZ,cACxBtZ,KAAKqJ,cAGdmQ,eAAgB,WACRxZ,KAAK0G,QAAQ1G,KAAKqJ,eAK1BoQ,GAEAL,eAAgB,SAAUnN,GACtB,MAAQA,IAASA,EAAM9J,QAAQiB,oBAAuB6I,EAAM9J,QAAQiB,oBAAsBxB,EAAEC,SAAS8U,gBAGzGP,QAAS,SAAU9Q,EAAQwF,GAIvB,GAAI6K,GAAQ,IAEZ,IADA7K,EAAUA,GAAW9K,KAAKuF,UACrBuF,EAAQtF,OAAQ,MAAOmQ,EACvB,IAAI5B,EAAOjJ,IAAY9K,KAAK0Z,YAAYpU,EAAQwF,GAAU6K,EAAQ7K,MAClE,KAAK,GAAIzK,GAAI,EAAGA,EAAIyK,EAAQtF,OAAQnF,IAAK,GAAIL,KAAK0Z,YAAYpU,EAAQwF,EAAQzK,IAAK,MAAOyK,GAAQzK,EACvG,OAAOsV,IAGX+D,YAAa,SAAUpZ,EAAGwK,GACtB,IAAKA,EAAS,OAAO,CACrB,IAAIzK,GAAGsZ,EAAGC,EAAgBlY,EAAXmY,KACXC,EAAI9Z,KAAK+Z,iBAKb,IAJA/Z,KAAKga,gBAAgBlP,EAAS+O,EAAM7Z,KAAKia,WACzCJ,EAAOA,EAAK,GACZnY,EAAI1B,KAAKsN,KAAK4M,mBAAmB5Z,IAE5BN,KAAKia,UAAUE,SAASzY,GAAM,OAAO,CAC1C,KAAKrB,EAAI,EAAGuZ,EAAMC,EAAKrU,OAAQmU,EAAI,EAAGtZ,EAAIuZ,EAAKD,EAAItZ,IAE/C,GAAIuB,EAAEwY,SAASC,uBAAuB3Y,EAAGmY,EAAKF,GAAIE,EAAKxZ,KAAOyZ,EAC1D,OAAO,CAGf,QAAO,IAKXQ,GAEAlB,eAAgB,SAAUnN,GACtB,MAAQA,IAASA,EAAM9J,QAAQkB,mBAAsB4I,EAAM9J,QAAQkB,mBAAqBzB,EAAEC,SAASwV,eAGvGjB,QAAS,SAAU9Q,EAAQwF,GAKvB,GAAI6K,GAAQ,IAEZ,IADA7K,EAAUA,GAAW9K,KAAKuF,UACrBuF,EAAQtF,OAAQ,MAAOmQ,EACvB,IAAI5B,EAAOjJ,IAAY9K,KAAK0Z,YAAYpU,EAAQwF,GAAU6K,EAAQ7K,MAClE,IAAIiJ,EAAOjJ,EAAQ,KAAO9K,KAAK0Z,YAAYpU,EAAQwF,EAAQ,IAAK6K,EAAQ7K,MACxE,KAAK,GAAIzK,GAAI,EAAGA,EAAIyK,EAAQtF,OAAQnF,IAAK,GAAIL,KAAK0Z,YAAYpU,EAAQwF,EAAQzK,GAAG,IAAK,MAAOyK,GAAQzK,EAC1G,OAAOsV,IAGX+D,YAAa,SAAUpZ,EAAGwK,GACtB,GAAoByP,GAAIC,EAAIC,EAAGd,EAAGe,EAA9BC,GAAS,CAEb,KAAKF,EAAI,EAAGC,EAAO5P,EAAQtF,OAAQmU,EAAIe,EAAO,EAAGD,EAAIC,EAAMf,EAAIc,IAC3DF,EAAKzP,EAAQ2P,GACbD,EAAK1P,EAAQ6O,GAEPY,EAAGrD,IAAM5W,EAAE4W,KAAUsD,EAAGtD,IAAM5W,EAAE4W,KACjC5W,EAAE6W,KAAOqD,EAAGrD,IAAMoD,EAAGpD,MAAQ7W,EAAE4W,IAAMqD,EAAGrD,MAAQsD,EAAGtD,IAAMqD,EAAGrD,KAAOqD,EAAGpD,MACvEwD,GAAUA,EAIlB,OAAOA,IAGXnD,YAAa,SAAU7B,EAAO7K,GAE1B,GADAA,EAAUA,GAAW9K,KAAKuF,SAC1B,CACA,GAAIqV,GAAMhZ,EAAEmJ,KAAK6D,QAAQ9D,EAAS6K,EAClC,KAAa,IAATiF,EAAY,MAAO9P,EACvB,KAAK,GAAIzK,GAAI,EAAGA,EAAIyK,EAAQtF,OAAQnF,IAEhC,IAAa,KADbua,EAAMhZ,EAAEmJ,KAAK6D,QAAQ9D,EAAQzK,GAAIsV,IACjB,MAAO7K,GAAQzK,MAOvCwa,GAEAzB,eAAgB,SAAUnN,GACtB,MAAQA,IAASA,EAAM9J,QAAQmB,kBAAqB2I,EAAM9J,QAAQmB,kBAAoB1B,EAAEC,SAAS4R,eAKrGqH,GAEA1B,eAAgB,SAAUnN,GACtB,MAAQA,IAASA,EAAM9J,QAAQoB,qBAAwB0I,EAAM9J,QAAQoB,qBAAuB3B,EAAEC,SAAS4V,kBAK3GsD,GAEA3B,eAAgB,SAAUnN,GACtB,MAAQA,IAASA,EAAM9J,QAAQqB,kBAAqByI,EAAM9J,QAAQqB,kBAAoB5B,EAAEC,SAASqW,eAKrG8C,EAAe,WAEfhb,KAAK8G,GAAG,MAAO9G,KAAKwZ,iBAGpBzF,EAASnS,EAAEwY,SAASrG,QAAUnS,EAAEwY,SAASa,OAASrZ,EAAEY,SAASyY,KAG7DrZ,GAAEY,WACFZ,EAAEY,SAAS0Y,QAAQlC,GACnBpX,EAAEY,SAAS0Y,QAAQzB,GACnB7X,EAAEY,SAASgJ,YAAYwP,IAEvBpZ,EAAEU,UACFV,EAAEU,QAAQ4Y,QAAQlC,GAClBpX,EAAEU,QAAQ4Y,QAAQZ,IAElB1Y,EAAEc,SACFd,EAAEc,OAAOwY,QAAQlC,GACjBpX,EAAEc,OAAOwY,QAAQL,GACjBjZ,EAAEc,OAAO8I,YAAYwP,IAErBpZ,EAAEgB,YACFhB,EAAEgB,UAAUsY,QAAQlC,GACpBpX,EAAEgB,UAAUsY,QAAQJ,IAEpBlZ,EAAEkB,SACFlB,EAAEkB,OAAOoY,QAAQlC,GACjBpX,EAAEkB,OAAOoY,QAAQH,IAGrBnZ,EAAEiV,OAAOrV,UAAUgM,OAAS,SAAUlI,GAClCA,EAAS1D,EAAEsI,OAAO5E,GAClBtF,KAAKkX,IAAM5R,EAAO4R,IAClBlX,KAAKmX,IAAM7R,EAAO6R,OAGrBzO,OAAO9G,IF6EN,SAAU/B,EAAQD,EAASM,GAEjCL,EAAOD,QAAUM,EAAoB","file":"Vue2LeafletEditablePlugin.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Vue2LeafletEditablePlugin\"] = factory();\n\telse\n\t\troot[\"Vue2LeafletEditablePlugin\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Vue2LeafletEditablePlugin\"] = factory();\n\telse\n\t\troot[\"Vue2LeafletEditablePlugin\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 1);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\nfunction init(L) {\n    // 🍂miniclass CancelableEvent (Event objects)\n    // 🍂method cancel()\n    // Cancel any subsequent action.\n\n    // 🍂miniclass VertexEvent (Event objects)\n    // 🍂property vertex: VertexMarker\n    // The vertex that fires the event.\n\n    // 🍂miniclass ShapeEvent (Event objects)\n    // 🍂property shape: Array\n    // The shape (LatLngs array) subject of the action.\n\n    // 🍂miniclass CancelableVertexEvent (Event objects)\n    // 🍂inherits VertexEvent\n    // 🍂inherits CancelableEvent\n\n    // 🍂miniclass CancelableShapeEvent (Event objects)\n    // 🍂inherits ShapeEvent\n    // 🍂inherits CancelableEvent\n\n    // 🍂miniclass LayerEvent (Event objects)\n    // 🍂property layer: object\n    // The Layer (Marker, Polyline…) subject of the action.\n\n    // 🍂namespace Editable; 🍂class Editable; 🍂aka L.Editable\n    // Main edition handler. By default, it is attached to the map\n    // as `map.editTools` property.\n    // Leaflet.Editable is made to be fully extendable. You have three ways to customize\n    // the behaviour: using options, listening to events, or extending.\n    L.Editable = L.Evented.extend({\n\n        statics: {\n            FORWARD: 1,\n            BACKWARD: -1\n        },\n\n        options: {\n\n            // You can pass them when creating a map using the `editOptions` key.\n            // 🍂option zIndex: int = 1000\n            // The default zIndex of the editing tools.\n            zIndex: 1000,\n\n            // 🍂option polygonClass: class = L.Polygon\n            // Class to be used when creating a new Polygon.\n            polygonClass: L.Polygon,\n\n            // 🍂option polylineClass: class = L.Polyline\n            // Class to be used when creating a new Polyline.\n            polylineClass: L.Polyline,\n\n            // 🍂option markerClass: class = L.Marker\n            // Class to be used when creating a new Marker.\n            markerClass: L.Marker,\n\n            // 🍂option rectangleClass: class = L.Rectangle\n            // Class to be used when creating a new Rectangle.\n            rectangleClass: L.Rectangle,\n\n            // 🍂option circleClass: class = L.Circle\n            // Class to be used when creating a new Circle.\n            circleClass: L.Circle,\n\n            // 🍂option drawingCSSClass: string = 'leaflet-editable-drawing'\n            // CSS class to be added to the map container while drawing.\n            drawingCSSClass: 'leaflet-editable-drawing',\n\n            // 🍂option drawingCursor: const = 'crosshair'\n            // Cursor mode set to the map while drawing.\n            drawingCursor: 'crosshair',\n\n            // 🍂option editLayer: Layer = new L.LayerGroup()\n            // Layer used to store edit tools (vertex, line guide…).\n            editLayer: undefined,\n\n            // 🍂option featuresLayer: Layer = new L.LayerGroup()\n            // Default layer used to store drawn features (Marker, Polyline…).\n            featuresLayer: undefined,\n\n            // 🍂option polylineEditorClass: class = PolylineEditor\n            // Class to be used as Polyline editor.\n            polylineEditorClass: undefined,\n\n            // 🍂option polygonEditorClass: class = PolygonEditor\n            // Class to be used as Polygon editor.\n            polygonEditorClass: undefined,\n\n            // 🍂option markerEditorClass: class = MarkerEditor\n            // Class to be used as Marker editor.\n            markerEditorClass: undefined,\n\n            // 🍂option rectangleEditorClass: class = RectangleEditor\n            // Class to be used as Rectangle editor.\n            rectangleEditorClass: undefined,\n\n            // 🍂option circleEditorClass: class = CircleEditor\n            // Class to be used as Circle editor.\n            circleEditorClass: undefined,\n\n            // 🍂option lineGuideOptions: hash = {}\n            // Options to be passed to the line guides.\n            lineGuideOptions: {},\n\n            // 🍂option skipMiddleMarkers: boolean = false\n            // Set this to true if you don't want middle markers.\n            skipMiddleMarkers: false\n\n        },\n\n        initialize: function initialize(map, options) {\n            L.setOptions(this, options);\n            this._lastZIndex = this.options.zIndex;\n            this.map = map;\n            this.editLayer = this.createEditLayer();\n            this.featuresLayer = this.createFeaturesLayer();\n            this.forwardLineGuide = this.createLineGuide();\n            this.backwardLineGuide = this.createLineGuide();\n        },\n\n        fireAndForward: function fireAndForward(type, e) {\n            e = e || {};\n            e.editTools = this;\n            this.fire(type, e);\n            this.map.fire(type, e);\n        },\n\n        createLineGuide: function createLineGuide() {\n            var options = L.extend({ dashArray: '5,10', weight: 1, interactive: false }, this.options.lineGuideOptions);\n            return L.polyline([], options);\n        },\n\n        createVertexIcon: function createVertexIcon(options) {\n            return L.Browser.mobile && L.Browser.touch ? new L.Editable.TouchVertexIcon(options) : new L.Editable.VertexIcon(options);\n        },\n\n        createEditLayer: function createEditLayer() {\n            return this.options.editLayer || new L.LayerGroup().addTo(this.map);\n        },\n\n        createFeaturesLayer: function createFeaturesLayer() {\n            return this.options.featuresLayer || new L.LayerGroup().addTo(this.map);\n        },\n\n        moveForwardLineGuide: function moveForwardLineGuide(latlng) {\n            if (this.forwardLineGuide._latlngs.length) {\n                this.forwardLineGuide._latlngs[1] = latlng;\n                this.forwardLineGuide._bounds.extend(latlng);\n                this.forwardLineGuide.redraw();\n            }\n        },\n\n        moveBackwardLineGuide: function moveBackwardLineGuide(latlng) {\n            if (this.backwardLineGuide._latlngs.length) {\n                this.backwardLineGuide._latlngs[1] = latlng;\n                this.backwardLineGuide._bounds.extend(latlng);\n                this.backwardLineGuide.redraw();\n            }\n        },\n\n        anchorForwardLineGuide: function anchorForwardLineGuide(latlng) {\n            this.forwardLineGuide._latlngs[0] = latlng;\n            this.forwardLineGuide._bounds.extend(latlng);\n            this.forwardLineGuide.redraw();\n        },\n\n        anchorBackwardLineGuide: function anchorBackwardLineGuide(latlng) {\n            this.backwardLineGuide._latlngs[0] = latlng;\n            this.backwardLineGuide._bounds.extend(latlng);\n            this.backwardLineGuide.redraw();\n        },\n\n        attachForwardLineGuide: function attachForwardLineGuide() {\n            this.editLayer.addLayer(this.forwardLineGuide);\n        },\n\n        attachBackwardLineGuide: function attachBackwardLineGuide() {\n            this.editLayer.addLayer(this.backwardLineGuide);\n        },\n\n        detachForwardLineGuide: function detachForwardLineGuide() {\n            this.forwardLineGuide.setLatLngs([]);\n            this.editLayer.removeLayer(this.forwardLineGuide);\n        },\n\n        detachBackwardLineGuide: function detachBackwardLineGuide() {\n            this.backwardLineGuide.setLatLngs([]);\n            this.editLayer.removeLayer(this.backwardLineGuide);\n        },\n\n        blockEvents: function blockEvents() {\n            // Hack: force map not to listen to other layers events while drawing.\n            if (!this._oldTargets) {\n                this._oldTargets = this.map._targets;\n                this.map._targets = {};\n            }\n        },\n\n        unblockEvents: function unblockEvents() {\n            if (this._oldTargets) {\n                // Reset, but keep targets created while drawing.\n                this.map._targets = L.extend(this.map._targets, this._oldTargets);\n                delete this._oldTargets;\n            }\n        },\n\n        registerForDrawing: function registerForDrawing(editor) {\n            if (this._drawingEditor) this.unregisterForDrawing(this._drawingEditor);\n            this.blockEvents();\n            editor.reset(); // Make sure editor tools still receive events.\n            this._drawingEditor = editor;\n            this.map.on('mousemove touchmove', editor.onDrawingMouseMove, editor);\n            this.map.on('mousedown', this.onMousedown, this);\n            this.map.on('mouseup', this.onMouseup, this);\n            L.DomUtil.addClass(this.map._container, this.options.drawingCSSClass);\n            this.defaultMapCursor = this.map._container.style.cursor;\n            this.map._container.style.cursor = this.options.drawingCursor;\n        },\n\n        unregisterForDrawing: function unregisterForDrawing(editor) {\n            this.unblockEvents();\n            L.DomUtil.removeClass(this.map._container, this.options.drawingCSSClass);\n            this.map._container.style.cursor = this.defaultMapCursor;\n            editor = editor || this._drawingEditor;\n            if (!editor) return;\n            this.map.off('mousemove touchmove', editor.onDrawingMouseMove, editor);\n            this.map.off('mousedown', this.onMousedown, this);\n            this.map.off('mouseup', this.onMouseup, this);\n            if (editor !== this._drawingEditor) return;\n            delete this._drawingEditor;\n            if (editor._drawing) editor.cancelDrawing();\n        },\n\n        onMousedown: function onMousedown(e) {\n            if (e.originalEvent.which != 1) return;\n            this._mouseDown = e;\n            this._drawingEditor.onDrawingMouseDown(e);\n        },\n\n        onMouseup: function onMouseup(e) {\n            if (this._mouseDown) {\n                var editor = this._drawingEditor,\n                    mouseDown = this._mouseDown;\n                this._mouseDown = null;\n                editor.onDrawingMouseUp(e);\n                if (this._drawingEditor !== editor) return; // onDrawingMouseUp may call unregisterFromDrawing.\n                var origin = L.point(mouseDown.originalEvent.clientX, mouseDown.originalEvent.clientY);\n                var distance = L.point(e.originalEvent.clientX, e.originalEvent.clientY).distanceTo(origin);\n                if (Math.abs(distance) < 9 * (window.devicePixelRatio || 1)) this._drawingEditor.onDrawingClick(e);\n            }\n        },\n\n        // 🍂section Public methods\n        // You will generally access them by the `map.editTools`\n        // instance:\n        //\n        // `map.editTools.startPolyline();`\n\n        // 🍂method drawing(): boolean\n        // Return true if any drawing action is ongoing.\n        drawing: function drawing() {\n            return this._drawingEditor && this._drawingEditor.drawing();\n        },\n\n        // 🍂method stopDrawing()\n        // When you need to stop any ongoing drawing, without needing to know which editor is active.\n        stopDrawing: function stopDrawing() {\n            this.unregisterForDrawing();\n        },\n\n        // 🍂method commitDrawing()\n        // When you need to commit any ongoing drawing, without needing to know which editor is active.\n        commitDrawing: function commitDrawing(e) {\n            if (!this._drawingEditor) return;\n            this._drawingEditor.commitDrawing(e);\n        },\n\n        connectCreatedToMap: function connectCreatedToMap(layer) {\n            return this.featuresLayer.addLayer(layer);\n        },\n\n        // 🍂method startPolyline(latlng: L.LatLng, options: hash): L.Polyline\n        // Start drawing a Polyline. If `latlng` is given, a first point will be added. In any case, continuing on user click.\n        // If `options` is given, it will be passed to the Polyline class constructor.\n        startPolyline: function startPolyline(latlng, options) {\n            var line = this.createPolyline([], options);\n            line.enableEdit(this.map).newShape(latlng);\n            return line;\n        },\n\n        // 🍂method startPolygon(latlng: L.LatLng, options: hash): L.Polygon\n        // Start drawing a Polygon. If `latlng` is given, a first point will be added. In any case, continuing on user click.\n        // If `options` is given, it will be passed to the Polygon class constructor.\n        startPolygon: function startPolygon(latlng, options) {\n            var polygon = this.createPolygon([], options);\n            polygon.enableEdit(this.map).newShape(latlng);\n            return polygon;\n        },\n\n        // 🍂method startMarker(latlng: L.LatLng, options: hash): L.Marker\n        // Start adding a Marker. If `latlng` is given, the Marker will be shown first at this point.\n        // In any case, it will follow the user mouse, and will have a final `latlng` on next click (or touch).\n        // If `options` is given, it will be passed to the Marker class constructor.\n        startMarker: function startMarker(latlng, options) {\n            latlng = latlng || this.map.getCenter().clone();\n            var marker = this.createMarker(latlng, options);\n            marker.enableEdit(this.map).startDrawing();\n            return marker;\n        },\n\n        // 🍂method startRectangle(latlng: L.LatLng, options: hash): L.Rectangle\n        // Start drawing a Rectangle. If `latlng` is given, the Rectangle anchor will be added. In any case, continuing on user drag.\n        // If `options` is given, it will be passed to the Rectangle class constructor.\n        startRectangle: function startRectangle(latlng, options) {\n            var corner = latlng || L.latLng([0, 0]);\n            var bounds = new L.LatLngBounds(corner, corner);\n            var rectangle = this.createRectangle(bounds, options);\n            rectangle.enableEdit(this.map).startDrawing();\n            return rectangle;\n        },\n\n        // 🍂method startCircle(latlng: L.LatLng, options: hash): L.Circle\n        // Start drawing a Circle. If `latlng` is given, the Circle anchor will be added. In any case, continuing on user drag.\n        // If `options` is given, it will be passed to the Circle class constructor.\n        startCircle: function startCircle(latlng, options) {\n            latlng = latlng || this.map.getCenter().clone();\n            var circle = this.createCircle(latlng, options);\n            circle.enableEdit(this.map).startDrawing();\n            return circle;\n        },\n\n        startHole: function startHole(editor, latlng) {\n            editor.newHole(latlng);\n        },\n\n        createLayer: function createLayer(klass, latlngs, options) {\n            options = L.Util.extend({ editOptions: { editTools: this } }, options);\n            var layer = new klass(latlngs, options);\n            // 🍂namespace Editable\n            // 🍂event editable:created: LayerEvent\n            // Fired when a new feature (Marker, Polyline…) is created.\n            this.fireAndForward('editable:created', { layer: layer });\n            return layer;\n        },\n\n        createPolyline: function createPolyline(latlngs, options) {\n            return this.createLayer(options && options.polylineClass || this.options.polylineClass, latlngs, options);\n        },\n\n        createPolygon: function createPolygon(latlngs, options) {\n            return this.createLayer(options && options.polygonClass || this.options.polygonClass, latlngs, options);\n        },\n\n        createMarker: function createMarker(latlng, options) {\n            return this.createLayer(options && options.markerClass || this.options.markerClass, latlng, options);\n        },\n\n        createRectangle: function createRectangle(bounds, options) {\n            return this.createLayer(options && options.rectangleClass || this.options.rectangleClass, bounds, options);\n        },\n\n        createCircle: function createCircle(latlng, options) {\n            return this.createLayer(options && options.circleClass || this.options.circleClass, latlng, options);\n        }\n\n    });\n\n    L.extend(L.Editable, {\n\n        makeCancellable: function makeCancellable(e) {\n            e.cancel = function () {\n                e._cancelled = true;\n            };\n        }\n\n    });\n\n    // 🍂namespace Map; 🍂class Map\n    // Leaflet.Editable add options and events to the `L.Map` object.\n    // See `Editable` events for the list of events fired on the Map.\n    // 🍂example\n    //\n    // ```js\n    // var map = L.map('map', {\n    //  editable: true,\n    //  editOptions: {\n    //    …\n    // }\n    // });\n    // ```\n    // 🍂section Editable Map Options\n    L.Map.mergeOptions({\n\n        // 🍂namespace Map\n        // 🍂section Map Options\n        // 🍂option editToolsClass: class = L.Editable\n        // Class to be used as vertex, for path editing.\n        editToolsClass: L.Editable,\n\n        // 🍂option editable: boolean = false\n        // Whether to create a L.Editable instance at map init.\n        editable: false,\n\n        // 🍂option editOptions: hash = {}\n        // Options to pass to L.Editable when instantiating.\n        editOptions: {}\n\n    });\n\n    L.Map.addInitHook(function () {\n\n        this.whenReady(function () {\n            if (this.options.editable) {\n                this.editTools = new this.options.editToolsClass(this, this.options.editOptions);\n            }\n        });\n    });\n\n    L.Editable.VertexIcon = L.DivIcon.extend({\n\n        options: {\n            iconSize: new L.Point(8, 8)\n        }\n\n    });\n\n    L.Editable.TouchVertexIcon = L.Editable.VertexIcon.extend({\n\n        options: {\n            iconSize: new L.Point(20, 20)\n        }\n\n    });\n\n    // 🍂namespace Editable; 🍂class VertexMarker; Handler for dragging path vertices.\n    L.Editable.VertexMarker = L.Marker.extend({\n\n        options: {\n            draggable: true,\n            className: 'leaflet-div-icon leaflet-vertex-icon'\n        },\n\n        // 🍂section Public methods\n        // The marker used to handle path vertex. You will usually interact with a `VertexMarker`\n        // instance when listening for events like `editable:vertex:ctrlclick`.\n\n        initialize: function initialize(latlng, latlngs, editor, options) {\n            // We don't use this._latlng, because on drag Leaflet replace it while\n            // we want to keep reference.\n            this.latlng = latlng;\n            this.latlngs = latlngs;\n            this.editor = editor;\n            L.Marker.prototype.initialize.call(this, latlng, options);\n            this.options.icon = this.editor.tools.createVertexIcon({ className: this.options.className });\n            this.latlng.__vertex = this;\n            this.editor.editLayer.addLayer(this);\n            this.setZIndexOffset(editor.tools._lastZIndex + 1);\n        },\n\n        onAdd: function onAdd(map) {\n            L.Marker.prototype.onAdd.call(this, map);\n            this.on('drag', this.onDrag);\n            this.on('dragstart', this.onDragStart);\n            this.on('dragend', this.onDragEnd);\n            this.on('mouseup', this.onMouseup);\n            this.on('click', this.onClick);\n            this.on('contextmenu', this.onContextMenu);\n            this.on('mousedown touchstart', this.onMouseDown);\n            this.on('mouseover', this.onMouseOver);\n            this.on('mouseout', this.onMouseOut);\n            this.addMiddleMarkers();\n        },\n\n        onRemove: function onRemove(map) {\n            if (this.middleMarker) this.middleMarker.delete();\n            delete this.latlng.__vertex;\n            this.off('drag', this.onDrag);\n            this.off('dragstart', this.onDragStart);\n            this.off('dragend', this.onDragEnd);\n            this.off('mouseup', this.onMouseup);\n            this.off('click', this.onClick);\n            this.off('contextmenu', this.onContextMenu);\n            this.off('mousedown touchstart', this.onMouseDown);\n            this.off('mouseover', this.onMouseOver);\n            this.off('mouseout', this.onMouseOut);\n            L.Marker.prototype.onRemove.call(this, map);\n        },\n\n        onDrag: function onDrag(e) {\n            e.vertex = this;\n            this.editor.onVertexMarkerDrag(e);\n            var iconPos = L.DomUtil.getPosition(this._icon),\n                latlng = this._map.layerPointToLatLng(iconPos);\n            this.latlng.update(latlng);\n            this._latlng = this.latlng; // Push back to Leaflet our reference.\n            this.editor.refresh();\n            if (this.middleMarker) this.middleMarker.updateLatLng();\n            var next = this.getNext();\n            if (next && next.middleMarker) next.middleMarker.updateLatLng();\n        },\n\n        onDragStart: function onDragStart(e) {\n            e.vertex = this;\n            this.editor.onVertexMarkerDragStart(e);\n        },\n\n        onDragEnd: function onDragEnd(e) {\n            e.vertex = this;\n            this.editor.onVertexMarkerDragEnd(e);\n        },\n\n        onClick: function onClick(e) {\n            e.vertex = this;\n            this.editor.onVertexMarkerClick(e);\n        },\n\n        onMouseup: function onMouseup(e) {\n            L.DomEvent.stop(e);\n            e.vertex = this;\n            this.editor.map.fire('mouseup', e);\n        },\n\n        onContextMenu: function onContextMenu(e) {\n            e.vertex = this;\n            this.editor.onVertexMarkerContextMenu(e);\n        },\n\n        onMouseDown: function onMouseDown(e) {\n            e.vertex = this;\n            this.editor.onVertexMarkerMouseDown(e);\n        },\n\n        onMouseOver: function onMouseOver(e) {\n            e.vertex = this;\n            this.editor.onVertexMarkerMouseOver(e);\n        },\n\n        onMouseOut: function onMouseOut(e) {\n            e.vertex = this;\n            this.editor.onVertexMarkerMouseOut(e);\n        },\n\n        // 🍂method delete()\n        // Delete a vertex and the related LatLng.\n        delete: function _delete() {\n            var next = this.getNext(); // Compute before changing latlng\n            this.latlngs.splice(this.getIndex(), 1);\n            this.editor.editLayer.removeLayer(this);\n            this.editor.onVertexDeleted({ latlng: this.latlng, vertex: this });\n            if (!this.latlngs.length) this.editor.deleteShape(this.latlngs);\n            if (next) next.resetMiddleMarker();\n            this.editor.refresh();\n        },\n\n        // 🍂method getIndex(): int\n        // Get the index of the current vertex among others of the same LatLngs group.\n        getIndex: function getIndex() {\n            return this.latlngs.indexOf(this.latlng);\n        },\n\n        // 🍂method getLastIndex(): int\n        // Get last vertex index of the LatLngs group of the current vertex.\n        getLastIndex: function getLastIndex() {\n            return this.latlngs.length - 1;\n        },\n\n        // 🍂method getPrevious(): VertexMarker\n        // Get the previous VertexMarker in the same LatLngs group.\n        getPrevious: function getPrevious() {\n            if (this.latlngs.length < 2) return;\n            var index = this.getIndex(),\n                previousIndex = index - 1;\n            if (index === 0 && this.editor.CLOSED) previousIndex = this.getLastIndex();\n            var previous = this.latlngs[previousIndex];\n            if (previous) return previous.__vertex;\n        },\n\n        // 🍂method getNext(): VertexMarker\n        // Get the next VertexMarker in the same LatLngs group.\n        getNext: function getNext() {\n            if (this.latlngs.length < 2) return;\n            var index = this.getIndex(),\n                nextIndex = index + 1;\n            if (index === this.getLastIndex() && this.editor.CLOSED) nextIndex = 0;\n            var next = this.latlngs[nextIndex];\n            if (next) return next.__vertex;\n        },\n\n        addMiddleMarker: function addMiddleMarker(previous) {\n            if (!this.editor.hasMiddleMarkers()) return;\n            previous = previous || this.getPrevious();\n            if (previous && !this.middleMarker) this.middleMarker = this.editor.addMiddleMarker(previous, this, this.latlngs, this.editor);\n        },\n\n        addMiddleMarkers: function addMiddleMarkers() {\n            if (!this.editor.hasMiddleMarkers()) return;\n            var previous = this.getPrevious();\n            if (previous) this.addMiddleMarker(previous);\n            var next = this.getNext();\n            if (next) next.resetMiddleMarker();\n        },\n\n        resetMiddleMarker: function resetMiddleMarker() {\n            if (this.middleMarker) this.middleMarker.delete();\n            this.addMiddleMarker();\n        },\n\n        // 🍂method split()\n        // Split the vertex LatLngs group at its index, if possible.\n        split: function split() {\n            if (!this.editor.splitShape) return; // Only for PolylineEditor\n            this.editor.splitShape(this.latlngs, this.getIndex());\n        },\n\n        // 🍂method continue()\n        // Continue the vertex LatLngs from this vertex. Only active for first and last vertices of a Polyline.\n        continue: function _continue() {\n            if (!this.editor.continueBackward) return; // Only for PolylineEditor\n            var index = this.getIndex();\n            if (index === 0) this.editor.continueBackward(this.latlngs);else if (index === this.getLastIndex()) this.editor.continueForward(this.latlngs);\n        }\n\n    });\n\n    L.Editable.mergeOptions({\n\n        // 🍂namespace Editable\n        // 🍂option vertexMarkerClass: class = VertexMarker\n        // Class to be used as vertex, for path editing.\n        vertexMarkerClass: L.Editable.VertexMarker\n\n    });\n\n    L.Editable.MiddleMarker = L.Marker.extend({\n\n        options: {\n            opacity: 0.5,\n            className: 'leaflet-div-icon leaflet-middle-icon',\n            draggable: true\n        },\n\n        initialize: function initialize(left, right, latlngs, editor, options) {\n            this.left = left;\n            this.right = right;\n            this.editor = editor;\n            this.latlngs = latlngs;\n            L.Marker.prototype.initialize.call(this, this.computeLatLng(), options);\n            this._opacity = this.options.opacity;\n            this.options.icon = this.editor.tools.createVertexIcon({ className: this.options.className });\n            this.editor.editLayer.addLayer(this);\n            this.setVisibility();\n        },\n\n        setVisibility: function setVisibility() {\n            var leftPoint = this._map.latLngToContainerPoint(this.left.latlng),\n                rightPoint = this._map.latLngToContainerPoint(this.right.latlng),\n                size = L.point(this.options.icon.options.iconSize);\n            if (leftPoint.distanceTo(rightPoint) < size.x * 3) this.hide();else this.show();\n        },\n\n        show: function show() {\n            this.setOpacity(this._opacity);\n        },\n\n        hide: function hide() {\n            this.setOpacity(0);\n        },\n\n        updateLatLng: function updateLatLng() {\n            this.setLatLng(this.computeLatLng());\n            this.setVisibility();\n        },\n\n        computeLatLng: function computeLatLng() {\n            var leftPoint = this.editor.map.latLngToContainerPoint(this.left.latlng),\n                rightPoint = this.editor.map.latLngToContainerPoint(this.right.latlng),\n                y = (leftPoint.y + rightPoint.y) / 2,\n                x = (leftPoint.x + rightPoint.x) / 2;\n            return this.editor.map.containerPointToLatLng([x, y]);\n        },\n\n        onAdd: function onAdd(map) {\n            L.Marker.prototype.onAdd.call(this, map);\n            L.DomEvent.on(this._icon, 'mousedown touchstart', this.onMouseDown, this);\n            map.on('zoomend', this.setVisibility, this);\n        },\n\n        onRemove: function onRemove(map) {\n            delete this.right.middleMarker;\n            L.DomEvent.off(this._icon, 'mousedown touchstart', this.onMouseDown, this);\n            map.off('zoomend', this.setVisibility, this);\n            L.Marker.prototype.onRemove.call(this, map);\n        },\n\n        onMouseDown: function onMouseDown(e) {\n            var iconPos = L.DomUtil.getPosition(this._icon),\n                latlng = this.editor.map.layerPointToLatLng(iconPos);\n            e = {\n                originalEvent: e,\n                latlng: latlng\n            };\n            if (this.options.opacity === 0) return;\n            L.Editable.makeCancellable(e);\n            this.editor.onMiddleMarkerMouseDown(e);\n            if (e._cancelled) return;\n            this.latlngs.splice(this.index(), 0, e.latlng);\n            this.editor.refresh();\n            var icon = this._icon;\n            var marker = this.editor.addVertexMarker(e.latlng, this.latlngs);\n            this.editor.onNewVertex(marker);\n            /* Hack to workaround browser not firing touchend when element is no more on DOM */\n            var parent = marker._icon.parentNode;\n            parent.removeChild(marker._icon);\n            marker._icon = icon;\n            parent.appendChild(marker._icon);\n            marker._initIcon();\n            marker._initInteraction();\n            marker.setOpacity(1);\n            /* End hack */\n            // Transfer ongoing dragging to real marker\n            L.Draggable._dragging = false;\n            marker.dragging._draggable._onDown(e.originalEvent);\n            this.delete();\n        },\n\n        delete: function _delete() {\n            this.editor.editLayer.removeLayer(this);\n        },\n\n        index: function index() {\n            return this.latlngs.indexOf(this.right.latlng);\n        }\n\n    });\n\n    L.Editable.mergeOptions({\n\n        // 🍂namespace Editable\n        // 🍂option middleMarkerClass: class = VertexMarker\n        // Class to be used as middle vertex, pulled by the user to create a new point in the middle of a path.\n        middleMarkerClass: L.Editable.MiddleMarker\n\n    });\n\n    // 🍂namespace Editable; 🍂class BaseEditor; 🍂aka L.Editable.BaseEditor\n    // When editing a feature (Marker, Polyline…), an editor is attached to it. This\n    // editor basically knows how to handle the edition.\n    L.Editable.BaseEditor = L.Handler.extend({\n\n        initialize: function initialize(map, feature, options) {\n            L.setOptions(this, options);\n            this.map = map;\n            this.feature = feature;\n            this.feature.editor = this;\n            this.editLayer = new L.LayerGroup();\n            this.tools = this.options.editTools || map.editTools;\n        },\n\n        // 🍂method enable(): this\n        // Set up the drawing tools for the feature to be editable.\n        addHooks: function addHooks() {\n            if (this.isConnected()) this.onFeatureAdd();else this.feature.once('add', this.onFeatureAdd, this);\n            this.onEnable();\n            this.feature.on(this._getEvents(), this);\n        },\n\n        // 🍂method disable(): this\n        // Remove the drawing tools for the feature.\n        removeHooks: function removeHooks() {\n            this.feature.off(this._getEvents(), this);\n            if (this.feature.dragging) this.feature.dragging.disable();\n            this.editLayer.clearLayers();\n            this.tools.editLayer.removeLayer(this.editLayer);\n            this.onDisable();\n            if (this._drawing) this.cancelDrawing();\n        },\n\n        // 🍂method drawing(): boolean\n        // Return true if any drawing action is ongoing with this editor.\n        drawing: function drawing() {\n            return !!this._drawing;\n        },\n\n        reset: function reset() {},\n\n        onFeatureAdd: function onFeatureAdd() {\n            this.tools.editLayer.addLayer(this.editLayer);\n            if (this.feature.dragging) this.feature.dragging.enable();\n        },\n\n        hasMiddleMarkers: function hasMiddleMarkers() {\n            return !this.options.skipMiddleMarkers && !this.tools.options.skipMiddleMarkers;\n        },\n\n        fireAndForward: function fireAndForward(type, e) {\n            e = e || {};\n            e.layer = this.feature;\n            this.feature.fire(type, e);\n            this.tools.fireAndForward(type, e);\n        },\n\n        onEnable: function onEnable() {\n            // 🍂namespace Editable\n            // 🍂event editable:enable: Event\n            // Fired when an existing feature is ready to be edited.\n            this.fireAndForward('editable:enable');\n        },\n\n        onDisable: function onDisable() {\n            // 🍂namespace Editable\n            // 🍂event editable:disable: Event\n            // Fired when an existing feature is not ready anymore to be edited.\n            this.fireAndForward('editable:disable');\n        },\n\n        onEditing: function onEditing() {\n            // 🍂namespace Editable\n            // 🍂event editable:editing: Event\n            // Fired as soon as any change is made to the feature geometry.\n            this.fireAndForward('editable:editing');\n        },\n\n        onStartDrawing: function onStartDrawing() {\n            // 🍂namespace Editable\n            // 🍂section Drawing events\n            // 🍂event editable:drawing:start: Event\n            // Fired when a feature is to be drawn.\n            this.fireAndForward('editable:drawing:start');\n        },\n\n        onEndDrawing: function onEndDrawing() {\n            // 🍂namespace Editable\n            // 🍂section Drawing events\n            // 🍂event editable:drawing:end: Event\n            // Fired when a feature is not drawn anymore.\n            this.fireAndForward('editable:drawing:end');\n        },\n\n        onCancelDrawing: function onCancelDrawing() {\n            // 🍂namespace Editable\n            // 🍂section Drawing events\n            // 🍂event editable:drawing:cancel: Event\n            // Fired when user cancel drawing while a feature is being drawn.\n            this.fireAndForward('editable:drawing:cancel');\n        },\n\n        onCommitDrawing: function onCommitDrawing(e) {\n            // 🍂namespace Editable\n            // 🍂section Drawing events\n            // 🍂event editable:drawing:commit: Event\n            // Fired when user finish drawing a feature.\n            this.fireAndForward('editable:drawing:commit', e);\n        },\n\n        onDrawingMouseDown: function onDrawingMouseDown(e) {\n            // 🍂namespace Editable\n            // 🍂section Drawing events\n            // 🍂event editable:drawing:mousedown: Event\n            // Fired when user `mousedown` while drawing.\n            this.fireAndForward('editable:drawing:mousedown', e);\n        },\n\n        onDrawingMouseUp: function onDrawingMouseUp(e) {\n            // 🍂namespace Editable\n            // 🍂section Drawing events\n            // 🍂event editable:drawing:mouseup: Event\n            // Fired when user `mouseup` while drawing.\n            this.fireAndForward('editable:drawing:mouseup', e);\n        },\n\n        startDrawing: function startDrawing() {\n            if (!this._drawing) this._drawing = L.Editable.FORWARD;\n            this.tools.registerForDrawing(this);\n            this.onStartDrawing();\n        },\n\n        commitDrawing: function commitDrawing(e) {\n            this.onCommitDrawing(e);\n            this.endDrawing();\n        },\n\n        cancelDrawing: function cancelDrawing() {\n            // If called during a vertex drag, the vertex will be removed before\n            // the mouseup fires on it. This is a workaround. Maybe better fix is\n            // To have L.Draggable reset it's status on disable (Leaflet side).\n            L.Draggable._dragging = false;\n            this.onCancelDrawing();\n            this.endDrawing();\n        },\n\n        endDrawing: function endDrawing() {\n            this._drawing = false;\n            this.tools.unregisterForDrawing(this);\n            this.onEndDrawing();\n        },\n\n        onDrawingClick: function onDrawingClick(e) {\n            if (!this.drawing()) return;\n            L.Editable.makeCancellable(e);\n            // 🍂namespace Editable\n            // 🍂section Drawing events\n            // 🍂event editable:drawing:click: CancelableEvent\n            // Fired when user `click` while drawing, before any internal action is being processed.\n            this.fireAndForward('editable:drawing:click', e);\n            if (e._cancelled) return;\n            if (!this.isConnected()) this.connect(e);\n            this.processDrawingClick(e);\n        },\n\n        isConnected: function isConnected() {\n            return this.map.hasLayer(this.feature);\n        },\n\n        connect: function connect() {\n            this.tools.connectCreatedToMap(this.feature);\n            this.tools.editLayer.addLayer(this.editLayer);\n        },\n\n        onMove: function onMove(e) {\n            // 🍂namespace Editable\n            // 🍂section Drawing events\n            // 🍂event editable:drawing:move: Event\n            // Fired when `move` mouse while drawing, while dragging a marker, and while dragging a vertex.\n            this.fireAndForward('editable:drawing:move', e);\n        },\n\n        onDrawingMouseMove: function onDrawingMouseMove(e) {\n            this.onMove(e);\n        },\n\n        _getEvents: function _getEvents() {\n            return {\n                dragstart: this.onDragStart,\n                drag: this.onDrag,\n                dragend: this.onDragEnd,\n                remove: this.disable\n            };\n        },\n\n        onDragStart: function onDragStart(e) {\n            this.onEditing();\n            // 🍂namespace Editable\n            // 🍂event editable:dragstart: Event\n            // Fired before a path feature is dragged.\n            this.fireAndForward('editable:dragstart', e);\n        },\n\n        onDrag: function onDrag(e) {\n            this.onMove(e);\n            // 🍂namespace Editable\n            // 🍂event editable:drag: Event\n            // Fired when a path feature is being dragged.\n            this.fireAndForward('editable:drag', e);\n        },\n\n        onDragEnd: function onDragEnd(e) {\n            // 🍂namespace Editable\n            // 🍂event editable:dragend: Event\n            // Fired after a path feature has been dragged.\n            this.fireAndForward('editable:dragend', e);\n        }\n\n    });\n\n    // 🍂namespace Editable; 🍂class MarkerEditor; 🍂aka L.Editable.MarkerEditor\n    // 🍂inherits BaseEditor\n    // Editor for Marker.\n    L.Editable.MarkerEditor = L.Editable.BaseEditor.extend({\n\n        onDrawingMouseMove: function onDrawingMouseMove(e) {\n            L.Editable.BaseEditor.prototype.onDrawingMouseMove.call(this, e);\n            if (this._drawing) this.feature.setLatLng(e.latlng);\n        },\n\n        processDrawingClick: function processDrawingClick(e) {\n            // 🍂namespace Editable\n            // 🍂section Drawing events\n            // 🍂event editable:drawing:clicked: Event\n            // Fired when user `click` while drawing, after all internal actions.\n            this.fireAndForward('editable:drawing:clicked', e);\n            this.commitDrawing(e);\n        },\n\n        connect: function connect(e) {\n            // On touch, the latlng has not been updated because there is\n            // no mousemove.\n            if (e) this.feature._latlng = e.latlng;\n            L.Editable.BaseEditor.prototype.connect.call(this, e);\n        }\n\n    });\n\n    // 🍂namespace Editable; 🍂class PathEditor; 🍂aka L.Editable.PathEditor\n    // 🍂inherits BaseEditor\n    // Base class for all path editors.\n    L.Editable.PathEditor = L.Editable.BaseEditor.extend({\n\n        CLOSED: false,\n        MIN_VERTEX: 2,\n\n        addHooks: function addHooks() {\n            L.Editable.BaseEditor.prototype.addHooks.call(this);\n            if (this.feature) this.initVertexMarkers();\n            return this;\n        },\n\n        initVertexMarkers: function initVertexMarkers(latlngs) {\n            if (!this.enabled()) return;\n            latlngs = latlngs || this.getLatLngs();\n            if (isFlat(latlngs)) this.addVertexMarkers(latlngs);else for (var i = 0; i < latlngs.length; i++) {\n                this.initVertexMarkers(latlngs[i]);\n            }\n        },\n\n        getLatLngs: function getLatLngs() {\n            return this.feature.getLatLngs();\n        },\n\n        // 🍂method reset()\n        // Rebuild edit elements (Vertex, MiddleMarker, etc.).\n        reset: function reset() {\n            this.editLayer.clearLayers();\n            this.initVertexMarkers();\n        },\n\n        addVertexMarker: function addVertexMarker(latlng, latlngs) {\n            return new this.tools.options.vertexMarkerClass(latlng, latlngs, this);\n        },\n\n        onNewVertex: function onNewVertex(vertex) {\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:new: VertexEvent\n            // Fired when a new vertex is created.\n            this.fireAndForward('editable:vertex:new', { latlng: vertex.latlng, vertex: vertex });\n        },\n\n        addVertexMarkers: function addVertexMarkers(latlngs) {\n            for (var i = 0; i < latlngs.length; i++) {\n                this.addVertexMarker(latlngs[i], latlngs);\n            }\n        },\n\n        refreshVertexMarkers: function refreshVertexMarkers(latlngs) {\n            latlngs = latlngs || this.getDefaultLatLngs();\n            for (var i = 0; i < latlngs.length; i++) {\n                latlngs[i].__vertex.update();\n            }\n        },\n\n        addMiddleMarker: function addMiddleMarker(left, right, latlngs) {\n            return new this.tools.options.middleMarkerClass(left, right, latlngs, this);\n        },\n\n        onVertexMarkerClick: function onVertexMarkerClick(e) {\n            L.Editable.makeCancellable(e);\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:click: CancelableVertexEvent\n            // Fired when a `click` is issued on a vertex, before any internal action is being processed.\n            this.fireAndForward('editable:vertex:click', e);\n            if (e._cancelled) return;\n            if (this.tools.drawing() && this.tools._drawingEditor !== this) return;\n            var index = e.vertex.getIndex(),\n                commit;\n            if (e.originalEvent.ctrlKey) {\n                this.onVertexMarkerCtrlClick(e);\n            } else if (e.originalEvent.altKey) {\n                this.onVertexMarkerAltClick(e);\n            } else if (e.originalEvent.shiftKey) {\n                this.onVertexMarkerShiftClick(e);\n            } else if (e.originalEvent.metaKey) {\n                this.onVertexMarkerMetaKeyClick(e);\n            } else if (index === e.vertex.getLastIndex() && this._drawing === L.Editable.FORWARD) {\n                if (index >= this.MIN_VERTEX - 1) commit = true;\n            } else if (index === 0 && this._drawing === L.Editable.BACKWARD && this._drawnLatLngs.length >= this.MIN_VERTEX) {\n                commit = true;\n            } else if (index === 0 && this._drawing === L.Editable.FORWARD && this._drawnLatLngs.length >= this.MIN_VERTEX && this.CLOSED) {\n                commit = true; // Allow to close on first point also for polygons\n            } else {\n                this.onVertexRawMarkerClick(e);\n            }\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:clicked: VertexEvent\n            // Fired when a `click` is issued on a vertex, after all internal actions.\n            this.fireAndForward('editable:vertex:clicked', e);\n            if (commit) this.commitDrawing(e);\n        },\n\n        onVertexRawMarkerClick: function onVertexRawMarkerClick(e) {\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:rawclick: CancelableVertexEvent\n            // Fired when a `click` is issued on a vertex without any special key and without being in drawing mode.\n            this.fireAndForward('editable:vertex:rawclick', e);\n            if (e._cancelled) return;\n            if (!this.vertexCanBeDeleted(e.vertex)) return;\n            e.vertex.delete();\n        },\n\n        vertexCanBeDeleted: function vertexCanBeDeleted(vertex) {\n            return vertex.latlngs.length > this.MIN_VERTEX;\n        },\n\n        onVertexDeleted: function onVertexDeleted(e) {\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:deleted: VertexEvent\n            // Fired after a vertex has been deleted by user.\n            this.fireAndForward('editable:vertex:deleted', e);\n        },\n\n        onVertexMarkerCtrlClick: function onVertexMarkerCtrlClick(e) {\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:ctrlclick: VertexEvent\n            // Fired when a `click` with `ctrlKey` is issued on a vertex.\n            this.fireAndForward('editable:vertex:ctrlclick', e);\n        },\n\n        onVertexMarkerShiftClick: function onVertexMarkerShiftClick(e) {\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:shiftclick: VertexEvent\n            // Fired when a `click` with `shiftKey` is issued on a vertex.\n            this.fireAndForward('editable:vertex:shiftclick', e);\n        },\n\n        onVertexMarkerMetaKeyClick: function onVertexMarkerMetaKeyClick(e) {\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:metakeyclick: VertexEvent\n            // Fired when a `click` with `metaKey` is issued on a vertex.\n            this.fireAndForward('editable:vertex:metakeyclick', e);\n        },\n\n        onVertexMarkerAltClick: function onVertexMarkerAltClick(e) {\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:altclick: VertexEvent\n            // Fired when a `click` with `altKey` is issued on a vertex.\n            this.fireAndForward('editable:vertex:altclick', e);\n        },\n\n        onVertexMarkerContextMenu: function onVertexMarkerContextMenu(e) {\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:contextmenu: VertexEvent\n            // Fired when a `contextmenu` is issued on a vertex.\n            this.fireAndForward('editable:vertex:contextmenu', e);\n        },\n\n        onVertexMarkerMouseDown: function onVertexMarkerMouseDown(e) {\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:mousedown: VertexEvent\n            // Fired when user `mousedown` a vertex.\n            this.fireAndForward('editable:vertex:mousedown', e);\n        },\n\n        onVertexMarkerMouseOver: function onVertexMarkerMouseOver(e) {\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:mouseover: VertexEvent\n            // Fired when a user's mouse enters the vertex\n            this.fireAndForward('editable:vertex:mouseover', e);\n        },\n\n        onVertexMarkerMouseOut: function onVertexMarkerMouseOut(e) {\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:mouseout: VertexEvent\n            // Fired when a user's mouse leaves the vertex\n            this.fireAndForward('editable:vertex:mouseout', e);\n        },\n\n        onMiddleMarkerMouseDown: function onMiddleMarkerMouseDown(e) {\n            // 🍂namespace Editable\n            // 🍂section MiddleMarker events\n            // 🍂event editable:middlemarker:mousedown: VertexEvent\n            // Fired when user `mousedown` a middle marker.\n            this.fireAndForward('editable:middlemarker:mousedown', e);\n        },\n\n        onVertexMarkerDrag: function onVertexMarkerDrag(e) {\n            this.onMove(e);\n            if (this.feature._bounds) this.extendBounds(e);\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:drag: VertexEvent\n            // Fired when a vertex is dragged by user.\n            this.fireAndForward('editable:vertex:drag', e);\n        },\n\n        onVertexMarkerDragStart: function onVertexMarkerDragStart(e) {\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:dragstart: VertexEvent\n            // Fired before a vertex is dragged by user.\n            this.fireAndForward('editable:vertex:dragstart', e);\n        },\n\n        onVertexMarkerDragEnd: function onVertexMarkerDragEnd(e) {\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:dragend: VertexEvent\n            // Fired after a vertex is dragged by user.\n            this.fireAndForward('editable:vertex:dragend', e);\n        },\n\n        setDrawnLatLngs: function setDrawnLatLngs(latlngs) {\n            this._drawnLatLngs = latlngs || this.getDefaultLatLngs();\n        },\n\n        startDrawing: function startDrawing() {\n            if (!this._drawnLatLngs) this.setDrawnLatLngs();\n            L.Editable.BaseEditor.prototype.startDrawing.call(this);\n        },\n\n        startDrawingForward: function startDrawingForward() {\n            this.startDrawing();\n        },\n\n        endDrawing: function endDrawing() {\n            this.tools.detachForwardLineGuide();\n            this.tools.detachBackwardLineGuide();\n            if (this._drawnLatLngs && this._drawnLatLngs.length < this.MIN_VERTEX) this.deleteShape(this._drawnLatLngs);\n            L.Editable.BaseEditor.prototype.endDrawing.call(this);\n            delete this._drawnLatLngs;\n        },\n\n        addLatLng: function addLatLng(latlng) {\n            if (this._drawing === L.Editable.FORWARD) this._drawnLatLngs.push(latlng);else this._drawnLatLngs.unshift(latlng);\n            this.feature._bounds.extend(latlng);\n            var vertex = this.addVertexMarker(latlng, this._drawnLatLngs);\n            this.onNewVertex(vertex);\n            this.refresh();\n        },\n\n        newPointForward: function newPointForward(latlng) {\n            this.addLatLng(latlng);\n            this.tools.attachForwardLineGuide();\n            this.tools.anchorForwardLineGuide(latlng);\n        },\n\n        newPointBackward: function newPointBackward(latlng) {\n            this.addLatLng(latlng);\n            this.tools.anchorBackwardLineGuide(latlng);\n        },\n\n        // 🍂namespace PathEditor\n        // 🍂method push()\n        // Programmatically add a point while drawing.\n        push: function push(latlng) {\n            if (!latlng) return console.error('L.Editable.PathEditor.push expect a valid latlng as parameter');\n            if (this._drawing === L.Editable.FORWARD) this.newPointForward(latlng);else this.newPointBackward(latlng);\n        },\n\n        removeLatLng: function removeLatLng(latlng) {\n            latlng.__vertex.delete();\n            this.refresh();\n        },\n\n        // 🍂method pop(): L.LatLng or null\n        // Programmatically remove last point (if any) while drawing.\n        pop: function pop() {\n            if (this._drawnLatLngs.length <= 1) return;\n            var latlng;\n            if (this._drawing === L.Editable.FORWARD) latlng = this._drawnLatLngs[this._drawnLatLngs.length - 1];else latlng = this._drawnLatLngs[0];\n            this.removeLatLng(latlng);\n            if (this._drawing === L.Editable.FORWARD) this.tools.anchorForwardLineGuide(this._drawnLatLngs[this._drawnLatLngs.length - 1]);else this.tools.anchorForwardLineGuide(this._drawnLatLngs[0]);\n            return latlng;\n        },\n\n        processDrawingClick: function processDrawingClick(e) {\n            if (e.vertex && e.vertex.editor === this) return;\n            if (this._drawing === L.Editable.FORWARD) this.newPointForward(e.latlng);else this.newPointBackward(e.latlng);\n            this.fireAndForward('editable:drawing:clicked', e);\n        },\n\n        onDrawingMouseMove: function onDrawingMouseMove(e) {\n            L.Editable.BaseEditor.prototype.onDrawingMouseMove.call(this, e);\n            if (this._drawing) {\n                this.tools.moveForwardLineGuide(e.latlng);\n                this.tools.moveBackwardLineGuide(e.latlng);\n            }\n        },\n\n        refresh: function refresh() {\n            this.feature.redraw();\n            this.onEditing();\n        },\n\n        // 🍂namespace PathEditor\n        // 🍂method newShape(latlng?: L.LatLng)\n        // Add a new shape (Polyline, Polygon) in a multi, and setup up drawing tools to draw it;\n        // if optional `latlng` is given, start a path at this point.\n        newShape: function newShape(latlng) {\n            var shape = this.addNewEmptyShape();\n            if (!shape) return;\n            this.setDrawnLatLngs(shape[0] || shape); // Polygon or polyline\n            this.startDrawingForward();\n            // 🍂namespace Editable\n            // 🍂section Shape events\n            // 🍂event editable:shape:new: ShapeEvent\n            // Fired when a new shape is created in a multi (Polygon or Polyline).\n            this.fireAndForward('editable:shape:new', { shape: shape });\n            if (latlng) this.newPointForward(latlng);\n        },\n\n        deleteShape: function deleteShape(shape, latlngs) {\n            var e = { shape: shape };\n            L.Editable.makeCancellable(e);\n            // 🍂namespace Editable\n            // 🍂section Shape events\n            // 🍂event editable:shape:delete: CancelableShapeEvent\n            // Fired before a new shape is deleted in a multi (Polygon or Polyline).\n            this.fireAndForward('editable:shape:delete', e);\n            if (e._cancelled) return;\n            shape = this._deleteShape(shape, latlngs);\n            if (this.ensureNotFlat) this.ensureNotFlat(); // Polygon.\n            this.feature.setLatLngs(this.getLatLngs()); // Force bounds reset.\n            this.refresh();\n            this.reset();\n            // 🍂namespace Editable\n            // 🍂section Shape events\n            // 🍂event editable:shape:deleted: ShapeEvent\n            // Fired after a new shape is deleted in a multi (Polygon or Polyline).\n            this.fireAndForward('editable:shape:deleted', { shape: shape });\n            return shape;\n        },\n\n        _deleteShape: function _deleteShape(shape, latlngs) {\n            latlngs = latlngs || this.getLatLngs();\n            if (!latlngs.length) return;\n            var self = this,\n                inplaceDelete = function inplaceDelete(latlngs, shape) {\n                // Called when deleting a flat latlngs\n                shape = latlngs.splice(0, Number.MAX_VALUE);\n                return shape;\n            },\n                spliceDelete = function spliceDelete(latlngs, shape) {\n                // Called when removing a latlngs inside an array\n                latlngs.splice(latlngs.indexOf(shape), 1);\n                if (!latlngs.length) self._deleteShape(latlngs);\n                return shape;\n            };\n            if (latlngs === shape) return inplaceDelete(latlngs, shape);\n            for (var i = 0; i < latlngs.length; i++) {\n                if (latlngs[i] === shape) return spliceDelete(latlngs, shape);else if (latlngs[i].indexOf(shape) !== -1) return spliceDelete(latlngs[i], shape);\n            }\n        },\n\n        // 🍂namespace PathEditor\n        // 🍂method deleteShapeAt(latlng: L.LatLng): Array\n        // Remove a path shape at the given `latlng`.\n        deleteShapeAt: function deleteShapeAt(latlng) {\n            var shape = this.feature.shapeAt(latlng);\n            if (shape) return this.deleteShape(shape);\n        },\n\n        // 🍂method appendShape(shape: Array)\n        // Append a new shape to the Polygon or Polyline.\n        appendShape: function appendShape(shape) {\n            this.insertShape(shape);\n        },\n\n        // 🍂method prependShape(shape: Array)\n        // Prepend a new shape to the Polygon or Polyline.\n        prependShape: function prependShape(shape) {\n            this.insertShape(shape, 0);\n        },\n\n        // 🍂method insertShape(shape: Array, index: int)\n        // Insert a new shape to the Polygon or Polyline at given index (default is to append).\n        insertShape: function insertShape(shape, index) {\n            this.ensureMulti();\n            shape = this.formatShape(shape);\n            if (typeof index === 'undefined') index = this.feature._latlngs.length;\n            this.feature._latlngs.splice(index, 0, shape);\n            this.feature.redraw();\n            if (this._enabled) this.reset();\n        },\n\n        extendBounds: function extendBounds(e) {\n            this.feature._bounds.extend(e.vertex.latlng);\n        },\n\n        onDragStart: function onDragStart(e) {\n            this.editLayer.clearLayers();\n            L.Editable.BaseEditor.prototype.onDragStart.call(this, e);\n        },\n\n        onDragEnd: function onDragEnd(e) {\n            this.initVertexMarkers();\n            L.Editable.BaseEditor.prototype.onDragEnd.call(this, e);\n        }\n\n    });\n\n    // 🍂namespace Editable; 🍂class PolylineEditor; 🍂aka L.Editable.PolylineEditor\n    // 🍂inherits PathEditor\n    L.Editable.PolylineEditor = L.Editable.PathEditor.extend({\n\n        startDrawingBackward: function startDrawingBackward() {\n            this._drawing = L.Editable.BACKWARD;\n            this.startDrawing();\n        },\n\n        // 🍂method continueBackward(latlngs?: Array)\n        // Set up drawing tools to continue the line backward.\n        continueBackward: function continueBackward(latlngs) {\n            if (this.drawing()) return;\n            latlngs = latlngs || this.getDefaultLatLngs();\n            this.setDrawnLatLngs(latlngs);\n            if (latlngs.length > 0) {\n                this.tools.attachBackwardLineGuide();\n                this.tools.anchorBackwardLineGuide(latlngs[0]);\n            }\n            this.startDrawingBackward();\n        },\n\n        // 🍂method continueForward(latlngs?: Array)\n        // Set up drawing tools to continue the line forward.\n        continueForward: function continueForward(latlngs) {\n            if (this.drawing()) return;\n            latlngs = latlngs || this.getDefaultLatLngs();\n            this.setDrawnLatLngs(latlngs);\n            if (latlngs.length > 0) {\n                this.tools.attachForwardLineGuide();\n                this.tools.anchorForwardLineGuide(latlngs[latlngs.length - 1]);\n            }\n            this.startDrawingForward();\n        },\n\n        getDefaultLatLngs: function getDefaultLatLngs(latlngs) {\n            latlngs = latlngs || this.feature._latlngs;\n            if (!latlngs.length || latlngs[0] instanceof L.LatLng) return latlngs;else return this.getDefaultLatLngs(latlngs[0]);\n        },\n\n        ensureMulti: function ensureMulti() {\n            if (this.feature._latlngs.length && isFlat(this.feature._latlngs)) {\n                this.feature._latlngs = [this.feature._latlngs];\n            }\n        },\n\n        addNewEmptyShape: function addNewEmptyShape() {\n            if (this.feature._latlngs.length) {\n                var shape = [];\n                this.appendShape(shape);\n                return shape;\n            } else {\n                return this.feature._latlngs;\n            }\n        },\n\n        formatShape: function formatShape(shape) {\n            if (isFlat(shape)) return shape;else if (shape[0]) return this.formatShape(shape[0]);\n        },\n\n        // 🍂method splitShape(latlngs?: Array, index: int)\n        // Split the given `latlngs` shape at index `index` and integrate new shape in instance `latlngs`.\n        splitShape: function splitShape(shape, index) {\n            if (!index || index >= shape.length - 1) return;\n            this.ensureMulti();\n            var shapeIndex = this.feature._latlngs.indexOf(shape);\n            if (shapeIndex === -1) return;\n            var first = shape.slice(0, index + 1),\n                second = shape.slice(index);\n            // We deal with reference, we don't want twice the same latlng around.\n            second[0] = L.latLng(second[0].lat, second[0].lng, second[0].alt);\n            this.feature._latlngs.splice(shapeIndex, 1, first, second);\n            this.refresh();\n            this.reset();\n        }\n\n    });\n\n    // 🍂namespace Editable; 🍂class PolygonEditor; 🍂aka L.Editable.PolygonEditor\n    // 🍂inherits PathEditor\n    L.Editable.PolygonEditor = L.Editable.PathEditor.extend({\n\n        CLOSED: true,\n        MIN_VERTEX: 3,\n\n        newPointForward: function newPointForward(latlng) {\n            L.Editable.PathEditor.prototype.newPointForward.call(this, latlng);\n            if (!this.tools.backwardLineGuide._latlngs.length) this.tools.anchorBackwardLineGuide(latlng);\n            if (this._drawnLatLngs.length === 2) this.tools.attachBackwardLineGuide();\n        },\n\n        addNewEmptyHole: function addNewEmptyHole(latlng) {\n            this.ensureNotFlat();\n            var latlngs = this.feature.shapeAt(latlng);\n            if (!latlngs) return;\n            var holes = [];\n            latlngs.push(holes);\n            return holes;\n        },\n\n        // 🍂method newHole(latlng?: L.LatLng, index: int)\n        // Set up drawing tools for creating a new hole on the Polygon. If the `latlng` param is given, a first point is created.\n        newHole: function newHole(latlng) {\n            var holes = this.addNewEmptyHole(latlng);\n            if (!holes) return;\n            this.setDrawnLatLngs(holes);\n            this.startDrawingForward();\n            if (latlng) this.newPointForward(latlng);\n        },\n\n        addNewEmptyShape: function addNewEmptyShape() {\n            if (this.feature._latlngs.length && this.feature._latlngs[0].length) {\n                var shape = [];\n                this.appendShape(shape);\n                return shape;\n            } else {\n                return this.feature._latlngs;\n            }\n        },\n\n        ensureMulti: function ensureMulti() {\n            if (this.feature._latlngs.length && isFlat(this.feature._latlngs[0])) {\n                this.feature._latlngs = [this.feature._latlngs];\n            }\n        },\n\n        ensureNotFlat: function ensureNotFlat() {\n            if (!this.feature._latlngs.length || isFlat(this.feature._latlngs)) this.feature._latlngs = [this.feature._latlngs];\n        },\n\n        vertexCanBeDeleted: function vertexCanBeDeleted(vertex) {\n            var parent = this.feature.parentShape(vertex.latlngs),\n                idx = L.Util.indexOf(parent, vertex.latlngs);\n            if (idx > 0) return true; // Holes can be totally deleted without removing the layer itself.\n            return L.Editable.PathEditor.prototype.vertexCanBeDeleted.call(this, vertex);\n        },\n\n        getDefaultLatLngs: function getDefaultLatLngs() {\n            if (!this.feature._latlngs.length) this.feature._latlngs.push([]);\n            return this.feature._latlngs[0];\n        },\n\n        formatShape: function formatShape(shape) {\n            // [[1, 2], [3, 4]] => must be nested\n            // [] => must be nested\n            // [[]] => is already nested\n            if (isFlat(shape) && (!shape[0] || shape[0].length !== 0)) return [shape];else return shape;\n        }\n\n    });\n\n    // 🍂namespace Editable; 🍂class RectangleEditor; 🍂aka L.Editable.RectangleEditor\n    // 🍂inherits PathEditor\n    L.Editable.RectangleEditor = L.Editable.PathEditor.extend({\n\n        CLOSED: true,\n        MIN_VERTEX: 4,\n\n        options: {\n            skipMiddleMarkers: true\n        },\n\n        extendBounds: function extendBounds(e) {\n            var index = e.vertex.getIndex(),\n                next = e.vertex.getNext(),\n                previous = e.vertex.getPrevious(),\n                oppositeIndex = (index + 2) % 4,\n                opposite = e.vertex.latlngs[oppositeIndex],\n                bounds = new L.LatLngBounds(e.latlng, opposite);\n            // Update latlngs by hand to preserve order.\n            previous.latlng.update([e.latlng.lat, opposite.lng]);\n            next.latlng.update([opposite.lat, e.latlng.lng]);\n            this.updateBounds(bounds);\n            this.refreshVertexMarkers();\n        },\n\n        onDrawingMouseDown: function onDrawingMouseDown(e) {\n            L.Editable.PathEditor.prototype.onDrawingMouseDown.call(this, e);\n            this.connect();\n            var latlngs = this.getDefaultLatLngs();\n            // L.Polygon._convertLatLngs removes last latlng if it equals first point,\n            // which is the case here as all latlngs are [0, 0]\n            if (latlngs.length === 3) latlngs.push(e.latlng);\n            var bounds = new L.LatLngBounds(e.latlng, e.latlng);\n            this.updateBounds(bounds);\n            this.updateLatLngs(bounds);\n            this.refresh();\n            this.reset();\n            // Stop dragging map.\n            // L.Draggable has two workflows:\n            // - mousedown => mousemove => mouseup\n            // - touchstart => touchmove => touchend\n            // Problem: L.Map.Tap does not allow us to listen to touchstart, so we only\n            // can deal with mousedown, but then when in a touch device, we are dealing with\n            // simulated events (actually simulated by L.Map.Tap), which are no more taken\n            // into account by L.Draggable.\n            // Ref.: https://github.com/Leaflet/Leaflet.Editable/issues/103\n            e.originalEvent._simulated = false;\n            this.map.dragging._draggable._onUp(e.originalEvent);\n            // Now transfer ongoing drag action to the bottom right corner.\n            // Should we refine which corner will handle the drag according to\n            // drag direction?\n            latlngs[3].__vertex.dragging._draggable._onDown(e.originalEvent);\n        },\n\n        onDrawingMouseUp: function onDrawingMouseUp(e) {\n            this.commitDrawing(e);\n            e.originalEvent._simulated = false;\n            L.Editable.PathEditor.prototype.onDrawingMouseUp.call(this, e);\n        },\n\n        onDrawingMouseMove: function onDrawingMouseMove(e) {\n            e.originalEvent._simulated = false;\n            L.Editable.PathEditor.prototype.onDrawingMouseMove.call(this, e);\n        },\n\n        getDefaultLatLngs: function getDefaultLatLngs(latlngs) {\n            return latlngs || this.feature._latlngs[0];\n        },\n\n        updateBounds: function updateBounds(bounds) {\n            this.feature._bounds = bounds;\n        },\n\n        updateLatLngs: function updateLatLngs(bounds) {\n            var latlngs = this.getDefaultLatLngs(),\n                newLatlngs = this.feature._boundsToLatLngs(bounds);\n            // Keep references.\n            for (var i = 0; i < latlngs.length; i++) {\n                latlngs[i].update(newLatlngs[i]);\n            }\n        }\n\n    });\n\n    // 🍂namespace Editable; 🍂class CircleEditor; 🍂aka L.Editable.CircleEditor\n    // 🍂inherits PathEditor\n    L.Editable.CircleEditor = L.Editable.PathEditor.extend({\n\n        MIN_VERTEX: 2,\n\n        options: {\n            skipMiddleMarkers: true\n        },\n\n        initialize: function initialize(map, feature, options) {\n            L.Editable.PathEditor.prototype.initialize.call(this, map, feature, options);\n            this._resizeLatLng = this.computeResizeLatLng();\n        },\n\n        computeResizeLatLng: function computeResizeLatLng() {\n            // While circle is not added to the map, _radius is not set.\n            var delta = (this.feature._radius || this.feature._mRadius) * Math.cos(Math.PI / 4),\n                point = this.map.project(this.feature._latlng);\n            return this.map.unproject([point.x + delta, point.y - delta]);\n        },\n\n        updateResizeLatLng: function updateResizeLatLng() {\n            this._resizeLatLng.update(this.computeResizeLatLng());\n            this._resizeLatLng.__vertex.update();\n        },\n\n        getLatLngs: function getLatLngs() {\n            return [this.feature._latlng, this._resizeLatLng];\n        },\n\n        getDefaultLatLngs: function getDefaultLatLngs() {\n            return this.getLatLngs();\n        },\n\n        onVertexMarkerDrag: function onVertexMarkerDrag(e) {\n            if (e.vertex.getIndex() === 1) this.resize(e);else this.updateResizeLatLng(e);\n            L.Editable.PathEditor.prototype.onVertexMarkerDrag.call(this, e);\n        },\n\n        resize: function resize(e) {\n            var radius = this.feature._latlng.distanceTo(e.latlng);\n            this.feature.setRadius(radius);\n        },\n\n        onDrawingMouseDown: function onDrawingMouseDown(e) {\n            L.Editable.PathEditor.prototype.onDrawingMouseDown.call(this, e);\n            this._resizeLatLng.update(e.latlng);\n            this.feature._latlng.update(e.latlng);\n            this.connect();\n            // Stop dragging map.\n            e.originalEvent._simulated = false;\n            this.map.dragging._draggable._onUp(e.originalEvent);\n            // Now transfer ongoing drag action to the radius handler.\n            this._resizeLatLng.__vertex.dragging._draggable._onDown(e.originalEvent);\n        },\n\n        onDrawingMouseUp: function onDrawingMouseUp(e) {\n            this.commitDrawing(e);\n            e.originalEvent._simulated = false;\n            L.Editable.PathEditor.prototype.onDrawingMouseUp.call(this, e);\n        },\n\n        onDrawingMouseMove: function onDrawingMouseMove(e) {\n            e.originalEvent._simulated = false;\n            L.Editable.PathEditor.prototype.onDrawingMouseMove.call(this, e);\n        },\n\n        onDrag: function onDrag(e) {\n            L.Editable.PathEditor.prototype.onDrag.call(this, e);\n            this.feature.dragging.updateLatLng(this._resizeLatLng);\n        }\n\n    });\n\n    // 🍂namespace Editable; 🍂class EditableMixin\n    // `EditableMixin` is included to `L.Polyline`, `L.Polygon`, `L.Rectangle`, `L.Circle`\n    // and `L.Marker`. It adds some methods to them.\n    // *When editing is enabled, the editor is accessible on the instance with the\n    // `editor` property.*\n    var EditableMixin = {\n\n        createEditor: function createEditor(map) {\n            map = map || this._map;\n            var tools = (this.options.editOptions || {}).editTools || map.editTools;\n            if (!tools) throw Error('Unable to detect Editable instance.');\n            var Klass = this.options.editorClass || this.getEditorClass(tools);\n            return new Klass(map, this, this.options.editOptions);\n        },\n\n        // 🍂method enableEdit(map?: L.Map): this.editor\n        // Enable editing, by creating an editor if not existing, and then calling `enable` on it.\n        enableEdit: function enableEdit(map) {\n            if (!this.editor) this.createEditor(map);\n            this.editor.enable();\n            return this.editor;\n        },\n\n        // 🍂method editEnabled(): boolean\n        // Return true if current instance has an editor attached, and this editor is enabled.\n        editEnabled: function editEnabled() {\n            return this.editor && this.editor.enabled();\n        },\n\n        // 🍂method disableEdit()\n        // Disable editing, also remove the editor property reference.\n        disableEdit: function disableEdit() {\n            if (this.editor) {\n                this.editor.disable();\n                delete this.editor;\n            }\n        },\n\n        // 🍂method toggleEdit()\n        // Enable or disable editing, according to current status.\n        toggleEdit: function toggleEdit() {\n            if (this.editEnabled()) this.disableEdit();else this.enableEdit();\n        },\n\n        _onEditableAdd: function _onEditableAdd() {\n            if (this.editor) this.enableEdit();\n        }\n\n    };\n\n    var PolylineMixin = {\n\n        getEditorClass: function getEditorClass(tools) {\n            return tools && tools.options.polylineEditorClass ? tools.options.polylineEditorClass : L.Editable.PolylineEditor;\n        },\n\n        shapeAt: function shapeAt(latlng, latlngs) {\n            // We can have those cases:\n            // - latlngs are just a flat array of latlngs, use this\n            // - latlngs is an array of arrays of latlngs, loop over\n            var shape = null;\n            latlngs = latlngs || this._latlngs;\n            if (!latlngs.length) return shape;else if (isFlat(latlngs) && this.isInLatLngs(latlng, latlngs)) shape = latlngs;else for (var i = 0; i < latlngs.length; i++) {\n                if (this.isInLatLngs(latlng, latlngs[i])) return latlngs[i];\n            }return shape;\n        },\n\n        isInLatLngs: function isInLatLngs(l, latlngs) {\n            if (!latlngs) return false;\n            var i,\n                k,\n                len,\n                part = [],\n                p,\n                w = this._clickTolerance();\n            this._projectLatlngs(latlngs, part, this._pxBounds);\n            part = part[0];\n            p = this._map.latLngToLayerPoint(l);\n\n            if (!this._pxBounds.contains(p)) {\n                return false;\n            }\n            for (i = 1, len = part.length, k = 0; i < len; k = i++) {\n\n                if (L.LineUtil.pointToSegmentDistance(p, part[k], part[i]) <= w) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n    };\n\n    var PolygonMixin = {\n\n        getEditorClass: function getEditorClass(tools) {\n            return tools && tools.options.polygonEditorClass ? tools.options.polygonEditorClass : L.Editable.PolygonEditor;\n        },\n\n        shapeAt: function shapeAt(latlng, latlngs) {\n            // We can have those cases:\n            // - latlngs are just a flat array of latlngs, use this\n            // - latlngs is an array of arrays of latlngs, this is a simple polygon (maybe with holes), use the first\n            // - latlngs is an array of arrays of arrays, this is a multi, loop over\n            var shape = null;\n            latlngs = latlngs || this._latlngs;\n            if (!latlngs.length) return shape;else if (isFlat(latlngs) && this.isInLatLngs(latlng, latlngs)) shape = latlngs;else if (isFlat(latlngs[0]) && this.isInLatLngs(latlng, latlngs[0])) shape = latlngs;else for (var i = 0; i < latlngs.length; i++) {\n                if (this.isInLatLngs(latlng, latlngs[i][0])) return latlngs[i];\n            }return shape;\n        },\n\n        isInLatLngs: function isInLatLngs(l, latlngs) {\n            var inside = false,\n                l1,\n                l2,\n                j,\n                k,\n                len2;\n\n            for (j = 0, len2 = latlngs.length, k = len2 - 1; j < len2; k = j++) {\n                l1 = latlngs[j];\n                l2 = latlngs[k];\n\n                if (l1.lat > l.lat !== l2.lat > l.lat && l.lng < (l2.lng - l1.lng) * (l.lat - l1.lat) / (l2.lat - l1.lat) + l1.lng) {\n                    inside = !inside;\n                }\n            }\n\n            return inside;\n        },\n\n        parentShape: function parentShape(shape, latlngs) {\n            latlngs = latlngs || this._latlngs;\n            if (!latlngs) return;\n            var idx = L.Util.indexOf(latlngs, shape);\n            if (idx !== -1) return latlngs;\n            for (var i = 0; i < latlngs.length; i++) {\n                idx = L.Util.indexOf(latlngs[i], shape);\n                if (idx !== -1) return latlngs[i];\n            }\n        }\n\n    };\n\n    var MarkerMixin = {\n\n        getEditorClass: function getEditorClass(tools) {\n            return tools && tools.options.markerEditorClass ? tools.options.markerEditorClass : L.Editable.MarkerEditor;\n        }\n\n    };\n\n    var RectangleMixin = {\n\n        getEditorClass: function getEditorClass(tools) {\n            return tools && tools.options.rectangleEditorClass ? tools.options.rectangleEditorClass : L.Editable.RectangleEditor;\n        }\n\n    };\n\n    var CircleMixin = {\n\n        getEditorClass: function getEditorClass(tools) {\n            return tools && tools.options.circleEditorClass ? tools.options.circleEditorClass : L.Editable.CircleEditor;\n        }\n\n    };\n\n    var keepEditable = function keepEditable() {\n        // Make sure you can remove/readd an editable layer.\n        this.on('add', this._onEditableAdd);\n    };\n\n    var isFlat = L.LineUtil.isFlat || L.LineUtil._flat || L.Polyline._flat; // <=> 1.1 compat.\n\n\n    if (L.Polyline) {\n        L.Polyline.include(EditableMixin);\n        L.Polyline.include(PolylineMixin);\n        L.Polyline.addInitHook(keepEditable);\n    }\n    if (L.Polygon) {\n        L.Polygon.include(EditableMixin);\n        L.Polygon.include(PolygonMixin);\n    }\n    if (L.Marker) {\n        L.Marker.include(EditableMixin);\n        L.Marker.include(MarkerMixin);\n        L.Marker.addInitHook(keepEditable);\n    }\n    if (L.Rectangle) {\n        L.Rectangle.include(EditableMixin);\n        L.Rectangle.include(RectangleMixin);\n    }\n    if (L.Circle) {\n        L.Circle.include(EditableMixin);\n        L.Circle.include(CircleMixin);\n    }\n\n    L.LatLng.prototype.update = function (latlng) {\n        latlng = L.latLng(latlng);\n        this.lat = latlng.lat;\n        this.lng = latlng.lng;\n    };\n}\ninit(window.L);\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIlZ1ZTJMZWFmbGV0RWRpdGFibGVQbHVnaW4uanMiXSwibmFtZXMiOlsiaW5pdCIsIkwiLCJFZGl0YWJsZSIsIkV2ZW50ZWQiLCJleHRlbmQiLCJzdGF0aWNzIiwiRk9SV0FSRCIsIkJBQ0tXQVJEIiwib3B0aW9ucyIsInpJbmRleCIsInBvbHlnb25DbGFzcyIsIlBvbHlnb24iLCJwb2x5bGluZUNsYXNzIiwiUG9seWxpbmUiLCJtYXJrZXJDbGFzcyIsIk1hcmtlciIsInJlY3RhbmdsZUNsYXNzIiwiUmVjdGFuZ2xlIiwiY2lyY2xlQ2xhc3MiLCJDaXJjbGUiLCJkcmF3aW5nQ1NTQ2xhc3MiLCJkcmF3aW5nQ3Vyc29yIiwiZWRpdExheWVyIiwidW5kZWZpbmVkIiwiZmVhdHVyZXNMYXllciIsInBvbHlsaW5lRWRpdG9yQ2xhc3MiLCJwb2x5Z29uRWRpdG9yQ2xhc3MiLCJtYXJrZXJFZGl0b3JDbGFzcyIsInJlY3RhbmdsZUVkaXRvckNsYXNzIiwiY2lyY2xlRWRpdG9yQ2xhc3MiLCJsaW5lR3VpZGVPcHRpb25zIiwic2tpcE1pZGRsZU1hcmtlcnMiLCJpbml0aWFsaXplIiwibWFwIiwic2V0T3B0aW9ucyIsIl9sYXN0WkluZGV4IiwiY3JlYXRlRWRpdExheWVyIiwiY3JlYXRlRmVhdHVyZXNMYXllciIsImZvcndhcmRMaW5lR3VpZGUiLCJjcmVhdGVMaW5lR3VpZGUiLCJiYWNrd2FyZExpbmVHdWlkZSIsImZpcmVBbmRGb3J3YXJkIiwidHlwZSIsImUiLCJlZGl0VG9vbHMiLCJmaXJlIiwiZGFzaEFycmF5Iiwid2VpZ2h0IiwiaW50ZXJhY3RpdmUiLCJwb2x5bGluZSIsImNyZWF0ZVZlcnRleEljb24iLCJCcm93c2VyIiwibW9iaWxlIiwidG91Y2giLCJUb3VjaFZlcnRleEljb24iLCJWZXJ0ZXhJY29uIiwiTGF5ZXJHcm91cCIsImFkZFRvIiwibW92ZUZvcndhcmRMaW5lR3VpZGUiLCJsYXRsbmciLCJfbGF0bG5ncyIsImxlbmd0aCIsIl9ib3VuZHMiLCJyZWRyYXciLCJtb3ZlQmFja3dhcmRMaW5lR3VpZGUiLCJhbmNob3JGb3J3YXJkTGluZUd1aWRlIiwiYW5jaG9yQmFja3dhcmRMaW5lR3VpZGUiLCJhdHRhY2hGb3J3YXJkTGluZUd1aWRlIiwiYWRkTGF5ZXIiLCJhdHRhY2hCYWNrd2FyZExpbmVHdWlkZSIsImRldGFjaEZvcndhcmRMaW5lR3VpZGUiLCJzZXRMYXRMbmdzIiwicmVtb3ZlTGF5ZXIiLCJkZXRhY2hCYWNrd2FyZExpbmVHdWlkZSIsImJsb2NrRXZlbnRzIiwiX29sZFRhcmdldHMiLCJfdGFyZ2V0cyIsInVuYmxvY2tFdmVudHMiLCJyZWdpc3RlckZvckRyYXdpbmciLCJlZGl0b3IiLCJfZHJhd2luZ0VkaXRvciIsInVucmVnaXN0ZXJGb3JEcmF3aW5nIiwicmVzZXQiLCJvbiIsIm9uRHJhd2luZ01vdXNlTW92ZSIsIm9uTW91c2Vkb3duIiwib25Nb3VzZXVwIiwiRG9tVXRpbCIsImFkZENsYXNzIiwiX2NvbnRhaW5lciIsImRlZmF1bHRNYXBDdXJzb3IiLCJzdHlsZSIsImN1cnNvciIsInJlbW92ZUNsYXNzIiwib2ZmIiwiX2RyYXdpbmciLCJjYW5jZWxEcmF3aW5nIiwib3JpZ2luYWxFdmVudCIsIndoaWNoIiwiX21vdXNlRG93biIsIm9uRHJhd2luZ01vdXNlRG93biIsIm1vdXNlRG93biIsIm9uRHJhd2luZ01vdXNlVXAiLCJvcmlnaW4iLCJwb2ludCIsImNsaWVudFgiLCJjbGllbnRZIiwiZGlzdGFuY2UiLCJkaXN0YW5jZVRvIiwiTWF0aCIsImFicyIsIndpbmRvdyIsImRldmljZVBpeGVsUmF0aW8iLCJvbkRyYXdpbmdDbGljayIsImRyYXdpbmciLCJzdG9wRHJhd2luZyIsImNvbW1pdERyYXdpbmciLCJjb25uZWN0Q3JlYXRlZFRvTWFwIiwibGF5ZXIiLCJzdGFydFBvbHlsaW5lIiwibGluZSIsImNyZWF0ZVBvbHlsaW5lIiwiZW5hYmxlRWRpdCIsIm5ld1NoYXBlIiwic3RhcnRQb2x5Z29uIiwicG9seWdvbiIsImNyZWF0ZVBvbHlnb24iLCJzdGFydE1hcmtlciIsImdldENlbnRlciIsImNsb25lIiwibWFya2VyIiwiY3JlYXRlTWFya2VyIiwic3RhcnREcmF3aW5nIiwic3RhcnRSZWN0YW5nbGUiLCJjb3JuZXIiLCJsYXRMbmciLCJib3VuZHMiLCJMYXRMbmdCb3VuZHMiLCJyZWN0YW5nbGUiLCJjcmVhdGVSZWN0YW5nbGUiLCJzdGFydENpcmNsZSIsImNpcmNsZSIsImNyZWF0ZUNpcmNsZSIsInN0YXJ0SG9sZSIsIm5ld0hvbGUiLCJjcmVhdGVMYXllciIsImtsYXNzIiwibGF0bG5ncyIsIlV0aWwiLCJlZGl0T3B0aW9ucyIsIm1ha2VDYW5jZWxsYWJsZSIsImNhbmNlbCIsIl9jYW5jZWxsZWQiLCJNYXAiLCJtZXJnZU9wdGlvbnMiLCJlZGl0VG9vbHNDbGFzcyIsImVkaXRhYmxlIiwiYWRkSW5pdEhvb2siLCJ3aGVuUmVhZHkiLCJEaXZJY29uIiwiaWNvblNpemUiLCJQb2ludCIsIlZlcnRleE1hcmtlciIsImRyYWdnYWJsZSIsImNsYXNzTmFtZSIsInByb3RvdHlwZSIsImNhbGwiLCJpY29uIiwidG9vbHMiLCJfX3ZlcnRleCIsInNldFpJbmRleE9mZnNldCIsIm9uQWRkIiwib25EcmFnIiwib25EcmFnU3RhcnQiLCJvbkRyYWdFbmQiLCJvbkNsaWNrIiwib25Db250ZXh0TWVudSIsIm9uTW91c2VEb3duIiwib25Nb3VzZU92ZXIiLCJvbk1vdXNlT3V0IiwiYWRkTWlkZGxlTWFya2VycyIsIm9uUmVtb3ZlIiwibWlkZGxlTWFya2VyIiwiZGVsZXRlIiwidmVydGV4Iiwib25WZXJ0ZXhNYXJrZXJEcmFnIiwiaWNvblBvcyIsImdldFBvc2l0aW9uIiwiX2ljb24iLCJfbWFwIiwibGF5ZXJQb2ludFRvTGF0TG5nIiwidXBkYXRlIiwiX2xhdGxuZyIsInJlZnJlc2giLCJ1cGRhdGVMYXRMbmciLCJuZXh0IiwiZ2V0TmV4dCIsIm9uVmVydGV4TWFya2VyRHJhZ1N0YXJ0Iiwib25WZXJ0ZXhNYXJrZXJEcmFnRW5kIiwib25WZXJ0ZXhNYXJrZXJDbGljayIsIkRvbUV2ZW50Iiwic3RvcCIsIm9uVmVydGV4TWFya2VyQ29udGV4dE1lbnUiLCJvblZlcnRleE1hcmtlck1vdXNlRG93biIsIm9uVmVydGV4TWFya2VyTW91c2VPdmVyIiwib25WZXJ0ZXhNYXJrZXJNb3VzZU91dCIsInNwbGljZSIsImdldEluZGV4Iiwib25WZXJ0ZXhEZWxldGVkIiwiZGVsZXRlU2hhcGUiLCJyZXNldE1pZGRsZU1hcmtlciIsImluZGV4T2YiLCJnZXRMYXN0SW5kZXgiLCJnZXRQcmV2aW91cyIsImluZGV4IiwicHJldmlvdXNJbmRleCIsIkNMT1NFRCIsInByZXZpb3VzIiwibmV4dEluZGV4IiwiYWRkTWlkZGxlTWFya2VyIiwiaGFzTWlkZGxlTWFya2VycyIsInNwbGl0Iiwic3BsaXRTaGFwZSIsImNvbnRpbnVlIiwiY29udGludWVCYWNrd2FyZCIsImNvbnRpbnVlRm9yd2FyZCIsInZlcnRleE1hcmtlckNsYXNzIiwiTWlkZGxlTWFya2VyIiwib3BhY2l0eSIsImxlZnQiLCJyaWdodCIsImNvbXB1dGVMYXRMbmciLCJfb3BhY2l0eSIsInNldFZpc2liaWxpdHkiLCJsZWZ0UG9pbnQiLCJsYXRMbmdUb0NvbnRhaW5lclBvaW50IiwicmlnaHRQb2ludCIsInNpemUiLCJ4IiwiaGlkZSIsInNob3ciLCJzZXRPcGFjaXR5Iiwic2V0TGF0TG5nIiwieSIsImNvbnRhaW5lclBvaW50VG9MYXRMbmciLCJvbk1pZGRsZU1hcmtlck1vdXNlRG93biIsImFkZFZlcnRleE1hcmtlciIsIm9uTmV3VmVydGV4IiwicGFyZW50IiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwiYXBwZW5kQ2hpbGQiLCJfaW5pdEljb24iLCJfaW5pdEludGVyYWN0aW9uIiwiRHJhZ2dhYmxlIiwiX2RyYWdnaW5nIiwiZHJhZ2dpbmciLCJfZHJhZ2dhYmxlIiwiX29uRG93biIsIm1pZGRsZU1hcmtlckNsYXNzIiwiQmFzZUVkaXRvciIsIkhhbmRsZXIiLCJmZWF0dXJlIiwiYWRkSG9va3MiLCJpc0Nvbm5lY3RlZCIsIm9uRmVhdHVyZUFkZCIsIm9uY2UiLCJvbkVuYWJsZSIsIl9nZXRFdmVudHMiLCJyZW1vdmVIb29rcyIsImRpc2FibGUiLCJjbGVhckxheWVycyIsIm9uRGlzYWJsZSIsImVuYWJsZSIsIm9uRWRpdGluZyIsIm9uU3RhcnREcmF3aW5nIiwib25FbmREcmF3aW5nIiwib25DYW5jZWxEcmF3aW5nIiwib25Db21taXREcmF3aW5nIiwiZW5kRHJhd2luZyIsImNvbm5lY3QiLCJwcm9jZXNzRHJhd2luZ0NsaWNrIiwiaGFzTGF5ZXIiLCJvbk1vdmUiLCJkcmFnc3RhcnQiLCJkcmFnIiwiZHJhZ2VuZCIsInJlbW92ZSIsIk1hcmtlckVkaXRvciIsIlBhdGhFZGl0b3IiLCJNSU5fVkVSVEVYIiwiaW5pdFZlcnRleE1hcmtlcnMiLCJlbmFibGVkIiwiZ2V0TGF0TG5ncyIsImlzRmxhdCIsImFkZFZlcnRleE1hcmtlcnMiLCJpIiwicmVmcmVzaFZlcnRleE1hcmtlcnMiLCJnZXREZWZhdWx0TGF0TG5ncyIsImNvbW1pdCIsImN0cmxLZXkiLCJvblZlcnRleE1hcmtlckN0cmxDbGljayIsImFsdEtleSIsIm9uVmVydGV4TWFya2VyQWx0Q2xpY2siLCJzaGlmdEtleSIsIm9uVmVydGV4TWFya2VyU2hpZnRDbGljayIsIm1ldGFLZXkiLCJvblZlcnRleE1hcmtlck1ldGFLZXlDbGljayIsIl9kcmF3bkxhdExuZ3MiLCJvblZlcnRleFJhd01hcmtlckNsaWNrIiwidmVydGV4Q2FuQmVEZWxldGVkIiwiZXh0ZW5kQm91bmRzIiwic2V0RHJhd25MYXRMbmdzIiwic3RhcnREcmF3aW5nRm9yd2FyZCIsImFkZExhdExuZyIsInB1c2giLCJ1bnNoaWZ0IiwibmV3UG9pbnRGb3J3YXJkIiwibmV3UG9pbnRCYWNrd2FyZCIsImNvbnNvbGUiLCJlcnJvciIsInJlbW92ZUxhdExuZyIsInBvcCIsInNoYXBlIiwiYWRkTmV3RW1wdHlTaGFwZSIsIl9kZWxldGVTaGFwZSIsImVuc3VyZU5vdEZsYXQiLCJzZWxmIiwiaW5wbGFjZURlbGV0ZSIsIk51bWJlciIsIk1BWF9WQUxVRSIsInNwbGljZURlbGV0ZSIsImRlbGV0ZVNoYXBlQXQiLCJzaGFwZUF0IiwiYXBwZW5kU2hhcGUiLCJpbnNlcnRTaGFwZSIsInByZXBlbmRTaGFwZSIsImVuc3VyZU11bHRpIiwiZm9ybWF0U2hhcGUiLCJfZW5hYmxlZCIsIlBvbHlsaW5lRWRpdG9yIiwic3RhcnREcmF3aW5nQmFja3dhcmQiLCJMYXRMbmciLCJzaGFwZUluZGV4IiwiZmlyc3QiLCJzbGljZSIsInNlY29uZCIsImxhdCIsImxuZyIsImFsdCIsIlBvbHlnb25FZGl0b3IiLCJhZGROZXdFbXB0eUhvbGUiLCJob2xlcyIsInBhcmVudFNoYXBlIiwiaWR4IiwiUmVjdGFuZ2xlRWRpdG9yIiwib3Bwb3NpdGVJbmRleCIsIm9wcG9zaXRlIiwidXBkYXRlQm91bmRzIiwidXBkYXRlTGF0TG5ncyIsIl9zaW11bGF0ZWQiLCJfb25VcCIsIm5ld0xhdGxuZ3MiLCJfYm91bmRzVG9MYXRMbmdzIiwiQ2lyY2xlRWRpdG9yIiwiX3Jlc2l6ZUxhdExuZyIsImNvbXB1dGVSZXNpemVMYXRMbmciLCJkZWx0YSIsIl9yYWRpdXMiLCJfbVJhZGl1cyIsImNvcyIsIlBJIiwicHJvamVjdCIsInVucHJvamVjdCIsInVwZGF0ZVJlc2l6ZUxhdExuZyIsInJlc2l6ZSIsInJhZGl1cyIsInNldFJhZGl1cyIsIkVkaXRhYmxlTWl4aW4iLCJjcmVhdGVFZGl0b3IiLCJFcnJvciIsIktsYXNzIiwiZWRpdG9yQ2xhc3MiLCJnZXRFZGl0b3JDbGFzcyIsImVkaXRFbmFibGVkIiwiZGlzYWJsZUVkaXQiLCJ0b2dnbGVFZGl0IiwiX29uRWRpdGFibGVBZGQiLCJQb2x5bGluZU1peGluIiwiaXNJbkxhdExuZ3MiLCJsIiwiayIsImxlbiIsInBhcnQiLCJwIiwidyIsIl9jbGlja1RvbGVyYW5jZSIsIl9wcm9qZWN0TGF0bG5ncyIsIl9weEJvdW5kcyIsImxhdExuZ1RvTGF5ZXJQb2ludCIsImNvbnRhaW5zIiwiTGluZVV0aWwiLCJwb2ludFRvU2VnbWVudERpc3RhbmNlIiwiUG9seWdvbk1peGluIiwiaW5zaWRlIiwibDEiLCJsMiIsImoiLCJsZW4yIiwiTWFya2VyTWl4aW4iLCJSZWN0YW5nbGVNaXhpbiIsIkNpcmNsZU1peGluIiwia2VlcEVkaXRhYmxlIiwiX2ZsYXQiLCJpbmNsdWRlIl0sIm1hcHBpbmdzIjoiQUFBQSxTQUFTQSxJQUFULENBQWNDLENBQWQsRUFBZ0I7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0FBLE1BQUVDLFFBQUYsR0FBYUQsRUFBRUUsT0FBRixDQUFVQyxNQUFWLENBQWlCOztBQUUxQkMsaUJBQVM7QUFDTEMscUJBQVMsQ0FESjtBQUVMQyxzQkFBVSxDQUFDO0FBRk4sU0FGaUI7O0FBTzFCQyxpQkFBUzs7QUFFTDtBQUNBO0FBQ0E7QUFDQUMsb0JBQVEsSUFMSDs7QUFPTDtBQUNBO0FBQ0FDLDBCQUFjVCxFQUFFVSxPQVRYOztBQVdMO0FBQ0E7QUFDQUMsMkJBQWVYLEVBQUVZLFFBYlo7O0FBZUw7QUFDQTtBQUNBQyx5QkFBYWIsRUFBRWMsTUFqQlY7O0FBbUJMO0FBQ0E7QUFDQUMsNEJBQWdCZixFQUFFZ0IsU0FyQmI7O0FBdUJMO0FBQ0E7QUFDQUMseUJBQWFqQixFQUFFa0IsTUF6QlY7O0FBMkJMO0FBQ0E7QUFDQUMsNkJBQWlCLDBCQTdCWjs7QUErQkw7QUFDQTtBQUNBQywyQkFBZSxXQWpDVjs7QUFtQ0w7QUFDQTtBQUNBQyx1QkFBV0MsU0FyQ047O0FBdUNMO0FBQ0E7QUFDQUMsMkJBQWVELFNBekNWOztBQTJDTDtBQUNBO0FBQ0FFLGlDQUFxQkYsU0E3Q2hCOztBQStDTDtBQUNBO0FBQ0FHLGdDQUFvQkgsU0FqRGY7O0FBbURMO0FBQ0E7QUFDQUksK0JBQW1CSixTQXJEZDs7QUF1REw7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NUUsTUFBVCxDQUFUO0FBQ0EsYUFBS2dTLEdBQUwsR0FBV2hTLE9BQU9nUyxHQUFsQjtBQUNBLGFBQUtDLEdBQUwsR0FBV2pTLE9BQU9pUyxHQUFsQjtBQUNILEtBSkQ7QUFLSDtBQUNENVYsS0FBSytHLE9BQU85RyxDQUFaIiwiZmlsZSI6IlZ1ZTJMZWFmbGV0RWRpdGFibGVQbHVnaW4uanMiLCJzb3VyY2VSb290IjoiL1VzZXJzL3B1bWVsb3RlYS9WdWVQcm9qZWN0cy92dWUyLWxlYWZsZXQtZWRpdGFibGUiLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBpbml0KEwpe1xuICAgIC8vIPCfjYJtaW5pY2xhc3MgQ2FuY2VsYWJsZUV2ZW50IChFdmVudCBvYmplY3RzKVxuICAgIC8vIPCfjYJtZXRob2QgY2FuY2VsKClcbiAgICAvLyBDYW5jZWwgYW55IHN1YnNlcXVlbnQgYWN0aW9uLlxuXG4gICAgLy8g8J+Ngm1pbmljbGFzcyBWZXJ0ZXhFdmVudCAoRXZlbnQgb2JqZWN0cylcbiAgICAvLyDwn42CcHJvcGVydHkgdmVydGV4OiBWZXJ0ZXhNYXJrZXJcbiAgICAvLyBUaGUgdmVydGV4IHRoYXQgZmlyZXMgdGhlIGV2ZW50LlxuXG4gICAgLy8g8J+Ngm1pbmljbGFzcyBTaGFwZUV2ZW50IChFdmVudCBvYmplY3RzKVxuICAgIC8vIPCfjYJwcm9wZXJ0eSBzaGFwZTogQXJyYXlcbiAgICAvLyBUaGUgc2hhcGUgKExhdExuZ3MgYXJyYXkpIHN1YmplY3Qgb2YgdGhlIGFjdGlvbi5cblxuICAgIC8vIPCfjYJtaW5pY2xhc3MgQ2FuY2VsYWJsZVZlcnRleEV2ZW50IChFdmVudCBvYmplY3RzKVxuICAgIC8vIPCfjYJpbmhlcml0cyBWZXJ0ZXhFdmVudFxuICAgIC8vIPCfjYJpbmhlcml0cyBDYW5jZWxhYmxlRXZlbnRcblxuICAgIC8vIPCfjYJtaW5pY2xhc3MgQ2FuY2VsYWJsZVNoYXBlRXZlbnQgKEV2ZW50IG9iamVjdHMpXG4gICAgLy8g8J+NgmluaGVyaXRzIFNoYXBlRXZlbnRcbiAgICAvLyDwn42CaW5oZXJpdHMgQ2FuY2VsYWJsZUV2ZW50XG5cbiAgICAvLyDwn42CbWluaWNsYXNzIExheWVyRXZlbnQgKEV2ZW50IG9iamVjdHMpXG4gICAgLy8g8J+NgnByb3BlcnR5IGxheWVyOiBvYmplY3RcbiAgICAvLyBUaGUgTGF5ZXIgKE1hcmtlciwgUG9seWxpbmXigKYpIHN1YmplY3Qgb2YgdGhlIGFjdGlvbi5cblxuICAgIC8vIPCfjYJuYW1lc3BhY2UgRWRpdGFibGU7IPCfjYJjbGFzcyBFZGl0YWJsZTsg8J+NgmFrYSBMLkVkaXRhYmxlXG4gICAgLy8gTWFpbiBlZGl0aW9uIGhhbmRsZXIuIEJ5IGRlZmF1bHQsIGl0IGlzIGF0dGFjaGVkIHRvIHRoZSBtYXBcbiAgICAvLyBhcyBgbWFwLmVkaXRUb29sc2AgcHJvcGVydHkuXG4gICAgLy8gTGVhZmxldC5FZGl0YWJsZSBpcyBtYWRlIHRvIGJlIGZ1bGx5IGV4dGVuZGFibGUuIFlvdSBoYXZlIHRocmVlIHdheXMgdG8gY3VzdG9taXplXG4gICAgLy8gdGhlIGJlaGF2aW91cjogdXNpbmcgb3B0aW9ucywgbGlzdGVuaW5nIHRvIGV2ZW50cywgb3IgZXh0ZW5kaW5nLlxuICAgIEwuRWRpdGFibGUgPSBMLkV2ZW50ZWQuZXh0ZW5kKHtcblxuICAgICAgICBzdGF0aWNzOiB7XG4gICAgICAgICAgICBGT1JXQVJEOiAxLFxuICAgICAgICAgICAgQkFDS1dBUkQ6IC0xXG4gICAgICAgIH0sXG5cbiAgICAgICAgb3B0aW9uczoge1xuXG4gICAgICAgICAgICAvLyBZb3UgY2FuIHBhc3MgdGhlbSB3aGVuIGNyZWF0aW5nIGEgbWFwIHVzaW5nIHRoZSBgZWRpdE9wdGlvbnNgIGtleS5cbiAgICAgICAgICAgIC8vIPCfjYJvcHRpb24gekluZGV4OiBpbnQgPSAxMDAwXG4gICAgICAgICAgICAvLyBUaGUgZGVmYXVsdCB6SW5kZXggb2YgdGhlIGVkaXRpbmcgdG9vbHMuXG4gICAgICAgICAgICB6SW5kZXg6IDEwMDAsXG5cbiAgICAgICAgICAgIC8vIPCfjYJvcHRpb24gcG9seWdvbkNsYXNzOiBjbGFzcyA9IEwuUG9seWdvblxuICAgICAgICAgICAgLy8gQ2xhc3MgdG8gYmUgdXNlZCB3aGVuIGNyZWF0aW5nIGEgbmV3IFBvbHlnb24uXG4gICAgICAgICAgICBwb2x5Z29uQ2xhc3M6IEwuUG9seWdvbixcblxuICAgICAgICAgICAgLy8g8J+Ngm9wdGlvbiBwb2x5bGluZUNsYXNzOiBjbGFzcyA9IEwuUG9seWxpbmVcbiAgICAgICAgICAgIC8vIENsYXNzIHRvIGJlIHVzZWQgd2hlbiBjcmVhdGluZyBhIG5ldyBQb2x5bGluZS5cbiAgICAgICAgICAgIHBvbHlsaW5lQ2xhc3M6IEwuUG9seWxpbmUsXG5cbiAgICAgICAgICAgIC8vIPCfjYJvcHRpb24gbWFya2VyQ2xhc3M6IGNsYXNzID0gTC5NYXJrZXJcbiAgICAgICAgICAgIC8vIENsYXNzIHRvIGJlIHVzZWQgd2hlbiBjcmVhdGluZyBhIG5ldyBNYXJrZXIuXG4gICAgICAgICAgICBtYXJrZXJDbGFzczogTC5NYXJrZXIsXG5cbiAgICAgICAgICAgIC8vIPCfjYJvcHRpb24gcmVjdGFuZ2xlQ2xhc3M6IGNsYXNzID0gTC5SZWN0YW5nbGVcbiAgICAgICAgICAgIC8vIENsYXNzIHRvIGJlIHVzZWQgd2hlbiBjcmVhdGluZyBhIG5ldyBSZWN0YW5nbGUuXG4gICAgICAgICAgICByZWN0YW5nbGVDbGFzczogTC5SZWN0YW5nbGUsXG5cbiAgICAgICAgICAgIC8vIPCfjYJvcHRpb24gY2lyY2xlQ2xhc3M6IGNsYXNzID0gTC5DaXJjbGVcbiAgICAgICAgICAgIC8vIENsYXNzIHRvIGJlIHVzZWQgd2hlbiBjcmVhdGluZyBhIG5ldyBDaXJjbGUuXG4gICAgICAgICAgICBjaXJjbGVDbGFzczogTC5DaXJjbGUsXG5cbiAgICAgICAgICAgIC8vIPCfjYJvcHRpb24gZHJhd2luZ0NTU0NsYXNzOiBzdHJpbmcgPSAnbGVhZmxldC1lZGl0YWJsZS1kcmF3aW5nJ1xuICAgICAgICAgICAgLy8gQ1NTIGNsYXNzIHRvIGJlIGFkZGVkIHRvIHRoZSBtYXAgY29udGFpbmVyIHdoaWxlIGRyYXdpbmcuXG4gICAgICAgICAgICBkcmF3aW5nQ1NTQ2xhc3M6ICdsZWFmbGV0LWVkaXRhYmxlLWRyYXdpbmcnLFxuXG4gICAgICAgICAgICAvLyDwn42Cb3B0aW9uIGRyYXdpbmdDdXJzb3I6IGNvbnN0ID0gJ2Nyb3NzaGFpcidcbiAgICAgICAgICAgIC8vIEN1cnNvciBtb2RlIHNldCB0byB0aGUgbWFwIHdoaWxlIGRyYXdpbmcuXG4gICAgICAgICAgICBkcmF3aW5nQ3Vyc29yOiAnY3Jvc3NoYWlyJyxcblxuICAgICAgICAgICAgLy8g8J+Ngm9wdGlvbiBlZGl0TGF5ZXI6IExheWVyID0gbmV3IEwuTGF5ZXJHcm91cCgpXG4gICAgICAgICAgICAvLyBMYXllciB1c2VkIHRvIHN0b3JlIGVkaXQgdG9vbHMgKHZlcnRleCwgbGluZSBndWlkZeKApikuXG4gICAgICAgICAgICBlZGl0TGF5ZXI6IHVuZGVmaW5lZCxcblxuICAgICAgICAgICAgLy8g8J+Ngm9wdGlvbiBmZWF0dXJlc0xheWVyOiBMYXllciA9IG5ldyBMLkxheWVyR3JvdXAoKVxuICAgICAgICAgICAgLy8gRGVmYXVsdCBsYXllciB1c2VkIHRvIHN0b3JlIGRyYXduIGZlYXR1cmVzIChNYXJrZXIsIFBvbHlsaW5l4oCmKS5cbiAgICAgICAgICAgIGZlYXR1cmVzTGF5ZXI6IHVuZGVmaW5lZCxcblxuICAgICAgICAgICAgLy8g8J+Ngm9wdGlvbiBwb2x5bGluZUVkaXRvckNsYXNzOiBjbGFzcyA9IFBvbHlsaW5lRWRpdG9yXG4gICAgICAgICAgICAvLyBDbGFzcyB0byBiZSB1c2VkIGFzIFBvbHlsaW5lIGVkaXRvci5cbiAgICAgICAgICAgIHBvbHlsaW5lRWRpdG9yQ2xhc3M6IHVuZGVmaW5lZCxcblxuICAgICAgICAgICAgLy8g8J+Ngm9wdGlvbiBwb2x5Z29uRWRpdG9yQ2xhc3M6IGNsYXNzID0gUG9seWdvbkVkaXRvclxuICAgICAgICAgICAgLy8gQ2xhc3MgdG8gYmUgdXNlZCBhcyBQb2x5Z29uIGVkaXRvci5cbiAgICAgICAgICAgIHBvbHlnb25FZGl0b3JDbGFzczogdW5kZWZpbmVkLFxuXG4gICAgICAgICAgICAvLyDwn42Cb3B0aW9uIG1hcmtlckVkaXRvckNsYXNzOiBjbGFzcyA9IE1hcmtlckVkaXRvclxuICAgICAgICAgICAgLy8gQ2xhc3MgdG8gYmUgdXNlZCBhcyBNYXJrZXIgZWRpdG9yLlxuICAgICAgICAgICAgbWFya2VyRWRpdG9yQ2xhc3M6IHVuZGVmaW5lZCxcblxuICAgICAgICAgICAgLy8g8J+Ngm9wdGlvbiByZWN0YW5nbGVFZGl0b3JDbGFzczogY2xhc3MgPSBSZWN0YW5nbGVFZGl0b3JcbiAgICAgICAgICAgIC8vIENsYXNzIHRvIGJlIHVzZWQgYXMgUmVjdGFuZ2xlIGVkaXRvci5cbiAgICAgICAgICAgIHJlY3RhbmdsZUVkaXRvckNsYXNzOiB1bmRlZmluZWQsXG5cbiAgICAgICAgICAgIC8vIPCfjYJvcHRpb24gY2lyY2xlRWRpdG9yQ2xhc3M6IGNsYXNzID0gQ2lyY2xlRWRpdG9yXG4gICAgICAgICAgICAvLyBDbGFzcyB0byBiZSB1c2VkIGFzIENpcmNsZSBlZGl0b3IuXG4gICAgICAgICAgICBjaXJjbGVFZGl0b3JDbGFzczogdW5kZWZpbmVkLFxuXG4gICAgICAgICAgICAvLyDwn42Cb3B0aW9uIGxpbmVHdWlkZU9wdGlvbnM6IGhhc2ggPSB7fVxuICAgICAgICAgICAgLy8gT3B0aW9ucyB0byBiZSBwYXNzZWQgdG8gdGhlIGxpbmUgZ3VpZGVzLlxuICAgICAgICAgICAgbGluZUd1aWRlT3B0aW9uczoge30sXG5cbiAgICAgICAgICAgIC8vIPCfjYJvcHRpb24gc2tpcE1pZGRsZU1hcmtlcnM6IGJvb2xlYW4gPSBmYWxzZVxuICAgICAgICAgICAgLy8gU2V0IHRoaXMgdG8gdHJ1ZSBpZiB5b3UgZG9uJ3Qgd2FudCBtaWRkbGUgbWFya2Vycy5cbiAgICAgICAgICAgIHNraXBNaWRkbGVNYXJrZXJzOiBmYWxzZVxuXG4gICAgICAgIH0sXG5cbiAgICAgICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcCwgb3B0aW9ucykge1xuICAgICAgICAgICAgTC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5fbGFzdFpJbmRleCA9IHRoaXMub3B0aW9ucy56SW5kZXg7XG4gICAgICAgICAgICB0aGlzLm1hcCA9IG1hcDtcbiAgICAgICAgICAgIHRoaXMuZWRpdExheWVyID0gdGhpcy5jcmVhdGVFZGl0TGF5ZXIoKTtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZXNMYXllciA9IHRoaXMuY3JlYXRlRmVhdHVyZXNMYXllcigpO1xuICAgICAgICAgICAgdGhpcy5mb3J3YXJkTGluZUd1aWRlID0gdGhpcy5jcmVhdGVMaW5lR3VpZGUoKTtcbiAgICAgICAgICAgIHRoaXMuYmFja3dhcmRMaW5lR3VpZGUgPSB0aGlzLmNyZWF0ZUxpbmVHdWlkZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGZpcmVBbmRGb3J3YXJkOiBmdW5jdGlvbiAodHlwZSwgZSkge1xuICAgICAgICAgICAgZSA9IGUgfHwge307XG4gICAgICAgICAgICBlLmVkaXRUb29scyA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmZpcmUodHlwZSwgZSk7XG4gICAgICAgICAgICB0aGlzLm1hcC5maXJlKHR5cGUsIGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZUxpbmVHdWlkZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBMLmV4dGVuZCh7ZGFzaEFycmF5OiAnNSwxMCcsIHdlaWdodDogMSwgaW50ZXJhY3RpdmU6IGZhbHNlfSwgdGhpcy5vcHRpb25zLmxpbmVHdWlkZU9wdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuIEwucG9seWxpbmUoW10sIG9wdGlvbnMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZVZlcnRleEljb246IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gTC5Ccm93c2VyLm1vYmlsZSAmJiBMLkJyb3dzZXIudG91Y2ggPyBuZXcgTC5FZGl0YWJsZS5Ub3VjaFZlcnRleEljb24ob3B0aW9ucykgOiBuZXcgTC5FZGl0YWJsZS5WZXJ0ZXhJY29uKG9wdGlvbnMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZUVkaXRMYXllcjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5lZGl0TGF5ZXIgfHwgbmV3IEwuTGF5ZXJHcm91cCgpLmFkZFRvKHRoaXMubWFwKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVGZWF0dXJlc0xheWVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmZlYXR1cmVzTGF5ZXIgfHwgbmV3IEwuTGF5ZXJHcm91cCgpLmFkZFRvKHRoaXMubWFwKTtcbiAgICAgICAgfSxcblxuICAgICAgICBtb3ZlRm9yd2FyZExpbmVHdWlkZTogZnVuY3Rpb24gKGxhdGxuZykge1xuICAgICAgICAgICAgaWYgKHRoaXMuZm9yd2FyZExpbmVHdWlkZS5fbGF0bG5ncy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZvcndhcmRMaW5lR3VpZGUuX2xhdGxuZ3NbMV0gPSBsYXRsbmc7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3J3YXJkTGluZUd1aWRlLl9ib3VuZHMuZXh0ZW5kKGxhdGxuZyk7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3J3YXJkTGluZUd1aWRlLnJlZHJhdygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG1vdmVCYWNrd2FyZExpbmVHdWlkZTogZnVuY3Rpb24gKGxhdGxuZykge1xuICAgICAgICAgICAgaWYgKHRoaXMuYmFja3dhcmRMaW5lR3VpZGUuX2xhdGxuZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5iYWNrd2FyZExpbmVHdWlkZS5fbGF0bG5nc1sxXSA9IGxhdGxuZztcbiAgICAgICAgICAgICAgICB0aGlzLmJhY2t3YXJkTGluZUd1aWRlLl9ib3VuZHMuZXh0ZW5kKGxhdGxuZyk7XG4gICAgICAgICAgICAgICAgdGhpcy5iYWNrd2FyZExpbmVHdWlkZS5yZWRyYXcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBhbmNob3JGb3J3YXJkTGluZUd1aWRlOiBmdW5jdGlvbiAobGF0bG5nKSB7XG4gICAgICAgICAgICB0aGlzLmZvcndhcmRMaW5lR3VpZGUuX2xhdGxuZ3NbMF0gPSBsYXRsbmc7XG4gICAgICAgICAgICB0aGlzLmZvcndhcmRMaW5lR3VpZGUuX2JvdW5kcy5leHRlbmQobGF0bG5nKTtcbiAgICAgICAgICAgIHRoaXMuZm9yd2FyZExpbmVHdWlkZS5yZWRyYXcoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBhbmNob3JCYWNrd2FyZExpbmVHdWlkZTogZnVuY3Rpb24gKGxhdGxuZykge1xuICAgICAgICAgICAgdGhpcy5iYWNrd2FyZExpbmVHdWlkZS5fbGF0bG5nc1swXSA9IGxhdGxuZztcbiAgICAgICAgICAgIHRoaXMuYmFja3dhcmRMaW5lR3VpZGUuX2JvdW5kcy5leHRlbmQobGF0bG5nKTtcbiAgICAgICAgICAgIHRoaXMuYmFja3dhcmRMaW5lR3VpZGUucmVkcmF3KCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYXR0YWNoRm9yd2FyZExpbmVHdWlkZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5lZGl0TGF5ZXIuYWRkTGF5ZXIodGhpcy5mb3J3YXJkTGluZUd1aWRlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBhdHRhY2hCYWNrd2FyZExpbmVHdWlkZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5lZGl0TGF5ZXIuYWRkTGF5ZXIodGhpcy5iYWNrd2FyZExpbmVHdWlkZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGV0YWNoRm9yd2FyZExpbmVHdWlkZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5mb3J3YXJkTGluZUd1aWRlLnNldExhdExuZ3MoW10pO1xuICAgICAgICAgICAgdGhpcy5lZGl0TGF5ZXIucmVtb3ZlTGF5ZXIodGhpcy5mb3J3YXJkTGluZUd1aWRlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBkZXRhY2hCYWNrd2FyZExpbmVHdWlkZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5iYWNrd2FyZExpbmVHdWlkZS5zZXRMYXRMbmdzKFtdKTtcbiAgICAgICAgICAgIHRoaXMuZWRpdExheWVyLnJlbW92ZUxheWVyKHRoaXMuYmFja3dhcmRMaW5lR3VpZGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGJsb2NrRXZlbnRzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBIYWNrOiBmb3JjZSBtYXAgbm90IHRvIGxpc3RlbiB0byBvdGhlciBsYXllcnMgZXZlbnRzIHdoaWxlIGRyYXdpbmcuXG4gICAgICAgICAgICBpZiAoIXRoaXMuX29sZFRhcmdldHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vbGRUYXJnZXRzID0gdGhpcy5tYXAuX3RhcmdldHM7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXAuX3RhcmdldHMgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICB1bmJsb2NrRXZlbnRzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fb2xkVGFyZ2V0cykge1xuICAgICAgICAgICAgICAgIC8vIFJlc2V0LCBidXQga2VlcCB0YXJnZXRzIGNyZWF0ZWQgd2hpbGUgZHJhd2luZy5cbiAgICAgICAgICAgICAgICB0aGlzLm1hcC5fdGFyZ2V0cyA9IEwuZXh0ZW5kKHRoaXMubWFwLl90YXJnZXRzLCB0aGlzLl9vbGRUYXJnZXRzKTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fb2xkVGFyZ2V0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICByZWdpc3RlckZvckRyYXdpbmc6IGZ1bmN0aW9uIChlZGl0b3IpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9kcmF3aW5nRWRpdG9yKSB0aGlzLnVucmVnaXN0ZXJGb3JEcmF3aW5nKHRoaXMuX2RyYXdpbmdFZGl0b3IpO1xuICAgICAgICAgICAgdGhpcy5ibG9ja0V2ZW50cygpO1xuICAgICAgICAgICAgZWRpdG9yLnJlc2V0KCk7ICAvLyBNYWtlIHN1cmUgZWRpdG9yIHRvb2xzIHN0aWxsIHJlY2VpdmUgZXZlbnRzLlxuICAgICAgICAgICAgdGhpcy5fZHJhd2luZ0VkaXRvciA9IGVkaXRvcjtcbiAgICAgICAgICAgIHRoaXMubWFwLm9uKCdtb3VzZW1vdmUgdG91Y2htb3ZlJywgZWRpdG9yLm9uRHJhd2luZ01vdXNlTW92ZSwgZWRpdG9yKTtcbiAgICAgICAgICAgIHRoaXMubWFwLm9uKCdtb3VzZWRvd24nLCB0aGlzLm9uTW91c2Vkb3duLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMubWFwLm9uKCdtb3VzZXVwJywgdGhpcy5vbk1vdXNldXAsIHRoaXMpO1xuICAgICAgICAgICAgTC5Eb21VdGlsLmFkZENsYXNzKHRoaXMubWFwLl9jb250YWluZXIsIHRoaXMub3B0aW9ucy5kcmF3aW5nQ1NTQ2xhc3MpO1xuICAgICAgICAgICAgdGhpcy5kZWZhdWx0TWFwQ3Vyc29yID0gdGhpcy5tYXAuX2NvbnRhaW5lci5zdHlsZS5jdXJzb3I7XG4gICAgICAgICAgICB0aGlzLm1hcC5fY29udGFpbmVyLnN0eWxlLmN1cnNvciA9IHRoaXMub3B0aW9ucy5kcmF3aW5nQ3Vyc29yO1xuICAgICAgICB9LFxuXG4gICAgICAgIHVucmVnaXN0ZXJGb3JEcmF3aW5nOiBmdW5jdGlvbiAoZWRpdG9yKSB7XG4gICAgICAgICAgICB0aGlzLnVuYmxvY2tFdmVudHMoKTtcbiAgICAgICAgICAgIEwuRG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLm1hcC5fY29udGFpbmVyLCB0aGlzLm9wdGlvbnMuZHJhd2luZ0NTU0NsYXNzKTtcbiAgICAgICAgICAgIHRoaXMubWFwLl9jb250YWluZXIuc3R5bGUuY3Vyc29yID0gdGhpcy5kZWZhdWx0TWFwQ3Vyc29yO1xuICAgICAgICAgICAgZWRpdG9yID0gZWRpdG9yIHx8IHRoaXMuX2RyYXdpbmdFZGl0b3I7XG4gICAgICAgICAgICBpZiAoIWVkaXRvcikgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5tYXAub2ZmKCdtb3VzZW1vdmUgdG91Y2htb3ZlJywgZWRpdG9yLm9uRHJhd2luZ01vdXNlTW92ZSwgZWRpdG9yKTtcbiAgICAgICAgICAgIHRoaXMubWFwLm9mZignbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlZG93biwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLm1hcC5vZmYoJ21vdXNldXAnLCB0aGlzLm9uTW91c2V1cCwgdGhpcyk7XG4gICAgICAgICAgICBpZiAoZWRpdG9yICE9PSB0aGlzLl9kcmF3aW5nRWRpdG9yKSByZXR1cm47XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fZHJhd2luZ0VkaXRvcjtcbiAgICAgICAgICAgIGlmIChlZGl0b3IuX2RyYXdpbmcpIGVkaXRvci5jYW5jZWxEcmF3aW5nKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25Nb3VzZWRvd246IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAoZS5vcmlnaW5hbEV2ZW50LndoaWNoICE9IDEpIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMuX21vdXNlRG93biA9IGU7XG4gICAgICAgICAgICB0aGlzLl9kcmF3aW5nRWRpdG9yLm9uRHJhd2luZ01vdXNlRG93bihlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvbk1vdXNldXA6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbW91c2VEb3duKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVkaXRvciA9IHRoaXMuX2RyYXdpbmdFZGl0b3IsXG4gICAgICAgICAgICAgICAgICAgIG1vdXNlRG93biA9IHRoaXMuX21vdXNlRG93bjtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb3VzZURvd24gPSBudWxsO1xuICAgICAgICAgICAgICAgIGVkaXRvci5vbkRyYXdpbmdNb3VzZVVwKGUpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9kcmF3aW5nRWRpdG9yICE9PSBlZGl0b3IpIHJldHVybjsgIC8vIG9uRHJhd2luZ01vdXNlVXAgbWF5IGNhbGwgdW5yZWdpc3RlckZyb21EcmF3aW5nLlxuICAgICAgICAgICAgICAgIHZhciBvcmlnaW4gPSBMLnBvaW50KG1vdXNlRG93bi5vcmlnaW5hbEV2ZW50LmNsaWVudFgsIG1vdXNlRG93bi5vcmlnaW5hbEV2ZW50LmNsaWVudFkpO1xuICAgICAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IEwucG9pbnQoZS5vcmlnaW5hbEV2ZW50LmNsaWVudFgsIGUub3JpZ2luYWxFdmVudC5jbGllbnRZKS5kaXN0YW5jZVRvKG9yaWdpbik7XG4gICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKGRpc3RhbmNlKSA8IDkgKiAod2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSkpIHRoaXMuX2RyYXdpbmdFZGl0b3Iub25EcmF3aW5nQ2xpY2soZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8g8J+NgnNlY3Rpb24gUHVibGljIG1ldGhvZHNcbiAgICAgICAgLy8gWW91IHdpbGwgZ2VuZXJhbGx5IGFjY2VzcyB0aGVtIGJ5IHRoZSBgbWFwLmVkaXRUb29sc2BcbiAgICAgICAgLy8gaW5zdGFuY2U6XG4gICAgICAgIC8vXG4gICAgICAgIC8vIGBtYXAuZWRpdFRvb2xzLnN0YXJ0UG9seWxpbmUoKTtgXG5cbiAgICAgICAgLy8g8J+Ngm1ldGhvZCBkcmF3aW5nKCk6IGJvb2xlYW5cbiAgICAgICAgLy8gUmV0dXJuIHRydWUgaWYgYW55IGRyYXdpbmcgYWN0aW9uIGlzIG9uZ29pbmcuXG4gICAgICAgIGRyYXdpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kcmF3aW5nRWRpdG9yICYmIHRoaXMuX2RyYXdpbmdFZGl0b3IuZHJhd2luZygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIPCfjYJtZXRob2Qgc3RvcERyYXdpbmcoKVxuICAgICAgICAvLyBXaGVuIHlvdSBuZWVkIHRvIHN0b3AgYW55IG9uZ29pbmcgZHJhd2luZywgd2l0aG91dCBuZWVkaW5nIHRvIGtub3cgd2hpY2ggZWRpdG9yIGlzIGFjdGl2ZS5cbiAgICAgICAgc3RvcERyYXdpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMudW5yZWdpc3RlckZvckRyYXdpbmcoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyDwn42CbWV0aG9kIGNvbW1pdERyYXdpbmcoKVxuICAgICAgICAvLyBXaGVuIHlvdSBuZWVkIHRvIGNvbW1pdCBhbnkgb25nb2luZyBkcmF3aW5nLCB3aXRob3V0IG5lZWRpbmcgdG8ga25vdyB3aGljaCBlZGl0b3IgaXMgYWN0aXZlLlxuICAgICAgICBjb21taXREcmF3aW5nOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9kcmF3aW5nRWRpdG9yKSByZXR1cm47XG4gICAgICAgICAgICB0aGlzLl9kcmF3aW5nRWRpdG9yLmNvbW1pdERyYXdpbmcoZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY29ubmVjdENyZWF0ZWRUb01hcDogZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mZWF0dXJlc0xheWVyLmFkZExheWVyKGxheWVyKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyDwn42CbWV0aG9kIHN0YXJ0UG9seWxpbmUobGF0bG5nOiBMLkxhdExuZywgb3B0aW9uczogaGFzaCk6IEwuUG9seWxpbmVcbiAgICAgICAgLy8gU3RhcnQgZHJhd2luZyBhIFBvbHlsaW5lLiBJZiBgbGF0bG5nYCBpcyBnaXZlbiwgYSBmaXJzdCBwb2ludCB3aWxsIGJlIGFkZGVkLiBJbiBhbnkgY2FzZSwgY29udGludWluZyBvbiB1c2VyIGNsaWNrLlxuICAgICAgICAvLyBJZiBgb3B0aW9uc2AgaXMgZ2l2ZW4sIGl0IHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBQb2x5bGluZSBjbGFzcyBjb25zdHJ1Y3Rvci5cbiAgICAgICAgc3RhcnRQb2x5bGluZTogZnVuY3Rpb24gKGxhdGxuZywgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIGxpbmUgPSB0aGlzLmNyZWF0ZVBvbHlsaW5lKFtdLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGxpbmUuZW5hYmxlRWRpdCh0aGlzLm1hcCkubmV3U2hhcGUobGF0bG5nKTtcbiAgICAgICAgICAgIHJldHVybiBsaW5lO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIPCfjYJtZXRob2Qgc3RhcnRQb2x5Z29uKGxhdGxuZzogTC5MYXRMbmcsIG9wdGlvbnM6IGhhc2gpOiBMLlBvbHlnb25cbiAgICAgICAgLy8gU3RhcnQgZHJhd2luZyBhIFBvbHlnb24uIElmIGBsYXRsbmdgIGlzIGdpdmVuLCBhIGZpcnN0IHBvaW50IHdpbGwgYmUgYWRkZWQuIEluIGFueSBjYXNlLCBjb250aW51aW5nIG9uIHVzZXIgY2xpY2suXG4gICAgICAgIC8vIElmIGBvcHRpb25zYCBpcyBnaXZlbiwgaXQgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIFBvbHlnb24gY2xhc3MgY29uc3RydWN0b3IuXG4gICAgICAgIHN0YXJ0UG9seWdvbjogZnVuY3Rpb24gKGxhdGxuZywgb3B0aW9ucykge1xuICAgICAgICAgICAgdmFyIHBvbHlnb24gPSB0aGlzLmNyZWF0ZVBvbHlnb24oW10sIG9wdGlvbnMpO1xuICAgICAgICAgICAgcG9seWdvbi5lbmFibGVFZGl0KHRoaXMubWFwKS5uZXdTaGFwZShsYXRsbmcpO1xuICAgICAgICAgICAgcmV0dXJuIHBvbHlnb247XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8g8J+Ngm1ldGhvZCBzdGFydE1hcmtlcihsYXRsbmc6IEwuTGF0TG5nLCBvcHRpb25zOiBoYXNoKTogTC5NYXJrZXJcbiAgICAgICAgLy8gU3RhcnQgYWRkaW5nIGEgTWFya2VyLiBJZiBgbGF0bG5nYCBpcyBnaXZlbiwgdGhlIE1hcmtlciB3aWxsIGJlIHNob3duIGZpcnN0IGF0IHRoaXMgcG9pbnQuXG4gICAgICAgIC8vIEluIGFueSBjYXNlLCBpdCB3aWxsIGZvbGxvdyB0aGUgdXNlciBtb3VzZSwgYW5kIHdpbGwgaGF2ZSBhIGZpbmFsIGBsYXRsbmdgIG9uIG5leHQgY2xpY2sgKG9yIHRvdWNoKS5cbiAgICAgICAgLy8gSWYgYG9wdGlvbnNgIGlzIGdpdmVuLCBpdCB3aWxsIGJlIHBhc3NlZCB0byB0aGUgTWFya2VyIGNsYXNzIGNvbnN0cnVjdG9yLlxuICAgICAgICBzdGFydE1hcmtlcjogZnVuY3Rpb24gKGxhdGxuZywgb3B0aW9ucykge1xuICAgICAgICAgICAgbGF0bG5nID0gbGF0bG5nIHx8IHRoaXMubWFwLmdldENlbnRlcigpLmNsb25lKCk7XG4gICAgICAgICAgICB2YXIgbWFya2VyID0gdGhpcy5jcmVhdGVNYXJrZXIobGF0bG5nLCBvcHRpb25zKTtcbiAgICAgICAgICAgIG1hcmtlci5lbmFibGVFZGl0KHRoaXMubWFwKS5zdGFydERyYXdpbmcoKTtcbiAgICAgICAgICAgIHJldHVybiBtYXJrZXI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8g8J+Ngm1ldGhvZCBzdGFydFJlY3RhbmdsZShsYXRsbmc6IEwuTGF0TG5nLCBvcHRpb25zOiBoYXNoKTogTC5SZWN0YW5nbGVcbiAgICAgICAgLy8gU3RhcnQgZHJhd2luZyBhIFJlY3RhbmdsZS4gSWYgYGxhdGxuZ2AgaXMgZ2l2ZW4sIHRoZSBSZWN0YW5nbGUgYW5jaG9yIHdpbGwgYmUgYWRkZWQuIEluIGFueSBjYXNlLCBjb250aW51aW5nIG9uIHVzZXIgZHJhZy5cbiAgICAgICAgLy8gSWYgYG9wdGlvbnNgIGlzIGdpdmVuLCBpdCB3aWxsIGJlIHBhc3NlZCB0byB0aGUgUmVjdGFuZ2xlIGNsYXNzIGNvbnN0cnVjdG9yLlxuICAgICAgICBzdGFydFJlY3RhbmdsZTogZnVuY3Rpb24obGF0bG5nLCBvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgY29ybmVyID0gbGF0bG5nIHx8IEwubGF0TG5nKFswLCAwXSk7XG4gICAgICAgICAgICB2YXIgYm91bmRzID0gbmV3IEwuTGF0TG5nQm91bmRzKGNvcm5lciwgY29ybmVyKTtcbiAgICAgICAgICAgIHZhciByZWN0YW5nbGUgPSB0aGlzLmNyZWF0ZVJlY3RhbmdsZShib3VuZHMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgcmVjdGFuZ2xlLmVuYWJsZUVkaXQodGhpcy5tYXApLnN0YXJ0RHJhd2luZygpO1xuICAgICAgICAgICAgcmV0dXJuIHJlY3RhbmdsZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyDwn42CbWV0aG9kIHN0YXJ0Q2lyY2xlKGxhdGxuZzogTC5MYXRMbmcsIG9wdGlvbnM6IGhhc2gpOiBMLkNpcmNsZVxuICAgICAgICAvLyBTdGFydCBkcmF3aW5nIGEgQ2lyY2xlLiBJZiBgbGF0bG5nYCBpcyBnaXZlbiwgdGhlIENpcmNsZSBhbmNob3Igd2lsbCBiZSBhZGRlZC4gSW4gYW55IGNhc2UsIGNvbnRpbnVpbmcgb24gdXNlciBkcmFnLlxuICAgICAgICAvLyBJZiBgb3B0aW9uc2AgaXMgZ2l2ZW4sIGl0IHdpbGwgYmUgcGFzc2VkIHRvIHRoZSBDaXJjbGUgY2xhc3MgY29uc3RydWN0b3IuXG4gICAgICAgIHN0YXJ0Q2lyY2xlOiBmdW5jdGlvbiAobGF0bG5nLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBsYXRsbmcgPSBsYXRsbmcgfHwgdGhpcy5tYXAuZ2V0Q2VudGVyKCkuY2xvbmUoKTtcbiAgICAgICAgICAgIHZhciBjaXJjbGUgPSB0aGlzLmNyZWF0ZUNpcmNsZShsYXRsbmcsIG9wdGlvbnMpO1xuICAgICAgICAgICAgY2lyY2xlLmVuYWJsZUVkaXQodGhpcy5tYXApLnN0YXJ0RHJhd2luZygpO1xuICAgICAgICAgICAgcmV0dXJuIGNpcmNsZTtcbiAgICAgICAgfSxcblxuICAgICAgICBzdGFydEhvbGU6IGZ1bmN0aW9uIChlZGl0b3IsIGxhdGxuZykge1xuICAgICAgICAgICAgZWRpdG9yLm5ld0hvbGUobGF0bG5nKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVMYXllcjogZnVuY3Rpb24gKGtsYXNzLCBsYXRsbmdzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gTC5VdGlsLmV4dGVuZCh7ZWRpdE9wdGlvbnM6IHtlZGl0VG9vbHM6IHRoaXN9fSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB2YXIgbGF5ZXIgPSBuZXcga2xhc3MobGF0bG5ncywgb3B0aW9ucyk7XG4gICAgICAgICAgICAvLyDwn42CbmFtZXNwYWNlIEVkaXRhYmxlXG4gICAgICAgICAgICAvLyDwn42CZXZlbnQgZWRpdGFibGU6Y3JlYXRlZDogTGF5ZXJFdmVudFxuICAgICAgICAgICAgLy8gRmlyZWQgd2hlbiBhIG5ldyBmZWF0dXJlIChNYXJrZXIsIFBvbHlsaW5l4oCmKSBpcyBjcmVhdGVkLlxuICAgICAgICAgICAgdGhpcy5maXJlQW5kRm9yd2FyZCgnZWRpdGFibGU6Y3JlYXRlZCcsIHtsYXllcjogbGF5ZXJ9KTtcbiAgICAgICAgICAgIHJldHVybiBsYXllcjtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVQb2x5bGluZTogZnVuY3Rpb24gKGxhdGxuZ3MsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUxheWVyKG9wdGlvbnMgJiYgb3B0aW9ucy5wb2x5bGluZUNsYXNzIHx8IHRoaXMub3B0aW9ucy5wb2x5bGluZUNsYXNzLCBsYXRsbmdzLCBvcHRpb25zKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVQb2x5Z29uOiBmdW5jdGlvbiAobGF0bG5ncywgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlTGF5ZXIob3B0aW9ucyAmJiBvcHRpb25zLnBvbHlnb25DbGFzcyB8fCB0aGlzLm9wdGlvbnMucG9seWdvbkNsYXNzLCBsYXRsbmdzLCBvcHRpb25zKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjcmVhdGVNYXJrZXI6IGZ1bmN0aW9uIChsYXRsbmcsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUxheWVyKG9wdGlvbnMgJiYgb3B0aW9ucy5tYXJrZXJDbGFzcyB8fCB0aGlzLm9wdGlvbnMubWFya2VyQ2xhc3MsIGxhdGxuZywgb3B0aW9ucyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY3JlYXRlUmVjdGFuZ2xlOiBmdW5jdGlvbiAoYm91bmRzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVMYXllcihvcHRpb25zICYmIG9wdGlvbnMucmVjdGFuZ2xlQ2xhc3MgfHwgdGhpcy5vcHRpb25zLnJlY3RhbmdsZUNsYXNzLCBib3VuZHMsIG9wdGlvbnMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNyZWF0ZUNpcmNsZTogZnVuY3Rpb24gKGxhdGxuZywgb3B0aW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlTGF5ZXIob3B0aW9ucyAmJiBvcHRpb25zLmNpcmNsZUNsYXNzIHx8IHRoaXMub3B0aW9ucy5jaXJjbGVDbGFzcywgbGF0bG5nLCBvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICBMLmV4dGVuZChMLkVkaXRhYmxlLCB7XG5cbiAgICAgICAgbWFrZUNhbmNlbGxhYmxlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS5jYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZS5fY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgLy8g8J+Ngm5hbWVzcGFjZSBNYXA7IPCfjYJjbGFzcyBNYXBcbiAgICAvLyBMZWFmbGV0LkVkaXRhYmxlIGFkZCBvcHRpb25zIGFuZCBldmVudHMgdG8gdGhlIGBMLk1hcGAgb2JqZWN0LlxuICAgIC8vIFNlZSBgRWRpdGFibGVgIGV2ZW50cyBmb3IgdGhlIGxpc3Qgb2YgZXZlbnRzIGZpcmVkIG9uIHRoZSBNYXAuXG4gICAgLy8g8J+NgmV4YW1wbGVcbiAgICAvL1xuICAgIC8vIGBgYGpzXG4gICAgLy8gdmFyIG1hcCA9IEwubWFwKCdtYXAnLCB7XG4gICAgLy8gIGVkaXRhYmxlOiB0cnVlLFxuICAgIC8vICBlZGl0T3B0aW9uczoge1xuICAgIC8vICAgIOKAplxuICAgIC8vIH1cbiAgICAvLyB9KTtcbiAgICAvLyBgYGBcbiAgICAvLyDwn42Cc2VjdGlvbiBFZGl0YWJsZSBNYXAgT3B0aW9uc1xuICAgIEwuTWFwLm1lcmdlT3B0aW9ucyh7XG5cbiAgICAgICAgLy8g8J+Ngm5hbWVzcGFjZSBNYXBcbiAgICAgICAgLy8g8J+NgnNlY3Rpb24gTWFwIE9wdGlvbnNcbiAgICAgICAgLy8g8J+Ngm9wdGlvbiBlZGl0VG9vbHNDbGFzczogY2xhc3MgPSBMLkVkaXRhYmxlXG4gICAgICAgIC8vIENsYXNzIHRvIGJlIHVzZWQgYXMgdmVydGV4LCBmb3IgcGF0aCBlZGl0aW5nLlxuICAgICAgICBlZGl0VG9vbHNDbGFzczogTC5FZGl0YWJsZSxcblxuICAgICAgICAvLyDwn42Cb3B0aW9uIGVkaXRhYmxlOiBib29sZWFuID0gZmFsc2VcbiAgICAgICAgLy8gV2hldGhlciB0byBjcmVhdGUgYSBMLkVkaXRhYmxlIGluc3RhbmNlIGF0IG1hcCBpbml0LlxuICAgICAgICBlZGl0YWJsZTogZmFsc2UsXG5cbiAgICAgICAgLy8g8J+Ngm9wdGlvbiBlZGl0T3B0aW9uczogaGFzaCA9IHt9XG4gICAgICAgIC8vIE9wdGlvbnMgdG8gcGFzcyB0byBMLkVkaXRhYmxlIHdoZW4gaW5zdGFudGlhdGluZy5cbiAgICAgICAgZWRpdE9wdGlvbnM6IHt9XG5cbiAgICB9KTtcblxuICAgIEwuTWFwLmFkZEluaXRIb29rKGZ1bmN0aW9uICgpIHtcblxuICAgICAgICB0aGlzLndoZW5SZWFkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmVkaXRhYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lZGl0VG9vbHMgPSBuZXcgdGhpcy5vcHRpb25zLmVkaXRUb29sc0NsYXNzKHRoaXMsIHRoaXMub3B0aW9ucy5lZGl0T3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgfSk7XG5cbiAgICBMLkVkaXRhYmxlLlZlcnRleEljb24gPSBMLkRpdkljb24uZXh0ZW5kKHtcblxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBpY29uU2l6ZTogbmV3IEwuUG9pbnQoOCwgOClcbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICBMLkVkaXRhYmxlLlRvdWNoVmVydGV4SWNvbiA9IEwuRWRpdGFibGUuVmVydGV4SWNvbi5leHRlbmQoe1xuXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIGljb25TaXplOiBuZXcgTC5Qb2ludCgyMCwgMjApXG4gICAgICAgIH1cblxuICAgIH0pO1xuXG5cbiAgICAvLyDwn42CbmFtZXNwYWNlIEVkaXRhYmxlOyDwn42CY2xhc3MgVmVydGV4TWFya2VyOyBIYW5kbGVyIGZvciBkcmFnZ2luZyBwYXRoIHZlcnRpY2VzLlxuICAgIEwuRWRpdGFibGUuVmVydGV4TWFya2VyID0gTC5NYXJrZXIuZXh0ZW5kKHtcblxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBkcmFnZ2FibGU6IHRydWUsXG4gICAgICAgICAgICBjbGFzc05hbWU6ICdsZWFmbGV0LWRpdi1pY29uIGxlYWZsZXQtdmVydGV4LWljb24nXG4gICAgICAgIH0sXG5cblxuICAgICAgICAvLyDwn42Cc2VjdGlvbiBQdWJsaWMgbWV0aG9kc1xuICAgICAgICAvLyBUaGUgbWFya2VyIHVzZWQgdG8gaGFuZGxlIHBhdGggdmVydGV4LiBZb3Ugd2lsbCB1c3VhbGx5IGludGVyYWN0IHdpdGggYSBgVmVydGV4TWFya2VyYFxuICAgICAgICAvLyBpbnN0YW5jZSB3aGVuIGxpc3RlbmluZyBmb3IgZXZlbnRzIGxpa2UgYGVkaXRhYmxlOnZlcnRleDpjdHJsY2xpY2tgLlxuXG4gICAgICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXRsbmcsIGxhdGxuZ3MsIGVkaXRvciwgb3B0aW9ucykge1xuICAgICAgICAgICAgLy8gV2UgZG9uJ3QgdXNlIHRoaXMuX2xhdGxuZywgYmVjYXVzZSBvbiBkcmFnIExlYWZsZXQgcmVwbGFjZSBpdCB3aGlsZVxuICAgICAgICAgICAgLy8gd2Ugd2FudCB0byBrZWVwIHJlZmVyZW5jZS5cbiAgICAgICAgICAgIHRoaXMubGF0bG5nID0gbGF0bG5nO1xuICAgICAgICAgICAgdGhpcy5sYXRsbmdzID0gbGF0bG5ncztcbiAgICAgICAgICAgIHRoaXMuZWRpdG9yID0gZWRpdG9yO1xuICAgICAgICAgICAgTC5NYXJrZXIucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCBsYXRsbmcsIG9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmljb24gPSB0aGlzLmVkaXRvci50b29scy5jcmVhdGVWZXJ0ZXhJY29uKHtjbGFzc05hbWU6IHRoaXMub3B0aW9ucy5jbGFzc05hbWV9KTtcbiAgICAgICAgICAgIHRoaXMubGF0bG5nLl9fdmVydGV4ID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuZWRpdG9yLmVkaXRMYXllci5hZGRMYXllcih0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuc2V0WkluZGV4T2Zmc2V0KGVkaXRvci50b29scy5fbGFzdFpJbmRleCArIDEpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XG4gICAgICAgICAgICBMLk1hcmtlci5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzLCBtYXApO1xuICAgICAgICAgICAgdGhpcy5vbignZHJhZycsIHRoaXMub25EcmFnKTtcbiAgICAgICAgICAgIHRoaXMub24oJ2RyYWdzdGFydCcsIHRoaXMub25EcmFnU3RhcnQpO1xuICAgICAgICAgICAgdGhpcy5vbignZHJhZ2VuZCcsIHRoaXMub25EcmFnRW5kKTtcbiAgICAgICAgICAgIHRoaXMub24oJ21vdXNldXAnLCB0aGlzLm9uTW91c2V1cCk7XG4gICAgICAgICAgICB0aGlzLm9uKCdjbGljaycsIHRoaXMub25DbGljayk7XG4gICAgICAgICAgICB0aGlzLm9uKCdjb250ZXh0bWVudScsIHRoaXMub25Db250ZXh0TWVudSk7XG4gICAgICAgICAgICB0aGlzLm9uKCdtb3VzZWRvd24gdG91Y2hzdGFydCcsIHRoaXMub25Nb3VzZURvd24pO1xuICAgICAgICAgICAgdGhpcy5vbignbW91c2VvdmVyJywgdGhpcy5vbk1vdXNlT3Zlcik7XG4gICAgICAgICAgICB0aGlzLm9uKCdtb3VzZW91dCcsIHRoaXMub25Nb3VzZU91dCk7XG4gICAgICAgICAgICB0aGlzLmFkZE1pZGRsZU1hcmtlcnMoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubWlkZGxlTWFya2VyKSB0aGlzLm1pZGRsZU1hcmtlci5kZWxldGUoKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmxhdGxuZy5fX3ZlcnRleDtcbiAgICAgICAgICAgIHRoaXMub2ZmKCdkcmFnJywgdGhpcy5vbkRyYWcpO1xuICAgICAgICAgICAgdGhpcy5vZmYoJ2RyYWdzdGFydCcsIHRoaXMub25EcmFnU3RhcnQpO1xuICAgICAgICAgICAgdGhpcy5vZmYoJ2RyYWdlbmQnLCB0aGlzLm9uRHJhZ0VuZCk7XG4gICAgICAgICAgICB0aGlzLm9mZignbW91c2V1cCcsIHRoaXMub25Nb3VzZXVwKTtcbiAgICAgICAgICAgIHRoaXMub2ZmKCdjbGljaycsIHRoaXMub25DbGljayk7XG4gICAgICAgICAgICB0aGlzLm9mZignY29udGV4dG1lbnUnLCB0aGlzLm9uQ29udGV4dE1lbnUpO1xuICAgICAgICAgICAgdGhpcy5vZmYoJ21vdXNlZG93biB0b3VjaHN0YXJ0JywgdGhpcy5vbk1vdXNlRG93bik7XG4gICAgICAgICAgICB0aGlzLm9mZignbW91c2VvdmVyJywgdGhpcy5vbk1vdXNlT3Zlcik7XG4gICAgICAgICAgICB0aGlzLm9mZignbW91c2VvdXQnLCB0aGlzLm9uTW91c2VPdXQpO1xuICAgICAgICAgICAgTC5NYXJrZXIucHJvdG90eXBlLm9uUmVtb3ZlLmNhbGwodGhpcywgbWFwKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvbkRyYWc6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLnZlcnRleCA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmVkaXRvci5vblZlcnRleE1hcmtlckRyYWcoZSk7XG4gICAgICAgICAgICB2YXIgaWNvblBvcyA9IEwuRG9tVXRpbC5nZXRQb3NpdGlvbih0aGlzLl9pY29uKSxcbiAgICAgICAgICAgICAgICBsYXRsbmcgPSB0aGlzLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKGljb25Qb3MpO1xuICAgICAgICAgICAgdGhpcy5sYXRsbmcudXBkYXRlKGxhdGxuZyk7XG4gICAgICAgICAgICB0aGlzLl9sYXRsbmcgPSB0aGlzLmxhdGxuZzsgIC8vIFB1c2ggYmFjayB0byBMZWFmbGV0IG91ciByZWZlcmVuY2UuXG4gICAgICAgICAgICB0aGlzLmVkaXRvci5yZWZyZXNoKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5taWRkbGVNYXJrZXIpIHRoaXMubWlkZGxlTWFya2VyLnVwZGF0ZUxhdExuZygpO1xuICAgICAgICAgICAgdmFyIG5leHQgPSB0aGlzLmdldE5leHQoKTtcbiAgICAgICAgICAgIGlmIChuZXh0ICYmIG5leHQubWlkZGxlTWFya2VyKSBuZXh0Lm1pZGRsZU1hcmtlci51cGRhdGVMYXRMbmcoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvbkRyYWdTdGFydDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUudmVydGV4ID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuZWRpdG9yLm9uVmVydGV4TWFya2VyRHJhZ1N0YXJ0KGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uRHJhZ0VuZDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGUudmVydGV4ID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuZWRpdG9yLm9uVmVydGV4TWFya2VyRHJhZ0VuZChlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvbkNsaWNrOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS52ZXJ0ZXggPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5lZGl0b3Iub25WZXJ0ZXhNYXJrZXJDbGljayhlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvbk1vdXNldXA6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBMLkRvbUV2ZW50LnN0b3AoZSk7XG4gICAgICAgICAgICBlLnZlcnRleCA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmVkaXRvci5tYXAuZmlyZSgnbW91c2V1cCcsIGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uQ29udGV4dE1lbnU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLnZlcnRleCA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmVkaXRvci5vblZlcnRleE1hcmtlckNvbnRleHRNZW51KGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uTW91c2VEb3duOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS52ZXJ0ZXggPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5lZGl0b3Iub25WZXJ0ZXhNYXJrZXJNb3VzZURvd24oZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25Nb3VzZU92ZXI6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLnZlcnRleCA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmVkaXRvci5vblZlcnRleE1hcmtlck1vdXNlT3ZlcihlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvbk1vdXNlT3V0OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS52ZXJ0ZXggPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5lZGl0b3Iub25WZXJ0ZXhNYXJrZXJNb3VzZU91dChlKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyDwn42CbWV0aG9kIGRlbGV0ZSgpXG4gICAgICAgIC8vIERlbGV0ZSBhIHZlcnRleCBhbmQgdGhlIHJlbGF0ZWQgTGF0TG5nLlxuICAgICAgICBkZWxldGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBuZXh0ID0gdGhpcy5nZXROZXh0KCk7ICAvLyBDb21wdXRlIGJlZm9yZSBjaGFuZ2luZyBsYXRsbmdcbiAgICAgICAgICAgIHRoaXMubGF0bG5ncy5zcGxpY2UodGhpcy5nZXRJbmRleCgpLCAxKTtcbiAgICAgICAgICAgIHRoaXMuZWRpdG9yLmVkaXRMYXllci5yZW1vdmVMYXllcih0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuZWRpdG9yLm9uVmVydGV4RGVsZXRlZCh7bGF0bG5nOiB0aGlzLmxhdGxuZywgdmVydGV4OiB0aGlzfSk7XG4gICAgICAgICAgICBpZiAoIXRoaXMubGF0bG5ncy5sZW5ndGgpIHRoaXMuZWRpdG9yLmRlbGV0ZVNoYXBlKHRoaXMubGF0bG5ncyk7XG4gICAgICAgICAgICBpZiAobmV4dCkgbmV4dC5yZXNldE1pZGRsZU1hcmtlcigpO1xuICAgICAgICAgICAgdGhpcy5lZGl0b3IucmVmcmVzaCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIPCfjYJtZXRob2QgZ2V0SW5kZXgoKTogaW50XG4gICAgICAgIC8vIEdldCB0aGUgaW5kZXggb2YgdGhlIGN1cnJlbnQgdmVydGV4IGFtb25nIG90aGVycyBvZiB0aGUgc2FtZSBMYXRMbmdzIGdyb3VwLlxuICAgICAgICBnZXRJbmRleDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGF0bG5ncy5pbmRleE9mKHRoaXMubGF0bG5nKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyDwn42CbWV0aG9kIGdldExhc3RJbmRleCgpOiBpbnRcbiAgICAgICAgLy8gR2V0IGxhc3QgdmVydGV4IGluZGV4IG9mIHRoZSBMYXRMbmdzIGdyb3VwIG9mIHRoZSBjdXJyZW50IHZlcnRleC5cbiAgICAgICAgZ2V0TGFzdEluZGV4OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sYXRsbmdzLmxlbmd0aCAtIDE7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8g8J+Ngm1ldGhvZCBnZXRQcmV2aW91cygpOiBWZXJ0ZXhNYXJrZXJcbiAgICAgICAgLy8gR2V0IHRoZSBwcmV2aW91cyBWZXJ0ZXhNYXJrZXIgaW4gdGhlIHNhbWUgTGF0TG5ncyBncm91cC5cbiAgICAgICAgZ2V0UHJldmlvdXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxhdGxuZ3MubGVuZ3RoIDwgMikgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5nZXRJbmRleCgpLFxuICAgICAgICAgICAgICAgIHByZXZpb3VzSW5kZXggPSBpbmRleCAtIDE7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IDAgJiYgdGhpcy5lZGl0b3IuQ0xPU0VEKSBwcmV2aW91c0luZGV4ID0gdGhpcy5nZXRMYXN0SW5kZXgoKTtcbiAgICAgICAgICAgIHZhciBwcmV2aW91cyA9IHRoaXMubGF0bG5nc1twcmV2aW91c0luZGV4XTtcbiAgICAgICAgICAgIGlmIChwcmV2aW91cykgcmV0dXJuIHByZXZpb3VzLl9fdmVydGV4O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIPCfjYJtZXRob2QgZ2V0TmV4dCgpOiBWZXJ0ZXhNYXJrZXJcbiAgICAgICAgLy8gR2V0IHRoZSBuZXh0IFZlcnRleE1hcmtlciBpbiB0aGUgc2FtZSBMYXRMbmdzIGdyb3VwLlxuICAgICAgICBnZXROZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5sYXRsbmdzLmxlbmd0aCA8IDIpIHJldHVybjtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuZ2V0SW5kZXgoKSxcbiAgICAgICAgICAgICAgICBuZXh0SW5kZXggPSBpbmRleCArIDE7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IHRoaXMuZ2V0TGFzdEluZGV4KCkgJiYgdGhpcy5lZGl0b3IuQ0xPU0VEKSBuZXh0SW5kZXggPSAwO1xuICAgICAgICAgICAgdmFyIG5leHQgPSB0aGlzLmxhdGxuZ3NbbmV4dEluZGV4XTtcbiAgICAgICAgICAgIGlmIChuZXh0KSByZXR1cm4gbmV4dC5fX3ZlcnRleDtcbiAgICAgICAgfSxcblxuICAgICAgICBhZGRNaWRkbGVNYXJrZXI6IGZ1bmN0aW9uIChwcmV2aW91cykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmVkaXRvci5oYXNNaWRkbGVNYXJrZXJzKCkpIHJldHVybjtcbiAgICAgICAgICAgIHByZXZpb3VzID0gcHJldmlvdXMgfHwgdGhpcy5nZXRQcmV2aW91cygpO1xuICAgICAgICAgICAgaWYgKHByZXZpb3VzICYmICF0aGlzLm1pZGRsZU1hcmtlcikgdGhpcy5taWRkbGVNYXJrZXIgPSB0aGlzLmVkaXRvci5hZGRNaWRkbGVNYXJrZXIocHJldmlvdXMsIHRoaXMsIHRoaXMubGF0bG5ncywgdGhpcy5lZGl0b3IpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFkZE1pZGRsZU1hcmtlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5lZGl0b3IuaGFzTWlkZGxlTWFya2VycygpKSByZXR1cm47XG4gICAgICAgICAgICB2YXIgcHJldmlvdXMgPSB0aGlzLmdldFByZXZpb3VzKCk7XG4gICAgICAgICAgICBpZiAocHJldmlvdXMpIHRoaXMuYWRkTWlkZGxlTWFya2VyKHByZXZpb3VzKTtcbiAgICAgICAgICAgIHZhciBuZXh0ID0gdGhpcy5nZXROZXh0KCk7XG4gICAgICAgICAgICBpZiAobmV4dCkgbmV4dC5yZXNldE1pZGRsZU1hcmtlcigpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlc2V0TWlkZGxlTWFya2VyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5taWRkbGVNYXJrZXIpIHRoaXMubWlkZGxlTWFya2VyLmRlbGV0ZSgpO1xuICAgICAgICAgICAgdGhpcy5hZGRNaWRkbGVNYXJrZXIoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyDwn42CbWV0aG9kIHNwbGl0KClcbiAgICAgICAgLy8gU3BsaXQgdGhlIHZlcnRleCBMYXRMbmdzIGdyb3VwIGF0IGl0cyBpbmRleCwgaWYgcG9zc2libGUuXG4gICAgICAgIHNwbGl0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZWRpdG9yLnNwbGl0U2hhcGUpIHJldHVybjsgIC8vIE9ubHkgZm9yIFBvbHlsaW5lRWRpdG9yXG4gICAgICAgICAgICB0aGlzLmVkaXRvci5zcGxpdFNoYXBlKHRoaXMubGF0bG5ncywgdGhpcy5nZXRJbmRleCgpKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyDwn42CbWV0aG9kIGNvbnRpbnVlKClcbiAgICAgICAgLy8gQ29udGludWUgdGhlIHZlcnRleCBMYXRMbmdzIGZyb20gdGhpcyB2ZXJ0ZXguIE9ubHkgYWN0aXZlIGZvciBmaXJzdCBhbmQgbGFzdCB2ZXJ0aWNlcyBvZiBhIFBvbHlsaW5lLlxuICAgICAgICBjb250aW51ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmVkaXRvci5jb250aW51ZUJhY2t3YXJkKSByZXR1cm47ICAvLyBPbmx5IGZvciBQb2x5bGluZUVkaXRvclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5nZXRJbmRleCgpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09PSAwKSB0aGlzLmVkaXRvci5jb250aW51ZUJhY2t3YXJkKHRoaXMubGF0bG5ncyk7XG4gICAgICAgICAgICBlbHNlIGlmIChpbmRleCA9PT0gdGhpcy5nZXRMYXN0SW5kZXgoKSkgdGhpcy5lZGl0b3IuY29udGludWVGb3J3YXJkKHRoaXMubGF0bG5ncyk7XG4gICAgICAgIH1cblxuICAgIH0pO1xuXG4gICAgTC5FZGl0YWJsZS5tZXJnZU9wdGlvbnMoe1xuXG4gICAgICAgIC8vIPCfjYJuYW1lc3BhY2UgRWRpdGFibGVcbiAgICAgICAgLy8g8J+Ngm9wdGlvbiB2ZXJ0ZXhNYXJrZXJDbGFzczogY2xhc3MgPSBWZXJ0ZXhNYXJrZXJcbiAgICAgICAgLy8gQ2xhc3MgdG8gYmUgdXNlZCBhcyB2ZXJ0ZXgsIGZvciBwYXRoIGVkaXRpbmcuXG4gICAgICAgIHZlcnRleE1hcmtlckNsYXNzOiBMLkVkaXRhYmxlLlZlcnRleE1hcmtlclxuXG4gICAgfSk7XG5cbiAgICBMLkVkaXRhYmxlLk1pZGRsZU1hcmtlciA9IEwuTWFya2VyLmV4dGVuZCh7XG5cbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgb3BhY2l0eTogMC41LFxuICAgICAgICAgICAgY2xhc3NOYW1lOiAnbGVhZmxldC1kaXYtaWNvbiBsZWFmbGV0LW1pZGRsZS1pY29uJyxcbiAgICAgICAgICAgIGRyYWdnYWJsZTogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIChsZWZ0LCByaWdodCwgbGF0bG5ncywgZWRpdG9yLCBvcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgICAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xuICAgICAgICAgICAgdGhpcy5lZGl0b3IgPSBlZGl0b3I7XG4gICAgICAgICAgICB0aGlzLmxhdGxuZ3MgPSBsYXRsbmdzO1xuICAgICAgICAgICAgTC5NYXJrZXIucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCB0aGlzLmNvbXB1dGVMYXRMbmcoKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLl9vcGFjaXR5ID0gdGhpcy5vcHRpb25zLm9wYWNpdHk7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuaWNvbiA9IHRoaXMuZWRpdG9yLnRvb2xzLmNyZWF0ZVZlcnRleEljb24oe2NsYXNzTmFtZTogdGhpcy5vcHRpb25zLmNsYXNzTmFtZX0pO1xuICAgICAgICAgICAgdGhpcy5lZGl0b3IuZWRpdExheWVyLmFkZExheWVyKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5zZXRWaXNpYmlsaXR5KCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0VmlzaWJpbGl0eTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGxlZnRQb2ludCA9IHRoaXMuX21hcC5sYXRMbmdUb0NvbnRhaW5lclBvaW50KHRoaXMubGVmdC5sYXRsbmcpLFxuICAgICAgICAgICAgICAgIHJpZ2h0UG9pbnQgPSB0aGlzLl9tYXAubGF0TG5nVG9Db250YWluZXJQb2ludCh0aGlzLnJpZ2h0LmxhdGxuZyksXG4gICAgICAgICAgICAgICAgc2l6ZSA9IEwucG9pbnQodGhpcy5vcHRpb25zLmljb24ub3B0aW9ucy5pY29uU2l6ZSk7XG4gICAgICAgICAgICBpZiAobGVmdFBvaW50LmRpc3RhbmNlVG8ocmlnaHRQb2ludCkgPCBzaXplLnggKiAzKSB0aGlzLmhpZGUoKTtcbiAgICAgICAgICAgIGVsc2UgdGhpcy5zaG93KCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2hvdzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5zZXRPcGFjaXR5KHRoaXMuX29wYWNpdHkpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhpZGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0T3BhY2l0eSgwKTtcbiAgICAgICAgfSxcblxuICAgICAgICB1cGRhdGVMYXRMbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0TGF0TG5nKHRoaXMuY29tcHV0ZUxhdExuZygpKTtcbiAgICAgICAgICAgIHRoaXMuc2V0VmlzaWJpbGl0eSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNvbXB1dGVMYXRMbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBsZWZ0UG9pbnQgPSB0aGlzLmVkaXRvci5tYXAubGF0TG5nVG9Db250YWluZXJQb2ludCh0aGlzLmxlZnQubGF0bG5nKSxcbiAgICAgICAgICAgICAgICByaWdodFBvaW50ID0gdGhpcy5lZGl0b3IubWFwLmxhdExuZ1RvQ29udGFpbmVyUG9pbnQodGhpcy5yaWdodC5sYXRsbmcpLFxuICAgICAgICAgICAgICAgIHkgPSAobGVmdFBvaW50LnkgKyByaWdodFBvaW50LnkpIC8gMixcbiAgICAgICAgICAgICAgICB4ID0gKGxlZnRQb2ludC54ICsgcmlnaHRQb2ludC54KSAvIDI7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lZGl0b3IubWFwLmNvbnRhaW5lclBvaW50VG9MYXRMbmcoW3gsIHldKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xuICAgICAgICAgICAgTC5NYXJrZXIucHJvdG90eXBlLm9uQWRkLmNhbGwodGhpcywgbWFwKTtcbiAgICAgICAgICAgIEwuRG9tRXZlbnQub24odGhpcy5faWNvbiwgJ21vdXNlZG93biB0b3VjaHN0YXJ0JywgdGhpcy5vbk1vdXNlRG93biwgdGhpcyk7XG4gICAgICAgICAgICBtYXAub24oJ3pvb21lbmQnLCB0aGlzLnNldFZpc2liaWxpdHksIHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5yaWdodC5taWRkbGVNYXJrZXI7XG4gICAgICAgICAgICBMLkRvbUV2ZW50Lm9mZih0aGlzLl9pY29uLCAnbW91c2Vkb3duIHRvdWNoc3RhcnQnLCB0aGlzLm9uTW91c2VEb3duLCB0aGlzKTtcbiAgICAgICAgICAgIG1hcC5vZmYoJ3pvb21lbmQnLCB0aGlzLnNldFZpc2liaWxpdHksIHRoaXMpO1xuICAgICAgICAgICAgTC5NYXJrZXIucHJvdG90eXBlLm9uUmVtb3ZlLmNhbGwodGhpcywgbWFwKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvbk1vdXNlRG93bjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciBpY29uUG9zID0gTC5Eb21VdGlsLmdldFBvc2l0aW9uKHRoaXMuX2ljb24pLFxuICAgICAgICAgICAgICAgIGxhdGxuZyA9IHRoaXMuZWRpdG9yLm1hcC5sYXllclBvaW50VG9MYXRMbmcoaWNvblBvcyk7XG4gICAgICAgICAgICBlID0ge1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGUsXG4gICAgICAgICAgICAgICAgbGF0bG5nOiBsYXRsbmdcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLm9wYWNpdHkgPT09IDApIHJldHVybjtcbiAgICAgICAgICAgIEwuRWRpdGFibGUubWFrZUNhbmNlbGxhYmxlKGUpO1xuICAgICAgICAgICAgdGhpcy5lZGl0b3Iub25NaWRkbGVNYXJrZXJNb3VzZURvd24oZSk7XG4gICAgICAgICAgICBpZiAoZS5fY2FuY2VsbGVkKSByZXR1cm47XG4gICAgICAgICAgICB0aGlzLmxhdGxuZ3Muc3BsaWNlKHRoaXMuaW5kZXgoKSwgMCwgZS5sYXRsbmcpO1xuICAgICAgICAgICAgdGhpcy5lZGl0b3IucmVmcmVzaCgpO1xuICAgICAgICAgICAgdmFyIGljb24gPSB0aGlzLl9pY29uO1xuICAgICAgICAgICAgdmFyIG1hcmtlciA9IHRoaXMuZWRpdG9yLmFkZFZlcnRleE1hcmtlcihlLmxhdGxuZywgdGhpcy5sYXRsbmdzKTtcbiAgICAgICAgICAgIHRoaXMuZWRpdG9yLm9uTmV3VmVydGV4KG1hcmtlcik7XG4gICAgICAgICAgICAvKiBIYWNrIHRvIHdvcmthcm91bmQgYnJvd3NlciBub3QgZmlyaW5nIHRvdWNoZW5kIHdoZW4gZWxlbWVudCBpcyBubyBtb3JlIG9uIERPTSAqL1xuICAgICAgICAgICAgdmFyIHBhcmVudCA9IG1hcmtlci5faWNvbi5wYXJlbnROb2RlO1xuICAgICAgICAgICAgcGFyZW50LnJlbW92ZUNoaWxkKG1hcmtlci5faWNvbik7XG4gICAgICAgICAgICBtYXJrZXIuX2ljb24gPSBpY29uO1xuICAgICAgICAgICAgcGFyZW50LmFwcGVuZENoaWxkKG1hcmtlci5faWNvbik7XG4gICAgICAgICAgICBtYXJrZXIuX2luaXRJY29uKCk7XG4gICAgICAgICAgICBtYXJrZXIuX2luaXRJbnRlcmFjdGlvbigpO1xuICAgICAgICAgICAgbWFya2VyLnNldE9wYWNpdHkoMSk7XG4gICAgICAgICAgICAvKiBFbmQgaGFjayAqL1xuICAgICAgICAgICAgLy8gVHJhbnNmZXIgb25nb2luZyBkcmFnZ2luZyB0byByZWFsIG1hcmtlclxuICAgICAgICAgICAgTC5EcmFnZ2FibGUuX2RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBtYXJrZXIuZHJhZ2dpbmcuX2RyYWdnYWJsZS5fb25Eb3duKGUub3JpZ2luYWxFdmVudCk7XG4gICAgICAgICAgICB0aGlzLmRlbGV0ZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGRlbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5lZGl0b3IuZWRpdExheWVyLnJlbW92ZUxheWVyKHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGluZGV4OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sYXRsbmdzLmluZGV4T2YodGhpcy5yaWdodC5sYXRsbmcpO1xuICAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIEwuRWRpdGFibGUubWVyZ2VPcHRpb25zKHtcblxuICAgICAgICAvLyDwn42CbmFtZXNwYWNlIEVkaXRhYmxlXG4gICAgICAgIC8vIPCfjYJvcHRpb24gbWlkZGxlTWFya2VyQ2xhc3M6IGNsYXNzID0gVmVydGV4TWFya2VyXG4gICAgICAgIC8vIENsYXNzIHRvIGJlIHVzZWQgYXMgbWlkZGxlIHZlcnRleCwgcHVsbGVkIGJ5IHRoZSB1c2VyIHRvIGNyZWF0ZSBhIG5ldyBwb2ludCBpbiB0aGUgbWlkZGxlIG9mIGEgcGF0aC5cbiAgICAgICAgbWlkZGxlTWFya2VyQ2xhc3M6IEwuRWRpdGFibGUuTWlkZGxlTWFya2VyXG5cbiAgICB9KTtcblxuICAgIC8vIPCfjYJuYW1lc3BhY2UgRWRpdGFibGU7IPCfjYJjbGFzcyBCYXNlRWRpdG9yOyDwn42CYWthIEwuRWRpdGFibGUuQmFzZUVkaXRvclxuICAgIC8vIFdoZW4gZWRpdGluZyBhIGZlYXR1cmUgKE1hcmtlciwgUG9seWxpbmXigKYpLCBhbiBlZGl0b3IgaXMgYXR0YWNoZWQgdG8gaXQuIFRoaXNcbiAgICAvLyBlZGl0b3IgYmFzaWNhbGx5IGtub3dzIGhvdyB0byBoYW5kbGUgdGhlIGVkaXRpb24uXG4gICAgTC5FZGl0YWJsZS5CYXNlRWRpdG9yID0gTC5IYW5kbGVyLmV4dGVuZCh7XG5cbiAgICAgICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcCwgZmVhdHVyZSwgb3B0aW9ucykge1xuICAgICAgICAgICAgTC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5tYXAgPSBtYXA7XG4gICAgICAgICAgICB0aGlzLmZlYXR1cmUgPSBmZWF0dXJlO1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlLmVkaXRvciA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmVkaXRMYXllciA9IG5ldyBMLkxheWVyR3JvdXAoKTtcbiAgICAgICAgICAgIHRoaXMudG9vbHMgPSB0aGlzLm9wdGlvbnMuZWRpdFRvb2xzIHx8IG1hcC5lZGl0VG9vbHM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8g8J+Ngm1ldGhvZCBlbmFibGUoKTogdGhpc1xuICAgICAgICAvLyBTZXQgdXAgdGhlIGRyYXdpbmcgdG9vbHMgZm9yIHRoZSBmZWF0dXJlIHRvIGJlIGVkaXRhYmxlLlxuICAgICAgICBhZGRIb29rczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNDb25uZWN0ZWQoKSkgdGhpcy5vbkZlYXR1cmVBZGQoKTtcbiAgICAgICAgICAgIGVsc2UgdGhpcy5mZWF0dXJlLm9uY2UoJ2FkZCcsIHRoaXMub25GZWF0dXJlQWRkLCB0aGlzKTtcbiAgICAgICAgICAgIHRoaXMub25FbmFibGUoKTtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZS5vbih0aGlzLl9nZXRFdmVudHMoKSwgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8g8J+Ngm1ldGhvZCBkaXNhYmxlKCk6IHRoaXNcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBkcmF3aW5nIHRvb2xzIGZvciB0aGUgZmVhdHVyZS5cbiAgICAgICAgcmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZS5vZmYodGhpcy5fZ2V0RXZlbnRzKCksIHRoaXMpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZmVhdHVyZS5kcmFnZ2luZykgdGhpcy5mZWF0dXJlLmRyYWdnaW5nLmRpc2FibGUoKTtcbiAgICAgICAgICAgIHRoaXMuZWRpdExheWVyLmNsZWFyTGF5ZXJzKCk7XG4gICAgICAgICAgICB0aGlzLnRvb2xzLmVkaXRMYXllci5yZW1vdmVMYXllcih0aGlzLmVkaXRMYXllcik7XG4gICAgICAgICAgICB0aGlzLm9uRGlzYWJsZSgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2RyYXdpbmcpIHRoaXMuY2FuY2VsRHJhd2luZygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIPCfjYJtZXRob2QgZHJhd2luZygpOiBib29sZWFuXG4gICAgICAgIC8vIFJldHVybiB0cnVlIGlmIGFueSBkcmF3aW5nIGFjdGlvbiBpcyBvbmdvaW5nIHdpdGggdGhpcyBlZGl0b3IuXG4gICAgICAgIGRyYXdpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAhIXRoaXMuX2RyYXdpbmc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uICgpIHt9LFxuXG4gICAgICAgIG9uRmVhdHVyZUFkZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy50b29scy5lZGl0TGF5ZXIuYWRkTGF5ZXIodGhpcy5lZGl0TGF5ZXIpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZmVhdHVyZS5kcmFnZ2luZykgdGhpcy5mZWF0dXJlLmRyYWdnaW5nLmVuYWJsZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhc01pZGRsZU1hcmtlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAhdGhpcy5vcHRpb25zLnNraXBNaWRkbGVNYXJrZXJzICYmICF0aGlzLnRvb2xzLm9wdGlvbnMuc2tpcE1pZGRsZU1hcmtlcnM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZmlyZUFuZEZvcndhcmQ6IGZ1bmN0aW9uICh0eXBlLCBlKSB7XG4gICAgICAgICAgICBlID0gZSB8fCB7fTtcbiAgICAgICAgICAgIGUubGF5ZXIgPSB0aGlzLmZlYXR1cmU7XG4gICAgICAgICAgICB0aGlzLmZlYXR1cmUuZmlyZSh0eXBlLCBlKTtcbiAgICAgICAgICAgIHRoaXMudG9vbHMuZmlyZUFuZEZvcndhcmQodHlwZSwgZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25FbmFibGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIPCfjYJuYW1lc3BhY2UgRWRpdGFibGVcbiAgICAgICAgICAgIC8vIPCfjYJldmVudCBlZGl0YWJsZTplbmFibGU6IEV2ZW50XG4gICAgICAgICAgICAvLyBGaXJlZCB3aGVuIGFuIGV4aXN0aW5nIGZlYXR1cmUgaXMgcmVhZHkgdG8gYmUgZWRpdGVkLlxuICAgICAgICAgICAgdGhpcy5maXJlQW5kRm9yd2FyZCgnZWRpdGFibGU6ZW5hYmxlJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25EaXNhYmxlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyDwn42CbmFtZXNwYWNlIEVkaXRhYmxlXG4gICAgICAgICAgICAvLyDwn42CZXZlbnQgZWRpdGFibGU6ZGlzYWJsZTogRXZlbnRcbiAgICAgICAgICAgIC8vIEZpcmVkIHdoZW4gYW4gZXhpc3RpbmcgZmVhdHVyZSBpcyBub3QgcmVhZHkgYW55bW9yZSB0byBiZSBlZGl0ZWQuXG4gICAgICAgICAgICB0aGlzLmZpcmVBbmRGb3J3YXJkKCdlZGl0YWJsZTpkaXNhYmxlJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25FZGl0aW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyDwn42CbmFtZXNwYWNlIEVkaXRhYmxlXG4gICAgICAgICAgICAvLyDwn42CZXZlbnQgZWRpdGFibGU6ZWRpdGluZzogRXZlbnRcbiAgICAgICAgICAgIC8vIEZpcmVkIGFzIHNvb24gYXMgYW55IGNoYW5nZSBpcyBtYWRlIHRvIHRoZSBmZWF0dXJlIGdlb21ldHJ5LlxuICAgICAgICAgICAgdGhpcy5maXJlQW5kRm9yd2FyZCgnZWRpdGFibGU6ZWRpdGluZycpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uU3RhcnREcmF3aW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyDwn42CbmFtZXNwYWNlIEVkaXRhYmxlXG4gICAgICAgICAgICAvLyDwn42Cc2VjdGlvbiBEcmF3aW5nIGV2ZW50c1xuICAgICAgICAgICAgLy8g8J+NgmV2ZW50IGVkaXRhYmxlOmRyYXdpbmc6c3RhcnQ6IEV2ZW50XG4gICAgICAgICAgICAvLyBGaXJlZCB3aGVuIGEgZmVhdHVyZSBpcyB0byBiZSBkcmF3bi5cbiAgICAgICAgICAgIHRoaXMuZmlyZUFuZEZvcndhcmQoJ2VkaXRhYmxlOmRyYXdpbmc6c3RhcnQnKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvbkVuZERyYXdpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIPCfjYJuYW1lc3BhY2UgRWRpdGFibGVcbiAgICAgICAgICAgIC8vIPCfjYJzZWN0aW9uIERyYXdpbmcgZXZlbnRzXG4gICAgICAgICAgICAvLyDwn42CZXZlbnQgZWRpdGFibGU6ZHJhd2luZzplbmQ6IEV2ZW50XG4gICAgICAgICAgICAvLyBGaXJlZCB3aGVuIGEgZmVhdHVyZSBpcyBub3QgZHJhd24gYW55bW9yZS5cbiAgICAgICAgICAgIHRoaXMuZmlyZUFuZEZvcndhcmQoJ2VkaXRhYmxlOmRyYXdpbmc6ZW5kJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25DYW5jZWxEcmF3aW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyDwn42CbmFtZXNwYWNlIEVkaXRhYmxlXG4gICAgICAgICAgICAvLyDwn42Cc2VjdGlvbiBEcmF3aW5nIGV2ZW50c1xuICAgICAgICAgICAgLy8g8J+NgmV2ZW50IGVkaXRhYmxlOmRyYXdpbmc6Y2FuY2VsOiBFdmVudFxuICAgICAgICAgICAgLy8gRmlyZWQgd2hlbiB1c2VyIGNhbmNlbCBkcmF3aW5nIHdoaWxlIGEgZmVhdHVyZSBpcyBiZWluZyBkcmF3bi5cbiAgICAgICAgICAgIHRoaXMuZmlyZUFuZEZvcndhcmQoJ2VkaXRhYmxlOmRyYXdpbmc6Y2FuY2VsJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25Db21taXREcmF3aW5nOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgLy8g8J+Ngm5hbWVzcGFjZSBFZGl0YWJsZVxuICAgICAgICAgICAgLy8g8J+NgnNlY3Rpb24gRHJhd2luZyBldmVudHNcbiAgICAgICAgICAgIC8vIPCfjYJldmVudCBlZGl0YWJsZTpkcmF3aW5nOmNvbW1pdDogRXZlbnRcbiAgICAgICAgICAgIC8vIEZpcmVkIHdoZW4gdXNlciBmaW5pc2ggZHJhd2luZyBhIGZlYXR1cmUuXG4gICAgICAgICAgICB0aGlzLmZpcmVBbmRGb3J3YXJkKCdlZGl0YWJsZTpkcmF3aW5nOmNvbW1pdCcsIGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uRHJhd2luZ01vdXNlRG93bjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIC8vIPCfjYJuYW1lc3BhY2UgRWRpdGFibGVcbiAgICAgICAgICAgIC8vIPCfjYJzZWN0aW9uIERyYXdpbmcgZXZlbnRzXG4gICAgICAgICAgICAvLyDwn42CZXZlbnQgZWRpdGFibGU6ZHJhd2luZzptb3VzZWRvd246IEV2ZW50XG4gICAgICAgICAgICAvLyBGaXJlZCB3aGVuIHVzZXIgYG1vdXNlZG93bmAgd2hpbGUgZHJhd2luZy5cbiAgICAgICAgICAgIHRoaXMuZmlyZUFuZEZvcndhcmQoJ2VkaXRhYmxlOmRyYXdpbmc6bW91c2Vkb3duJywgZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25EcmF3aW5nTW91c2VVcDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIC8vIPCfjYJuYW1lc3BhY2UgRWRpdGFibGVcbiAgICAgICAgICAgIC8vIPCfjYJzZWN0aW9uIERyYXdpbmcgZXZlbnRzXG4gICAgICAgICAgICAvLyDwn42CZXZlbnQgZWRpdGFibGU6ZHJhd2luZzptb3VzZXVwOiBFdmVudFxuICAgICAgICAgICAgLy8gRmlyZWQgd2hlbiB1c2VyIGBtb3VzZXVwYCB3aGlsZSBkcmF3aW5nLlxuICAgICAgICAgICAgdGhpcy5maXJlQW5kRm9yd2FyZCgnZWRpdGFibGU6ZHJhd2luZzptb3VzZXVwJywgZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc3RhcnREcmF3aW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2RyYXdpbmcpIHRoaXMuX2RyYXdpbmcgPSBMLkVkaXRhYmxlLkZPUldBUkQ7XG4gICAgICAgICAgICB0aGlzLnRvb2xzLnJlZ2lzdGVyRm9yRHJhd2luZyh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMub25TdGFydERyYXdpbmcoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjb21taXREcmF3aW5nOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdGhpcy5vbkNvbW1pdERyYXdpbmcoZSk7XG4gICAgICAgICAgICB0aGlzLmVuZERyYXdpbmcoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjYW5jZWxEcmF3aW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBJZiBjYWxsZWQgZHVyaW5nIGEgdmVydGV4IGRyYWcsIHRoZSB2ZXJ0ZXggd2lsbCBiZSByZW1vdmVkIGJlZm9yZVxuICAgICAgICAgICAgLy8gdGhlIG1vdXNldXAgZmlyZXMgb24gaXQuIFRoaXMgaXMgYSB3b3JrYXJvdW5kLiBNYXliZSBiZXR0ZXIgZml4IGlzXG4gICAgICAgICAgICAvLyBUbyBoYXZlIEwuRHJhZ2dhYmxlIHJlc2V0IGl0J3Mgc3RhdHVzIG9uIGRpc2FibGUgKExlYWZsZXQgc2lkZSkuXG4gICAgICAgICAgICBMLkRyYWdnYWJsZS5fZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMub25DYW5jZWxEcmF3aW5nKCk7XG4gICAgICAgICAgICB0aGlzLmVuZERyYXdpbmcoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBlbmREcmF3aW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9kcmF3aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnRvb2xzLnVucmVnaXN0ZXJGb3JEcmF3aW5nKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5vbkVuZERyYXdpbmcoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvbkRyYXdpbmdDbGljazogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5kcmF3aW5nKCkpIHJldHVybjtcbiAgICAgICAgICAgIEwuRWRpdGFibGUubWFrZUNhbmNlbGxhYmxlKGUpO1xuICAgICAgICAgICAgLy8g8J+Ngm5hbWVzcGFjZSBFZGl0YWJsZVxuICAgICAgICAgICAgLy8g8J+NgnNlY3Rpb24gRHJhd2luZyBldmVudHNcbiAgICAgICAgICAgIC8vIPCfjYJldmVudCBlZGl0YWJsZTpkcmF3aW5nOmNsaWNrOiBDYW5jZWxhYmxlRXZlbnRcbiAgICAgICAgICAgIC8vIEZpcmVkIHdoZW4gdXNlciBgY2xpY2tgIHdoaWxlIGRyYXdpbmcsIGJlZm9yZSBhbnkgaW50ZXJuYWwgYWN0aW9uIGlzIGJlaW5nIHByb2Nlc3NlZC5cbiAgICAgICAgICAgIHRoaXMuZmlyZUFuZEZvcndhcmQoJ2VkaXRhYmxlOmRyYXdpbmc6Y2xpY2snLCBlKTtcbiAgICAgICAgICAgIGlmIChlLl9jYW5jZWxsZWQpIHJldHVybjtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0Nvbm5lY3RlZCgpKSB0aGlzLmNvbm5lY3QoZSk7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NEcmF3aW5nQ2xpY2soZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNDb25uZWN0ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hcC5oYXNMYXllcih0aGlzLmZlYXR1cmUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNvbm5lY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMudG9vbHMuY29ubmVjdENyZWF0ZWRUb01hcCh0aGlzLmZlYXR1cmUpO1xuICAgICAgICAgICAgdGhpcy50b29scy5lZGl0TGF5ZXIuYWRkTGF5ZXIodGhpcy5lZGl0TGF5ZXIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uTW92ZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIC8vIPCfjYJuYW1lc3BhY2UgRWRpdGFibGVcbiAgICAgICAgICAgIC8vIPCfjYJzZWN0aW9uIERyYXdpbmcgZXZlbnRzXG4gICAgICAgICAgICAvLyDwn42CZXZlbnQgZWRpdGFibGU6ZHJhd2luZzptb3ZlOiBFdmVudFxuICAgICAgICAgICAgLy8gRmlyZWQgd2hlbiBgbW92ZWAgbW91c2Ugd2hpbGUgZHJhd2luZywgd2hpbGUgZHJhZ2dpbmcgYSBtYXJrZXIsIGFuZCB3aGlsZSBkcmFnZ2luZyBhIHZlcnRleC5cbiAgICAgICAgICAgIHRoaXMuZmlyZUFuZEZvcndhcmQoJ2VkaXRhYmxlOmRyYXdpbmc6bW92ZScsIGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uRHJhd2luZ01vdXNlTW92ZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHRoaXMub25Nb3ZlKGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9nZXRFdmVudHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZHJhZ3N0YXJ0OiB0aGlzLm9uRHJhZ1N0YXJ0LFxuICAgICAgICAgICAgICAgIGRyYWc6IHRoaXMub25EcmFnLFxuICAgICAgICAgICAgICAgIGRyYWdlbmQ6IHRoaXMub25EcmFnRW5kLFxuICAgICAgICAgICAgICAgIHJlbW92ZTogdGhpcy5kaXNhYmxlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uRHJhZ1N0YXJ0OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdGhpcy5vbkVkaXRpbmcoKTtcbiAgICAgICAgICAgIC8vIPCfjYJuYW1lc3BhY2UgRWRpdGFibGVcbiAgICAgICAgICAgIC8vIPCfjYJldmVudCBlZGl0YWJsZTpkcmFnc3RhcnQ6IEV2ZW50XG4gICAgICAgICAgICAvLyBGaXJlZCBiZWZvcmUgYSBwYXRoIGZlYXR1cmUgaXMgZHJhZ2dlZC5cbiAgICAgICAgICAgIHRoaXMuZmlyZUFuZEZvcndhcmQoJ2VkaXRhYmxlOmRyYWdzdGFydCcsIGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uRHJhZzogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHRoaXMub25Nb3ZlKGUpO1xuICAgICAgICAgICAgLy8g8J+Ngm5hbWVzcGFjZSBFZGl0YWJsZVxuICAgICAgICAgICAgLy8g8J+NgmV2ZW50IGVkaXRhYmxlOmRyYWc6IEV2ZW50XG4gICAgICAgICAgICAvLyBGaXJlZCB3aGVuIGEgcGF0aCBmZWF0dXJlIGlzIGJlaW5nIGRyYWdnZWQuXG4gICAgICAgICAgICB0aGlzLmZpcmVBbmRGb3J3YXJkKCdlZGl0YWJsZTpkcmFnJywgZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25EcmFnRW5kOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgLy8g8J+Ngm5hbWVzcGFjZSBFZGl0YWJsZVxuICAgICAgICAgICAgLy8g8J+NgmV2ZW50IGVkaXRhYmxlOmRyYWdlbmQ6IEV2ZW50XG4gICAgICAgICAgICAvLyBGaXJlZCBhZnRlciBhIHBhdGggZmVhdHVyZSBoYXMgYmVlbiBkcmFnZ2VkLlxuICAgICAgICAgICAgdGhpcy5maXJlQW5kRm9yd2FyZCgnZWRpdGFibGU6ZHJhZ2VuZCcsIGUpO1xuICAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIC8vIPCfjYJuYW1lc3BhY2UgRWRpdGFibGU7IPCfjYJjbGFzcyBNYXJrZXJFZGl0b3I7IPCfjYJha2EgTC5FZGl0YWJsZS5NYXJrZXJFZGl0b3JcbiAgICAvLyDwn42CaW5oZXJpdHMgQmFzZUVkaXRvclxuICAgIC8vIEVkaXRvciBmb3IgTWFya2VyLlxuICAgIEwuRWRpdGFibGUuTWFya2VyRWRpdG9yID0gTC5FZGl0YWJsZS5CYXNlRWRpdG9yLmV4dGVuZCh7XG5cbiAgICAgICAgb25EcmF3aW5nTW91c2VNb3ZlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgTC5FZGl0YWJsZS5CYXNlRWRpdG9yLnByb3RvdHlwZS5vbkRyYXdpbmdNb3VzZU1vdmUuY2FsbCh0aGlzLCBlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9kcmF3aW5nKSB0aGlzLmZlYXR1cmUuc2V0TGF0TG5nKGUubGF0bG5nKTtcbiAgICAgICAgfSxcblxuICAgICAgICBwcm9jZXNzRHJhd2luZ0NsaWNrOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgLy8g8J+Ngm5hbWVzcGFjZSBFZGl0YWJsZVxuICAgICAgICAgICAgLy8g8J+NgnNlY3Rpb24gRHJhd2luZyBldmVudHNcbiAgICAgICAgICAgIC8vIPCfjYJldmVudCBlZGl0YWJsZTpkcmF3aW5nOmNsaWNrZWQ6IEV2ZW50XG4gICAgICAgICAgICAvLyBGaXJlZCB3aGVuIHVzZXIgYGNsaWNrYCB3aGlsZSBkcmF3aW5nLCBhZnRlciBhbGwgaW50ZXJuYWwgYWN0aW9ucy5cbiAgICAgICAgICAgIHRoaXMuZmlyZUFuZEZvcndhcmQoJ2VkaXRhYmxlOmRyYXdpbmc6Y2xpY2tlZCcsIGUpO1xuICAgICAgICAgICAgdGhpcy5jb21taXREcmF3aW5nKGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNvbm5lY3Q6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAvLyBPbiB0b3VjaCwgdGhlIGxhdGxuZyBoYXMgbm90IGJlZW4gdXBkYXRlZCBiZWNhdXNlIHRoZXJlIGlzXG4gICAgICAgICAgICAvLyBubyBtb3VzZW1vdmUuXG4gICAgICAgICAgICBpZiAoZSkgdGhpcy5mZWF0dXJlLl9sYXRsbmcgPSBlLmxhdGxuZztcbiAgICAgICAgICAgIEwuRWRpdGFibGUuQmFzZUVkaXRvci5wcm90b3R5cGUuY29ubmVjdC5jYWxsKHRoaXMsIGUpO1xuICAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIC8vIPCfjYJuYW1lc3BhY2UgRWRpdGFibGU7IPCfjYJjbGFzcyBQYXRoRWRpdG9yOyDwn42CYWthIEwuRWRpdGFibGUuUGF0aEVkaXRvclxuICAgIC8vIPCfjYJpbmhlcml0cyBCYXNlRWRpdG9yXG4gICAgLy8gQmFzZSBjbGFzcyBmb3IgYWxsIHBhdGggZWRpdG9ycy5cbiAgICBMLkVkaXRhYmxlLlBhdGhFZGl0b3IgPSBMLkVkaXRhYmxlLkJhc2VFZGl0b3IuZXh0ZW5kKHtcblxuICAgICAgICBDTE9TRUQ6IGZhbHNlLFxuICAgICAgICBNSU5fVkVSVEVYOiAyLFxuXG4gICAgICAgIGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBMLkVkaXRhYmxlLkJhc2VFZGl0b3IucHJvdG90eXBlLmFkZEhvb2tzLmNhbGwodGhpcyk7XG4gICAgICAgICAgICBpZiAodGhpcy5mZWF0dXJlKSB0aGlzLmluaXRWZXJ0ZXhNYXJrZXJzKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBpbml0VmVydGV4TWFya2VyczogZnVuY3Rpb24gKGxhdGxuZ3MpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5lbmFibGVkKCkpIHJldHVybjtcbiAgICAgICAgICAgIGxhdGxuZ3MgPSBsYXRsbmdzIHx8IHRoaXMuZ2V0TGF0TG5ncygpO1xuICAgICAgICAgICAgaWYgKGlzRmxhdChsYXRsbmdzKSkgdGhpcy5hZGRWZXJ0ZXhNYXJrZXJzKGxhdGxuZ3MpO1xuICAgICAgICAgICAgZWxzZSBmb3IgKHZhciBpID0gMDsgaSA8IGxhdGxuZ3MubGVuZ3RoOyBpKyspIHRoaXMuaW5pdFZlcnRleE1hcmtlcnMobGF0bG5nc1tpXSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0TGF0TG5nczogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmVhdHVyZS5nZXRMYXRMbmdzKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8g8J+Ngm1ldGhvZCByZXNldCgpXG4gICAgICAgIC8vIFJlYnVpbGQgZWRpdCBlbGVtZW50cyAoVmVydGV4LCBNaWRkbGVNYXJrZXIsIGV0Yy4pLlxuICAgICAgICByZXNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5lZGl0TGF5ZXIuY2xlYXJMYXllcnMoKTtcbiAgICAgICAgICAgIHRoaXMuaW5pdFZlcnRleE1hcmtlcnMoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBhZGRWZXJ0ZXhNYXJrZXI6IGZ1bmN0aW9uIChsYXRsbmcsIGxhdGxuZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgdGhpcy50b29scy5vcHRpb25zLnZlcnRleE1hcmtlckNsYXNzKGxhdGxuZywgbGF0bG5ncywgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25OZXdWZXJ0ZXg6IGZ1bmN0aW9uICh2ZXJ0ZXgpIHtcbiAgICAgICAgICAgIC8vIPCfjYJuYW1lc3BhY2UgRWRpdGFibGVcbiAgICAgICAgICAgIC8vIPCfjYJzZWN0aW9uIFZlcnRleCBldmVudHNcbiAgICAgICAgICAgIC8vIPCfjYJldmVudCBlZGl0YWJsZTp2ZXJ0ZXg6bmV3OiBWZXJ0ZXhFdmVudFxuICAgICAgICAgICAgLy8gRmlyZWQgd2hlbiBhIG5ldyB2ZXJ0ZXggaXMgY3JlYXRlZC5cbiAgICAgICAgICAgIHRoaXMuZmlyZUFuZEZvcndhcmQoJ2VkaXRhYmxlOnZlcnRleDpuZXcnLCB7bGF0bG5nOiB2ZXJ0ZXgubGF0bG5nLCB2ZXJ0ZXg6IHZlcnRleH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFkZFZlcnRleE1hcmtlcnM6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhdGxuZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFZlcnRleE1hcmtlcihsYXRsbmdzW2ldLCBsYXRsbmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICByZWZyZXNoVmVydGV4TWFya2VyczogZnVuY3Rpb24gKGxhdGxuZ3MpIHtcbiAgICAgICAgICAgIGxhdGxuZ3MgPSBsYXRsbmdzIHx8IHRoaXMuZ2V0RGVmYXVsdExhdExuZ3MoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF0bG5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxhdGxuZ3NbaV0uX192ZXJ0ZXgudXBkYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWRkTWlkZGxlTWFya2VyOiBmdW5jdGlvbiAobGVmdCwgcmlnaHQsIGxhdGxuZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgdGhpcy50b29scy5vcHRpb25zLm1pZGRsZU1hcmtlckNsYXNzKGxlZnQsIHJpZ2h0LCBsYXRsbmdzLCB0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvblZlcnRleE1hcmtlckNsaWNrOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgTC5FZGl0YWJsZS5tYWtlQ2FuY2VsbGFibGUoZSk7XG4gICAgICAgICAgICAvLyDwn42CbmFtZXNwYWNlIEVkaXRhYmxlXG4gICAgICAgICAgICAvLyDwn42Cc2VjdGlvbiBWZXJ0ZXggZXZlbnRzXG4gICAgICAgICAgICAvLyDwn42CZXZlbnQgZWRpdGFibGU6dmVydGV4OmNsaWNrOiBDYW5jZWxhYmxlVmVydGV4RXZlbnRcbiAgICAgICAgICAgIC8vIEZpcmVkIHdoZW4gYSBgY2xpY2tgIGlzIGlzc3VlZCBvbiBhIHZlcnRleCwgYmVmb3JlIGFueSBpbnRlcm5hbCBhY3Rpb24gaXMgYmVpbmcgcHJvY2Vzc2VkLlxuICAgICAgICAgICAgdGhpcy5maXJlQW5kRm9yd2FyZCgnZWRpdGFibGU6dmVydGV4OmNsaWNrJywgZSk7XG4gICAgICAgICAgICBpZiAoZS5fY2FuY2VsbGVkKSByZXR1cm47XG4gICAgICAgICAgICBpZiAodGhpcy50b29scy5kcmF3aW5nKCkgJiYgdGhpcy50b29scy5fZHJhd2luZ0VkaXRvciAhPT0gdGhpcykgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gZS52ZXJ0ZXguZ2V0SW5kZXgoKSwgY29tbWl0O1xuICAgICAgICAgICAgaWYgKGUub3JpZ2luYWxFdmVudC5jdHJsS2V5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vblZlcnRleE1hcmtlckN0cmxDbGljayhlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZS5vcmlnaW5hbEV2ZW50LmFsdEtleSkge1xuICAgICAgICAgICAgICAgIHRoaXMub25WZXJ0ZXhNYXJrZXJBbHRDbGljayhlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZS5vcmlnaW5hbEV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vblZlcnRleE1hcmtlclNoaWZ0Q2xpY2soZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGUub3JpZ2luYWxFdmVudC5tZXRhS2V5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vblZlcnRleE1hcmtlck1ldGFLZXlDbGljayhlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPT09IGUudmVydGV4LmdldExhc3RJbmRleCgpICYmIHRoaXMuX2RyYXdpbmcgPT09IEwuRWRpdGFibGUuRk9SV0FSRCkge1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA+PSB0aGlzLk1JTl9WRVJURVggLSAxKSBjb21taXQgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpbmRleCA9PT0gMCAmJiB0aGlzLl9kcmF3aW5nID09PSBMLkVkaXRhYmxlLkJBQ0tXQVJEICYmIHRoaXMuX2RyYXduTGF0TG5ncy5sZW5ndGggPj0gdGhpcy5NSU5fVkVSVEVYKSB7XG4gICAgICAgICAgICAgICAgY29tbWl0ID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPT09IDAgJiYgdGhpcy5fZHJhd2luZyA9PT0gTC5FZGl0YWJsZS5GT1JXQVJEICYmIHRoaXMuX2RyYXduTGF0TG5ncy5sZW5ndGggPj0gdGhpcy5NSU5fVkVSVEVYICYmIHRoaXMuQ0xPU0VEKSB7XG4gICAgICAgICAgICAgICAgY29tbWl0ID0gdHJ1ZTsgIC8vIEFsbG93IHRvIGNsb3NlIG9uIGZpcnN0IHBvaW50IGFsc28gZm9yIHBvbHlnb25zXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMub25WZXJ0ZXhSYXdNYXJrZXJDbGljayhlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIPCfjYJuYW1lc3BhY2UgRWRpdGFibGVcbiAgICAgICAgICAgIC8vIPCfjYJzZWN0aW9uIFZlcnRleCBldmVudHNcbiAgICAgICAgICAgIC8vIPCfjYJldmVudCBlZGl0YWJsZTp2ZXJ0ZXg6Y2xpY2tlZDogVmVydGV4RXZlbnRcbiAgICAgICAgICAgIC8vIEZpcmVkIHdoZW4gYSBgY2xpY2tgIGlzIGlzc3VlZCBvbiBhIHZlcnRleCwgYWZ0ZXIgYWxsIGludGVybmFsIGFjdGlvbnMuXG4gICAgICAgICAgICB0aGlzLmZpcmVBbmRGb3J3YXJkKCdlZGl0YWJsZTp2ZXJ0ZXg6Y2xpY2tlZCcsIGUpO1xuICAgICAgICAgICAgaWYgKGNvbW1pdCkgdGhpcy5jb21taXREcmF3aW5nKGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uVmVydGV4UmF3TWFya2VyQ2xpY2s6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAvLyDwn42CbmFtZXNwYWNlIEVkaXRhYmxlXG4gICAgICAgICAgICAvLyDwn42Cc2VjdGlvbiBWZXJ0ZXggZXZlbnRzXG4gICAgICAgICAgICAvLyDwn42CZXZlbnQgZWRpdGFibGU6dmVydGV4OnJhd2NsaWNrOiBDYW5jZWxhYmxlVmVydGV4RXZlbnRcbiAgICAgICAgICAgIC8vIEZpcmVkIHdoZW4gYSBgY2xpY2tgIGlzIGlzc3VlZCBvbiBhIHZlcnRleCB3aXRob3V0IGFueSBzcGVjaWFsIGtleSBhbmQgd2l0aG91dCBiZWluZyBpbiBkcmF3aW5nIG1vZGUuXG4gICAgICAgICAgICB0aGlzLmZpcmVBbmRGb3J3YXJkKCdlZGl0YWJsZTp2ZXJ0ZXg6cmF3Y2xpY2snLCBlKTtcbiAgICAgICAgICAgIGlmIChlLl9jYW5jZWxsZWQpIHJldHVybjtcbiAgICAgICAgICAgIGlmICghdGhpcy52ZXJ0ZXhDYW5CZURlbGV0ZWQoZS52ZXJ0ZXgpKSByZXR1cm47XG4gICAgICAgICAgICBlLnZlcnRleC5kZWxldGUoKTtcbiAgICAgICAgfSxcblxuICAgICAgICB2ZXJ0ZXhDYW5CZURlbGV0ZWQ6IGZ1bmN0aW9uICh2ZXJ0ZXgpIHtcbiAgICAgICAgICAgIHJldHVybiB2ZXJ0ZXgubGF0bG5ncy5sZW5ndGggPiB0aGlzLk1JTl9WRVJURVg7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25WZXJ0ZXhEZWxldGVkOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgLy8g8J+Ngm5hbWVzcGFjZSBFZGl0YWJsZVxuICAgICAgICAgICAgLy8g8J+NgnNlY3Rpb24gVmVydGV4IGV2ZW50c1xuICAgICAgICAgICAgLy8g8J+NgmV2ZW50IGVkaXRhYmxlOnZlcnRleDpkZWxldGVkOiBWZXJ0ZXhFdmVudFxuICAgICAgICAgICAgLy8gRmlyZWQgYWZ0ZXIgYSB2ZXJ0ZXggaGFzIGJlZW4gZGVsZXRlZCBieSB1c2VyLlxuICAgICAgICAgICAgdGhpcy5maXJlQW5kRm9yd2FyZCgnZWRpdGFibGU6dmVydGV4OmRlbGV0ZWQnLCBlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvblZlcnRleE1hcmtlckN0cmxDbGljazogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIC8vIPCfjYJuYW1lc3BhY2UgRWRpdGFibGVcbiAgICAgICAgICAgIC8vIPCfjYJzZWN0aW9uIFZlcnRleCBldmVudHNcbiAgICAgICAgICAgIC8vIPCfjYJldmVudCBlZGl0YWJsZTp2ZXJ0ZXg6Y3RybGNsaWNrOiBWZXJ0ZXhFdmVudFxuICAgICAgICAgICAgLy8gRmlyZWQgd2hlbiBhIGBjbGlja2Agd2l0aCBgY3RybEtleWAgaXMgaXNzdWVkIG9uIGEgdmVydGV4LlxuICAgICAgICAgICAgdGhpcy5maXJlQW5kRm9yd2FyZCgnZWRpdGFibGU6dmVydGV4OmN0cmxjbGljaycsIGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uVmVydGV4TWFya2VyU2hpZnRDbGljazogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIC8vIPCfjYJuYW1lc3BhY2UgRWRpdGFibGVcbiAgICAgICAgICAgIC8vIPCfjYJzZWN0aW9uIFZlcnRleCBldmVudHNcbiAgICAgICAgICAgIC8vIPCfjYJldmVudCBlZGl0YWJsZTp2ZXJ0ZXg6c2hpZnRjbGljazogVmVydGV4RXZlbnRcbiAgICAgICAgICAgIC8vIEZpcmVkIHdoZW4gYSBgY2xpY2tgIHdpdGggYHNoaWZ0S2V5YCBpcyBpc3N1ZWQgb24gYSB2ZXJ0ZXguXG4gICAgICAgICAgICB0aGlzLmZpcmVBbmRGb3J3YXJkKCdlZGl0YWJsZTp2ZXJ0ZXg6c2hpZnRjbGljaycsIGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uVmVydGV4TWFya2VyTWV0YUtleUNsaWNrOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgLy8g8J+Ngm5hbWVzcGFjZSBFZGl0YWJsZVxuICAgICAgICAgICAgLy8g8J+NgnNlY3Rpb24gVmVydGV4IGV2ZW50c1xuICAgICAgICAgICAgLy8g8J+NgmV2ZW50IGVkaXRhYmxlOnZlcnRleDptZXRha2V5Y2xpY2s6IFZlcnRleEV2ZW50XG4gICAgICAgICAgICAvLyBGaXJlZCB3aGVuIGEgYGNsaWNrYCB3aXRoIGBtZXRhS2V5YCBpcyBpc3N1ZWQgb24gYSB2ZXJ0ZXguXG4gICAgICAgICAgICB0aGlzLmZpcmVBbmRGb3J3YXJkKCdlZGl0YWJsZTp2ZXJ0ZXg6bWV0YWtleWNsaWNrJywgZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25WZXJ0ZXhNYXJrZXJBbHRDbGljazogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIC8vIPCfjYJuYW1lc3BhY2UgRWRpdGFibGVcbiAgICAgICAgICAgIC8vIPCfjYJzZWN0aW9uIFZlcnRleCBldmVudHNcbiAgICAgICAgICAgIC8vIPCfjYJldmVudCBlZGl0YWJsZTp2ZXJ0ZXg6YWx0Y2xpY2s6IFZlcnRleEV2ZW50XG4gICAgICAgICAgICAvLyBGaXJlZCB3aGVuIGEgYGNsaWNrYCB3aXRoIGBhbHRLZXlgIGlzIGlzc3VlZCBvbiBhIHZlcnRleC5cbiAgICAgICAgICAgIHRoaXMuZmlyZUFuZEZvcndhcmQoJ2VkaXRhYmxlOnZlcnRleDphbHRjbGljaycsIGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uVmVydGV4TWFya2VyQ29udGV4dE1lbnU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAvLyDwn42CbmFtZXNwYWNlIEVkaXRhYmxlXG4gICAgICAgICAgICAvLyDwn42Cc2VjdGlvbiBWZXJ0ZXggZXZlbnRzXG4gICAgICAgICAgICAvLyDwn42CZXZlbnQgZWRpdGFibGU6dmVydGV4OmNvbnRleHRtZW51OiBWZXJ0ZXhFdmVudFxuICAgICAgICAgICAgLy8gRmlyZWQgd2hlbiBhIGBjb250ZXh0bWVudWAgaXMgaXNzdWVkIG9uIGEgdmVydGV4LlxuICAgICAgICAgICAgdGhpcy5maXJlQW5kRm9yd2FyZCgnZWRpdGFibGU6dmVydGV4OmNvbnRleHRtZW51JywgZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25WZXJ0ZXhNYXJrZXJNb3VzZURvd246IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAvLyDwn42CbmFtZXNwYWNlIEVkaXRhYmxlXG4gICAgICAgICAgICAvLyDwn42Cc2VjdGlvbiBWZXJ0ZXggZXZlbnRzXG4gICAgICAgICAgICAvLyDwn42CZXZlbnQgZWRpdGFibGU6dmVydGV4Om1vdXNlZG93bjogVmVydGV4RXZlbnRcbiAgICAgICAgICAgIC8vIEZpcmVkIHdoZW4gdXNlciBgbW91c2Vkb3duYCBhIHZlcnRleC5cbiAgICAgICAgICAgIHRoaXMuZmlyZUFuZEZvcndhcmQoJ2VkaXRhYmxlOnZlcnRleDptb3VzZWRvd24nLCBlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvblZlcnRleE1hcmtlck1vdXNlT3ZlcjogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIC8vIPCfjYJuYW1lc3BhY2UgRWRpdGFibGVcbiAgICAgICAgICAgIC8vIPCfjYJzZWN0aW9uIFZlcnRleCBldmVudHNcbiAgICAgICAgICAgIC8vIPCfjYJldmVudCBlZGl0YWJsZTp2ZXJ0ZXg6bW91c2VvdmVyOiBWZXJ0ZXhFdmVudFxuICAgICAgICAgICAgLy8gRmlyZWQgd2hlbiBhIHVzZXIncyBtb3VzZSBlbnRlcnMgdGhlIHZlcnRleFxuICAgICAgICAgICAgdGhpcy5maXJlQW5kRm9yd2FyZCgnZWRpdGFibGU6dmVydGV4Om1vdXNlb3ZlcicsIGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uVmVydGV4TWFya2VyTW91c2VPdXQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAvLyDwn42CbmFtZXNwYWNlIEVkaXRhYmxlXG4gICAgICAgICAgICAvLyDwn42Cc2VjdGlvbiBWZXJ0ZXggZXZlbnRzXG4gICAgICAgICAgICAvLyDwn42CZXZlbnQgZWRpdGFibGU6dmVydGV4Om1vdXNlb3V0OiBWZXJ0ZXhFdmVudFxuICAgICAgICAgICAgLy8gRmlyZWQgd2hlbiBhIHVzZXIncyBtb3VzZSBsZWF2ZXMgdGhlIHZlcnRleFxuICAgICAgICAgICAgdGhpcy5maXJlQW5kRm9yd2FyZCgnZWRpdGFibGU6dmVydGV4Om1vdXNlb3V0JywgZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25NaWRkbGVNYXJrZXJNb3VzZURvd246IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAvLyDwn42CbmFtZXNwYWNlIEVkaXRhYmxlXG4gICAgICAgICAgICAvLyDwn42Cc2VjdGlvbiBNaWRkbGVNYXJrZXIgZXZlbnRzXG4gICAgICAgICAgICAvLyDwn42CZXZlbnQgZWRpdGFibGU6bWlkZGxlbWFya2VyOm1vdXNlZG93bjogVmVydGV4RXZlbnRcbiAgICAgICAgICAgIC8vIEZpcmVkIHdoZW4gdXNlciBgbW91c2Vkb3duYCBhIG1pZGRsZSBtYXJrZXIuXG4gICAgICAgICAgICB0aGlzLmZpcmVBbmRGb3J3YXJkKCdlZGl0YWJsZTptaWRkbGVtYXJrZXI6bW91c2Vkb3duJywgZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25WZXJ0ZXhNYXJrZXJEcmFnOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdGhpcy5vbk1vdmUoZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5mZWF0dXJlLl9ib3VuZHMpIHRoaXMuZXh0ZW5kQm91bmRzKGUpO1xuICAgICAgICAgICAgLy8g8J+Ngm5hbWVzcGFjZSBFZGl0YWJsZVxuICAgICAgICAgICAgLy8g8J+NgnNlY3Rpb24gVmVydGV4IGV2ZW50c1xuICAgICAgICAgICAgLy8g8J+NgmV2ZW50IGVkaXRhYmxlOnZlcnRleDpkcmFnOiBWZXJ0ZXhFdmVudFxuICAgICAgICAgICAgLy8gRmlyZWQgd2hlbiBhIHZlcnRleCBpcyBkcmFnZ2VkIGJ5IHVzZXIuXG4gICAgICAgICAgICB0aGlzLmZpcmVBbmRGb3J3YXJkKCdlZGl0YWJsZTp2ZXJ0ZXg6ZHJhZycsIGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uVmVydGV4TWFya2VyRHJhZ1N0YXJ0OiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgLy8g8J+Ngm5hbWVzcGFjZSBFZGl0YWJsZVxuICAgICAgICAgICAgLy8g8J+NgnNlY3Rpb24gVmVydGV4IGV2ZW50c1xuICAgICAgICAgICAgLy8g8J+NgmV2ZW50IGVkaXRhYmxlOnZlcnRleDpkcmFnc3RhcnQ6IFZlcnRleEV2ZW50XG4gICAgICAgICAgICAvLyBGaXJlZCBiZWZvcmUgYSB2ZXJ0ZXggaXMgZHJhZ2dlZCBieSB1c2VyLlxuICAgICAgICAgICAgdGhpcy5maXJlQW5kRm9yd2FyZCgnZWRpdGFibGU6dmVydGV4OmRyYWdzdGFydCcsIGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uVmVydGV4TWFya2VyRHJhZ0VuZDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIC8vIPCfjYJuYW1lc3BhY2UgRWRpdGFibGVcbiAgICAgICAgICAgIC8vIPCfjYJzZWN0aW9uIFZlcnRleCBldmVudHNcbiAgICAgICAgICAgIC8vIPCfjYJldmVudCBlZGl0YWJsZTp2ZXJ0ZXg6ZHJhZ2VuZDogVmVydGV4RXZlbnRcbiAgICAgICAgICAgIC8vIEZpcmVkIGFmdGVyIGEgdmVydGV4IGlzIGRyYWdnZWQgYnkgdXNlci5cbiAgICAgICAgICAgIHRoaXMuZmlyZUFuZEZvcndhcmQoJ2VkaXRhYmxlOnZlcnRleDpkcmFnZW5kJywgZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0RHJhd25MYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuICAgICAgICAgICAgdGhpcy5fZHJhd25MYXRMbmdzID0gbGF0bG5ncyB8fCB0aGlzLmdldERlZmF1bHRMYXRMbmdzKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc3RhcnREcmF3aW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2RyYXduTGF0TG5ncykgdGhpcy5zZXREcmF3bkxhdExuZ3MoKTtcbiAgICAgICAgICAgIEwuRWRpdGFibGUuQmFzZUVkaXRvci5wcm90b3R5cGUuc3RhcnREcmF3aW5nLmNhbGwodGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc3RhcnREcmF3aW5nRm9yd2FyZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5zdGFydERyYXdpbmcoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBlbmREcmF3aW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnRvb2xzLmRldGFjaEZvcndhcmRMaW5lR3VpZGUoKTtcbiAgICAgICAgICAgIHRoaXMudG9vbHMuZGV0YWNoQmFja3dhcmRMaW5lR3VpZGUoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9kcmF3bkxhdExuZ3MgJiYgdGhpcy5fZHJhd25MYXRMbmdzLmxlbmd0aCA8IHRoaXMuTUlOX1ZFUlRFWCkgdGhpcy5kZWxldGVTaGFwZSh0aGlzLl9kcmF3bkxhdExuZ3MpO1xuICAgICAgICAgICAgTC5FZGl0YWJsZS5CYXNlRWRpdG9yLnByb3RvdHlwZS5lbmREcmF3aW5nLmNhbGwodGhpcyk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fZHJhd25MYXRMbmdzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFkZExhdExuZzogZnVuY3Rpb24gKGxhdGxuZykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2RyYXdpbmcgPT09IEwuRWRpdGFibGUuRk9SV0FSRCkgdGhpcy5fZHJhd25MYXRMbmdzLnB1c2gobGF0bG5nKTtcbiAgICAgICAgICAgIGVsc2UgdGhpcy5fZHJhd25MYXRMbmdzLnVuc2hpZnQobGF0bG5nKTtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZS5fYm91bmRzLmV4dGVuZChsYXRsbmcpO1xuICAgICAgICAgICAgdmFyIHZlcnRleCA9IHRoaXMuYWRkVmVydGV4TWFya2VyKGxhdGxuZywgdGhpcy5fZHJhd25MYXRMbmdzKTtcbiAgICAgICAgICAgIHRoaXMub25OZXdWZXJ0ZXgodmVydGV4KTtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG5ld1BvaW50Rm9yd2FyZDogZnVuY3Rpb24gKGxhdGxuZykge1xuICAgICAgICAgICAgdGhpcy5hZGRMYXRMbmcobGF0bG5nKTtcbiAgICAgICAgICAgIHRoaXMudG9vbHMuYXR0YWNoRm9yd2FyZExpbmVHdWlkZSgpO1xuICAgICAgICAgICAgdGhpcy50b29scy5hbmNob3JGb3J3YXJkTGluZUd1aWRlKGxhdGxuZyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbmV3UG9pbnRCYWNrd2FyZDogZnVuY3Rpb24gKGxhdGxuZykge1xuICAgICAgICAgICAgdGhpcy5hZGRMYXRMbmcobGF0bG5nKTtcbiAgICAgICAgICAgIHRoaXMudG9vbHMuYW5jaG9yQmFja3dhcmRMaW5lR3VpZGUobGF0bG5nKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyDwn42CbmFtZXNwYWNlIFBhdGhFZGl0b3JcbiAgICAgICAgLy8g8J+Ngm1ldGhvZCBwdXNoKClcbiAgICAgICAgLy8gUHJvZ3JhbW1hdGljYWxseSBhZGQgYSBwb2ludCB3aGlsZSBkcmF3aW5nLlxuICAgICAgICBwdXNoOiBmdW5jdGlvbiAobGF0bG5nKSB7XG4gICAgICAgICAgICBpZiAoIWxhdGxuZykgcmV0dXJuIGNvbnNvbGUuZXJyb3IoJ0wuRWRpdGFibGUuUGF0aEVkaXRvci5wdXNoIGV4cGVjdCBhIHZhbGlkIGxhdGxuZyBhcyBwYXJhbWV0ZXInKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9kcmF3aW5nID09PSBMLkVkaXRhYmxlLkZPUldBUkQpIHRoaXMubmV3UG9pbnRGb3J3YXJkKGxhdGxuZyk7XG4gICAgICAgICAgICBlbHNlIHRoaXMubmV3UG9pbnRCYWNrd2FyZChsYXRsbmcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbW92ZUxhdExuZzogZnVuY3Rpb24gKGxhdGxuZykge1xuICAgICAgICAgICAgbGF0bG5nLl9fdmVydGV4LmRlbGV0ZSgpO1xuICAgICAgICAgICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8g8J+Ngm1ldGhvZCBwb3AoKTogTC5MYXRMbmcgb3IgbnVsbFxuICAgICAgICAvLyBQcm9ncmFtbWF0aWNhbGx5IHJlbW92ZSBsYXN0IHBvaW50IChpZiBhbnkpIHdoaWxlIGRyYXdpbmcuXG4gICAgICAgIHBvcDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2RyYXduTGF0TG5ncy5sZW5ndGggPD0gMSkgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGxhdGxuZztcbiAgICAgICAgICAgIGlmICh0aGlzLl9kcmF3aW5nID09PSBMLkVkaXRhYmxlLkZPUldBUkQpIGxhdGxuZyA9IHRoaXMuX2RyYXduTGF0TG5nc1t0aGlzLl9kcmF3bkxhdExuZ3MubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBlbHNlIGxhdGxuZyA9IHRoaXMuX2RyYXduTGF0TG5nc1swXTtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlTGF0TG5nKGxhdGxuZyk7XG4gICAgICAgICAgICBpZiAodGhpcy5fZHJhd2luZyA9PT0gTC5FZGl0YWJsZS5GT1JXQVJEKSB0aGlzLnRvb2xzLmFuY2hvckZvcndhcmRMaW5lR3VpZGUodGhpcy5fZHJhd25MYXRMbmdzW3RoaXMuX2RyYXduTGF0TG5ncy5sZW5ndGggLSAxXSk7XG4gICAgICAgICAgICBlbHNlIHRoaXMudG9vbHMuYW5jaG9yRm9yd2FyZExpbmVHdWlkZSh0aGlzLl9kcmF3bkxhdExuZ3NbMF0pO1xuICAgICAgICAgICAgcmV0dXJuIGxhdGxuZztcbiAgICAgICAgfSxcblxuICAgICAgICBwcm9jZXNzRHJhd2luZ0NsaWNrOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgaWYgKGUudmVydGV4ICYmIGUudmVydGV4LmVkaXRvciA9PT0gdGhpcykgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2RyYXdpbmcgPT09IEwuRWRpdGFibGUuRk9SV0FSRCkgdGhpcy5uZXdQb2ludEZvcndhcmQoZS5sYXRsbmcpO1xuICAgICAgICAgICAgZWxzZSB0aGlzLm5ld1BvaW50QmFja3dhcmQoZS5sYXRsbmcpO1xuICAgICAgICAgICAgdGhpcy5maXJlQW5kRm9yd2FyZCgnZWRpdGFibGU6ZHJhd2luZzpjbGlja2VkJywgZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25EcmF3aW5nTW91c2VNb3ZlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgTC5FZGl0YWJsZS5CYXNlRWRpdG9yLnByb3RvdHlwZS5vbkRyYXdpbmdNb3VzZU1vdmUuY2FsbCh0aGlzLCBlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9kcmF3aW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50b29scy5tb3ZlRm9yd2FyZExpbmVHdWlkZShlLmxhdGxuZyk7XG4gICAgICAgICAgICAgICAgdGhpcy50b29scy5tb3ZlQmFja3dhcmRMaW5lR3VpZGUoZS5sYXRsbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHJlZnJlc2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZS5yZWRyYXcoKTtcbiAgICAgICAgICAgIHRoaXMub25FZGl0aW5nKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8g8J+Ngm5hbWVzcGFjZSBQYXRoRWRpdG9yXG4gICAgICAgIC8vIPCfjYJtZXRob2QgbmV3U2hhcGUobGF0bG5nPzogTC5MYXRMbmcpXG4gICAgICAgIC8vIEFkZCBhIG5ldyBzaGFwZSAoUG9seWxpbmUsIFBvbHlnb24pIGluIGEgbXVsdGksIGFuZCBzZXR1cCB1cCBkcmF3aW5nIHRvb2xzIHRvIGRyYXcgaXQ7XG4gICAgICAgIC8vIGlmIG9wdGlvbmFsIGBsYXRsbmdgIGlzIGdpdmVuLCBzdGFydCBhIHBhdGggYXQgdGhpcyBwb2ludC5cbiAgICAgICAgbmV3U2hhcGU6IGZ1bmN0aW9uIChsYXRsbmcpIHtcbiAgICAgICAgICAgIHZhciBzaGFwZSA9IHRoaXMuYWRkTmV3RW1wdHlTaGFwZSgpO1xuICAgICAgICAgICAgaWYgKCFzaGFwZSkgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5zZXREcmF3bkxhdExuZ3Moc2hhcGVbMF0gfHwgc2hhcGUpOyAgLy8gUG9seWdvbiBvciBwb2x5bGluZVxuICAgICAgICAgICAgdGhpcy5zdGFydERyYXdpbmdGb3J3YXJkKCk7XG4gICAgICAgICAgICAvLyDwn42CbmFtZXNwYWNlIEVkaXRhYmxlXG4gICAgICAgICAgICAvLyDwn42Cc2VjdGlvbiBTaGFwZSBldmVudHNcbiAgICAgICAgICAgIC8vIPCfjYJldmVudCBlZGl0YWJsZTpzaGFwZTpuZXc6IFNoYXBlRXZlbnRcbiAgICAgICAgICAgIC8vIEZpcmVkIHdoZW4gYSBuZXcgc2hhcGUgaXMgY3JlYXRlZCBpbiBhIG11bHRpIChQb2x5Z29uIG9yIFBvbHlsaW5lKS5cbiAgICAgICAgICAgIHRoaXMuZmlyZUFuZEZvcndhcmQoJ2VkaXRhYmxlOnNoYXBlOm5ldycsIHtzaGFwZTogc2hhcGV9KTtcbiAgICAgICAgICAgIGlmIChsYXRsbmcpIHRoaXMubmV3UG9pbnRGb3J3YXJkKGxhdGxuZyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZGVsZXRlU2hhcGU6IGZ1bmN0aW9uIChzaGFwZSwgbGF0bG5ncykge1xuICAgICAgICAgICAgdmFyIGUgPSB7c2hhcGU6IHNoYXBlfTtcbiAgICAgICAgICAgIEwuRWRpdGFibGUubWFrZUNhbmNlbGxhYmxlKGUpO1xuICAgICAgICAgICAgLy8g8J+Ngm5hbWVzcGFjZSBFZGl0YWJsZVxuICAgICAgICAgICAgLy8g8J+NgnNlY3Rpb24gU2hhcGUgZXZlbnRzXG4gICAgICAgICAgICAvLyDwn42CZXZlbnQgZWRpdGFibGU6c2hhcGU6ZGVsZXRlOiBDYW5jZWxhYmxlU2hhcGVFdmVudFxuICAgICAgICAgICAgLy8gRmlyZWQgYmVmb3JlIGEgbmV3IHNoYXBlIGlzIGRlbGV0ZWQgaW4gYSBtdWx0aSAoUG9seWdvbiBvciBQb2x5bGluZSkuXG4gICAgICAgICAgICB0aGlzLmZpcmVBbmRGb3J3YXJkKCdlZGl0YWJsZTpzaGFwZTpkZWxldGUnLCBlKTtcbiAgICAgICAgICAgIGlmIChlLl9jYW5jZWxsZWQpIHJldHVybjtcbiAgICAgICAgICAgIHNoYXBlID0gdGhpcy5fZGVsZXRlU2hhcGUoc2hhcGUsIGxhdGxuZ3MpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZW5zdXJlTm90RmxhdCkgdGhpcy5lbnN1cmVOb3RGbGF0KCk7ICAvLyBQb2x5Z29uLlxuICAgICAgICAgICAgdGhpcy5mZWF0dXJlLnNldExhdExuZ3ModGhpcy5nZXRMYXRMbmdzKCkpOyAgLy8gRm9yY2UgYm91bmRzIHJlc2V0LlxuICAgICAgICAgICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgICAgICAvLyDwn42CbmFtZXNwYWNlIEVkaXRhYmxlXG4gICAgICAgICAgICAvLyDwn42Cc2VjdGlvbiBTaGFwZSBldmVudHNcbiAgICAgICAgICAgIC8vIPCfjYJldmVudCBlZGl0YWJsZTpzaGFwZTpkZWxldGVkOiBTaGFwZUV2ZW50XG4gICAgICAgICAgICAvLyBGaXJlZCBhZnRlciBhIG5ldyBzaGFwZSBpcyBkZWxldGVkIGluIGEgbXVsdGkgKFBvbHlnb24gb3IgUG9seWxpbmUpLlxuICAgICAgICAgICAgdGhpcy5maXJlQW5kRm9yd2FyZCgnZWRpdGFibGU6c2hhcGU6ZGVsZXRlZCcsIHtzaGFwZTogc2hhcGV9KTtcbiAgICAgICAgICAgIHJldHVybiBzaGFwZTtcbiAgICAgICAgfSxcblxuICAgICAgICBfZGVsZXRlU2hhcGU6IGZ1bmN0aW9uIChzaGFwZSwgbGF0bG5ncykge1xuICAgICAgICAgICAgbGF0bG5ncyA9IGxhdGxuZ3MgfHwgdGhpcy5nZXRMYXRMbmdzKCk7XG4gICAgICAgICAgICBpZiAoIWxhdGxuZ3MubGVuZ3RoKSByZXR1cm47XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICAgICAgaW5wbGFjZURlbGV0ZSA9IGZ1bmN0aW9uIChsYXRsbmdzLCBzaGFwZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDYWxsZWQgd2hlbiBkZWxldGluZyBhIGZsYXQgbGF0bG5nc1xuICAgICAgICAgICAgICAgICAgICBzaGFwZSA9IGxhdGxuZ3Muc3BsaWNlKDAsIE51bWJlci5NQVhfVkFMVUUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2hhcGU7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzcGxpY2VEZWxldGUgPSBmdW5jdGlvbiAobGF0bG5ncywgc2hhcGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FsbGVkIHdoZW4gcmVtb3ZpbmcgYSBsYXRsbmdzIGluc2lkZSBhbiBhcnJheVxuICAgICAgICAgICAgICAgICAgICBsYXRsbmdzLnNwbGljZShsYXRsbmdzLmluZGV4T2Yoc2hhcGUpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFsYXRsbmdzLmxlbmd0aCkgc2VsZi5fZGVsZXRlU2hhcGUobGF0bG5ncyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaGFwZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGxhdGxuZ3MgPT09IHNoYXBlKSByZXR1cm4gaW5wbGFjZURlbGV0ZShsYXRsbmdzLCBzaGFwZSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhdGxuZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAobGF0bG5nc1tpXSA9PT0gc2hhcGUpIHJldHVybiBzcGxpY2VEZWxldGUobGF0bG5ncywgc2hhcGUpO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGxhdGxuZ3NbaV0uaW5kZXhPZihzaGFwZSkgIT09IC0xKSByZXR1cm4gc3BsaWNlRGVsZXRlKGxhdGxuZ3NbaV0sIHNoYXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyDwn42CbmFtZXNwYWNlIFBhdGhFZGl0b3JcbiAgICAgICAgLy8g8J+Ngm1ldGhvZCBkZWxldGVTaGFwZUF0KGxhdGxuZzogTC5MYXRMbmcpOiBBcnJheVxuICAgICAgICAvLyBSZW1vdmUgYSBwYXRoIHNoYXBlIGF0IHRoZSBnaXZlbiBgbGF0bG5nYC5cbiAgICAgICAgZGVsZXRlU2hhcGVBdDogZnVuY3Rpb24gKGxhdGxuZykge1xuICAgICAgICAgICAgdmFyIHNoYXBlID0gdGhpcy5mZWF0dXJlLnNoYXBlQXQobGF0bG5nKTtcbiAgICAgICAgICAgIGlmIChzaGFwZSkgcmV0dXJuIHRoaXMuZGVsZXRlU2hhcGUoc2hhcGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIPCfjYJtZXRob2QgYXBwZW5kU2hhcGUoc2hhcGU6IEFycmF5KVxuICAgICAgICAvLyBBcHBlbmQgYSBuZXcgc2hhcGUgdG8gdGhlIFBvbHlnb24gb3IgUG9seWxpbmUuXG4gICAgICAgIGFwcGVuZFNoYXBlOiBmdW5jdGlvbiAoc2hhcGUpIHtcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0U2hhcGUoc2hhcGUpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIPCfjYJtZXRob2QgcHJlcGVuZFNoYXBlKHNoYXBlOiBBcnJheSlcbiAgICAgICAgLy8gUHJlcGVuZCBhIG5ldyBzaGFwZSB0byB0aGUgUG9seWdvbiBvciBQb2x5bGluZS5cbiAgICAgICAgcHJlcGVuZFNoYXBlOiBmdW5jdGlvbiAoc2hhcGUpIHtcbiAgICAgICAgICAgIHRoaXMuaW5zZXJ0U2hhcGUoc2hhcGUsIDApO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIPCfjYJtZXRob2QgaW5zZXJ0U2hhcGUoc2hhcGU6IEFycmF5LCBpbmRleDogaW50KVxuICAgICAgICAvLyBJbnNlcnQgYSBuZXcgc2hhcGUgdG8gdGhlIFBvbHlnb24gb3IgUG9seWxpbmUgYXQgZ2l2ZW4gaW5kZXggKGRlZmF1bHQgaXMgdG8gYXBwZW5kKS5cbiAgICAgICAgaW5zZXJ0U2hhcGU6IGZ1bmN0aW9uIChzaGFwZSwgaW5kZXgpIHtcbiAgICAgICAgICAgIHRoaXMuZW5zdXJlTXVsdGkoKTtcbiAgICAgICAgICAgIHNoYXBlID0gdGhpcy5mb3JtYXRTaGFwZShzaGFwZSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGluZGV4ID09PSAndW5kZWZpbmVkJykgaW5kZXggPSB0aGlzLmZlYXR1cmUuX2xhdGxuZ3MubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlLl9sYXRsbmdzLnNwbGljZShpbmRleCwgMCwgc2hhcGUpO1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlLnJlZHJhdygpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2VuYWJsZWQpIHRoaXMucmVzZXQoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBleHRlbmRCb3VuZHM6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB0aGlzLmZlYXR1cmUuX2JvdW5kcy5leHRlbmQoZS52ZXJ0ZXgubGF0bG5nKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvbkRyYWdTdGFydDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHRoaXMuZWRpdExheWVyLmNsZWFyTGF5ZXJzKCk7XG4gICAgICAgICAgICBMLkVkaXRhYmxlLkJhc2VFZGl0b3IucHJvdG90eXBlLm9uRHJhZ1N0YXJ0LmNhbGwodGhpcywgZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25EcmFnRW5kOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdGhpcy5pbml0VmVydGV4TWFya2VycygpO1xuICAgICAgICAgICAgTC5FZGl0YWJsZS5CYXNlRWRpdG9yLnByb3RvdHlwZS5vbkRyYWdFbmQuY2FsbCh0aGlzLCBlKTtcbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICAvLyDwn42CbmFtZXNwYWNlIEVkaXRhYmxlOyDwn42CY2xhc3MgUG9seWxpbmVFZGl0b3I7IPCfjYJha2EgTC5FZGl0YWJsZS5Qb2x5bGluZUVkaXRvclxuICAgIC8vIPCfjYJpbmhlcml0cyBQYXRoRWRpdG9yXG4gICAgTC5FZGl0YWJsZS5Qb2x5bGluZUVkaXRvciA9IEwuRWRpdGFibGUuUGF0aEVkaXRvci5leHRlbmQoe1xuXG4gICAgICAgIHN0YXJ0RHJhd2luZ0JhY2t3YXJkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9kcmF3aW5nID0gTC5FZGl0YWJsZS5CQUNLV0FSRDtcbiAgICAgICAgICAgIHRoaXMuc3RhcnREcmF3aW5nKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8g8J+Ngm1ldGhvZCBjb250aW51ZUJhY2t3YXJkKGxhdGxuZ3M/OiBBcnJheSlcbiAgICAgICAgLy8gU2V0IHVwIGRyYXdpbmcgdG9vbHMgdG8gY29udGludWUgdGhlIGxpbmUgYmFja3dhcmQuXG4gICAgICAgIGNvbnRpbnVlQmFja3dhcmQ6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kcmF3aW5nKCkpIHJldHVybjtcbiAgICAgICAgICAgIGxhdGxuZ3MgPSBsYXRsbmdzIHx8IHRoaXMuZ2V0RGVmYXVsdExhdExuZ3MoKTtcbiAgICAgICAgICAgIHRoaXMuc2V0RHJhd25MYXRMbmdzKGxhdGxuZ3MpO1xuICAgICAgICAgICAgaWYgKGxhdGxuZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMudG9vbHMuYXR0YWNoQmFja3dhcmRMaW5lR3VpZGUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRvb2xzLmFuY2hvckJhY2t3YXJkTGluZUd1aWRlKGxhdGxuZ3NbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdGFydERyYXdpbmdCYWNrd2FyZCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIPCfjYJtZXRob2QgY29udGludWVGb3J3YXJkKGxhdGxuZ3M/OiBBcnJheSlcbiAgICAgICAgLy8gU2V0IHVwIGRyYXdpbmcgdG9vbHMgdG8gY29udGludWUgdGhlIGxpbmUgZm9yd2FyZC5cbiAgICAgICAgY29udGludWVGb3J3YXJkOiBmdW5jdGlvbiAobGF0bG5ncykge1xuICAgICAgICAgICAgaWYgKHRoaXMuZHJhd2luZygpKSByZXR1cm47XG4gICAgICAgICAgICBsYXRsbmdzID0gbGF0bG5ncyB8fCB0aGlzLmdldERlZmF1bHRMYXRMbmdzKCk7XG4gICAgICAgICAgICB0aGlzLnNldERyYXduTGF0TG5ncyhsYXRsbmdzKTtcbiAgICAgICAgICAgIGlmIChsYXRsbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRvb2xzLmF0dGFjaEZvcndhcmRMaW5lR3VpZGUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRvb2xzLmFuY2hvckZvcndhcmRMaW5lR3VpZGUobGF0bG5nc1tsYXRsbmdzLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3RhcnREcmF3aW5nRm9yd2FyZCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldERlZmF1bHRMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuICAgICAgICAgICAgbGF0bG5ncyA9IGxhdGxuZ3MgfHwgdGhpcy5mZWF0dXJlLl9sYXRsbmdzO1xuICAgICAgICAgICAgaWYgKCFsYXRsbmdzLmxlbmd0aCB8fCBsYXRsbmdzWzBdIGluc3RhbmNlb2YgTC5MYXRMbmcpIHJldHVybiBsYXRsbmdzO1xuICAgICAgICAgICAgZWxzZSByZXR1cm4gdGhpcy5nZXREZWZhdWx0TGF0TG5ncyhsYXRsbmdzWzBdKTtcbiAgICAgICAgfSxcblxuICAgICAgICBlbnN1cmVNdWx0aTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZmVhdHVyZS5fbGF0bG5ncy5sZW5ndGggJiYgaXNGbGF0KHRoaXMuZmVhdHVyZS5fbGF0bG5ncykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZlYXR1cmUuX2xhdGxuZ3MgPSBbdGhpcy5mZWF0dXJlLl9sYXRsbmdzXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBhZGROZXdFbXB0eVNoYXBlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5mZWF0dXJlLl9sYXRsbmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBzaGFwZSA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kU2hhcGUoc2hhcGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzaGFwZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmVhdHVyZS5fbGF0bG5ncztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBmb3JtYXRTaGFwZTogZnVuY3Rpb24gKHNoYXBlKSB7XG4gICAgICAgICAgICBpZiAoaXNGbGF0KHNoYXBlKSkgcmV0dXJuIHNoYXBlO1xuICAgICAgICAgICAgZWxzZSBpZiAoc2hhcGVbMF0pIHJldHVybiB0aGlzLmZvcm1hdFNoYXBlKHNoYXBlWzBdKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyDwn42CbWV0aG9kIHNwbGl0U2hhcGUobGF0bG5ncz86IEFycmF5LCBpbmRleDogaW50KVxuICAgICAgICAvLyBTcGxpdCB0aGUgZ2l2ZW4gYGxhdGxuZ3NgIHNoYXBlIGF0IGluZGV4IGBpbmRleGAgYW5kIGludGVncmF0ZSBuZXcgc2hhcGUgaW4gaW5zdGFuY2UgYGxhdGxuZ3NgLlxuICAgICAgICBzcGxpdFNoYXBlOiBmdW5jdGlvbiAoc2hhcGUsIGluZGV4KSB7XG4gICAgICAgICAgICBpZiAoIWluZGV4IHx8IGluZGV4ID49IHNoYXBlLmxlbmd0aCAtIDEpIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMuZW5zdXJlTXVsdGkoKTtcbiAgICAgICAgICAgIHZhciBzaGFwZUluZGV4ID0gdGhpcy5mZWF0dXJlLl9sYXRsbmdzLmluZGV4T2Yoc2hhcGUpO1xuICAgICAgICAgICAgaWYgKHNoYXBlSW5kZXggPT09IC0xKSByZXR1cm47XG4gICAgICAgICAgICB2YXIgZmlyc3QgPSBzaGFwZS5zbGljZSgwLCBpbmRleCArIDEpLFxuICAgICAgICAgICAgICAgIHNlY29uZCA9IHNoYXBlLnNsaWNlKGluZGV4KTtcbiAgICAgICAgICAgIC8vIFdlIGRlYWwgd2l0aCByZWZlcmVuY2UsIHdlIGRvbid0IHdhbnQgdHdpY2UgdGhlIHNhbWUgbGF0bG5nIGFyb3VuZC5cbiAgICAgICAgICAgIHNlY29uZFswXSA9IEwubGF0TG5nKHNlY29uZFswXS5sYXQsIHNlY29uZFswXS5sbmcsIHNlY29uZFswXS5hbHQpO1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlLl9sYXRsbmdzLnNwbGljZShzaGFwZUluZGV4LCAxLCBmaXJzdCwgc2Vjb25kKTtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaCgpO1xuICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIC8vIPCfjYJuYW1lc3BhY2UgRWRpdGFibGU7IPCfjYJjbGFzcyBQb2x5Z29uRWRpdG9yOyDwn42CYWthIEwuRWRpdGFibGUuUG9seWdvbkVkaXRvclxuICAgIC8vIPCfjYJpbmhlcml0cyBQYXRoRWRpdG9yXG4gICAgTC5FZGl0YWJsZS5Qb2x5Z29uRWRpdG9yID0gTC5FZGl0YWJsZS5QYXRoRWRpdG9yLmV4dGVuZCh7XG5cbiAgICAgICAgQ0xPU0VEOiB0cnVlLFxuICAgICAgICBNSU5fVkVSVEVYOiAzLFxuXG4gICAgICAgIG5ld1BvaW50Rm9yd2FyZDogZnVuY3Rpb24gKGxhdGxuZykge1xuICAgICAgICAgICAgTC5FZGl0YWJsZS5QYXRoRWRpdG9yLnByb3RvdHlwZS5uZXdQb2ludEZvcndhcmQuY2FsbCh0aGlzLCBsYXRsbmcpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnRvb2xzLmJhY2t3YXJkTGluZUd1aWRlLl9sYXRsbmdzLmxlbmd0aCkgdGhpcy50b29scy5hbmNob3JCYWNrd2FyZExpbmVHdWlkZShsYXRsbmcpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2RyYXduTGF0TG5ncy5sZW5ndGggPT09IDIpIHRoaXMudG9vbHMuYXR0YWNoQmFja3dhcmRMaW5lR3VpZGUoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBhZGROZXdFbXB0eUhvbGU6IGZ1bmN0aW9uIChsYXRsbmcpIHtcbiAgICAgICAgICAgIHRoaXMuZW5zdXJlTm90RmxhdCgpO1xuICAgICAgICAgICAgdmFyIGxhdGxuZ3MgPSB0aGlzLmZlYXR1cmUuc2hhcGVBdChsYXRsbmcpO1xuICAgICAgICAgICAgaWYgKCFsYXRsbmdzKSByZXR1cm47XG4gICAgICAgICAgICB2YXIgaG9sZXMgPSBbXTtcbiAgICAgICAgICAgIGxhdGxuZ3MucHVzaChob2xlcyk7XG4gICAgICAgICAgICByZXR1cm4gaG9sZXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8g8J+Ngm1ldGhvZCBuZXdIb2xlKGxhdGxuZz86IEwuTGF0TG5nLCBpbmRleDogaW50KVxuICAgICAgICAvLyBTZXQgdXAgZHJhd2luZyB0b29scyBmb3IgY3JlYXRpbmcgYSBuZXcgaG9sZSBvbiB0aGUgUG9seWdvbi4gSWYgdGhlIGBsYXRsbmdgIHBhcmFtIGlzIGdpdmVuLCBhIGZpcnN0IHBvaW50IGlzIGNyZWF0ZWQuXG4gICAgICAgIG5ld0hvbGU6IGZ1bmN0aW9uIChsYXRsbmcpIHtcbiAgICAgICAgICAgIHZhciBob2xlcyA9IHRoaXMuYWRkTmV3RW1wdHlIb2xlKGxhdGxuZyk7XG4gICAgICAgICAgICBpZiAoIWhvbGVzKSByZXR1cm47XG4gICAgICAgICAgICB0aGlzLnNldERyYXduTGF0TG5ncyhob2xlcyk7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0RHJhd2luZ0ZvcndhcmQoKTtcbiAgICAgICAgICAgIGlmIChsYXRsbmcpIHRoaXMubmV3UG9pbnRGb3J3YXJkKGxhdGxuZyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWRkTmV3RW1wdHlTaGFwZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZmVhdHVyZS5fbGF0bG5ncy5sZW5ndGggJiYgdGhpcy5mZWF0dXJlLl9sYXRsbmdzWzBdLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBzaGFwZSA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kU2hhcGUoc2hhcGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzaGFwZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmVhdHVyZS5fbGF0bG5ncztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBlbnN1cmVNdWx0aTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZmVhdHVyZS5fbGF0bG5ncy5sZW5ndGggJiYgaXNGbGF0KHRoaXMuZmVhdHVyZS5fbGF0bG5nc1swXSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZlYXR1cmUuX2xhdGxuZ3MgPSBbdGhpcy5mZWF0dXJlLl9sYXRsbmdzXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBlbnN1cmVOb3RGbGF0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZmVhdHVyZS5fbGF0bG5ncy5sZW5ndGggfHwgaXNGbGF0KHRoaXMuZmVhdHVyZS5fbGF0bG5ncykpIHRoaXMuZmVhdHVyZS5fbGF0bG5ncyA9IFt0aGlzLmZlYXR1cmUuX2xhdGxuZ3NdO1xuICAgICAgICB9LFxuXG4gICAgICAgIHZlcnRleENhbkJlRGVsZXRlZDogZnVuY3Rpb24gKHZlcnRleCkge1xuICAgICAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMuZmVhdHVyZS5wYXJlbnRTaGFwZSh2ZXJ0ZXgubGF0bG5ncyksXG4gICAgICAgICAgICAgICAgaWR4ID0gTC5VdGlsLmluZGV4T2YocGFyZW50LCB2ZXJ0ZXgubGF0bG5ncyk7XG4gICAgICAgICAgICBpZiAoaWR4ID4gMCkgcmV0dXJuIHRydWU7ICAvLyBIb2xlcyBjYW4gYmUgdG90YWxseSBkZWxldGVkIHdpdGhvdXQgcmVtb3ZpbmcgdGhlIGxheWVyIGl0c2VsZi5cbiAgICAgICAgICAgIHJldHVybiBMLkVkaXRhYmxlLlBhdGhFZGl0b3IucHJvdG90eXBlLnZlcnRleENhbkJlRGVsZXRlZC5jYWxsKHRoaXMsIHZlcnRleCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0RGVmYXVsdExhdExuZ3M6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5mZWF0dXJlLl9sYXRsbmdzLmxlbmd0aCkgdGhpcy5mZWF0dXJlLl9sYXRsbmdzLnB1c2goW10pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmVhdHVyZS5fbGF0bG5nc1swXTtcbiAgICAgICAgfSxcblxuICAgICAgICBmb3JtYXRTaGFwZTogZnVuY3Rpb24gKHNoYXBlKSB7XG4gICAgICAgICAgICAvLyBbWzEsIDJdLCBbMywgNF1dID0+IG11c3QgYmUgbmVzdGVkXG4gICAgICAgICAgICAvLyBbXSA9PiBtdXN0IGJlIG5lc3RlZFxuICAgICAgICAgICAgLy8gW1tdXSA9PiBpcyBhbHJlYWR5IG5lc3RlZFxuICAgICAgICAgICAgaWYgKGlzRmxhdChzaGFwZSkgJiYgKCFzaGFwZVswXSB8fCBzaGFwZVswXS5sZW5ndGggIT09IDApKSByZXR1cm4gW3NoYXBlXTtcbiAgICAgICAgICAgIGVsc2UgcmV0dXJuIHNoYXBlO1xuICAgICAgICB9XG5cbiAgICB9KTtcblxuICAgIC8vIPCfjYJuYW1lc3BhY2UgRWRpdGFibGU7IPCfjYJjbGFzcyBSZWN0YW5nbGVFZGl0b3I7IPCfjYJha2EgTC5FZGl0YWJsZS5SZWN0YW5nbGVFZGl0b3JcbiAgICAvLyDwn42CaW5oZXJpdHMgUGF0aEVkaXRvclxuICAgIEwuRWRpdGFibGUuUmVjdGFuZ2xlRWRpdG9yID0gTC5FZGl0YWJsZS5QYXRoRWRpdG9yLmV4dGVuZCh7XG5cbiAgICAgICAgQ0xPU0VEOiB0cnVlLFxuICAgICAgICBNSU5fVkVSVEVYOiA0LFxuXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIHNraXBNaWRkbGVNYXJrZXJzOiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgZXh0ZW5kQm91bmRzOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gZS52ZXJ0ZXguZ2V0SW5kZXgoKSxcbiAgICAgICAgICAgICAgICBuZXh0ID0gZS52ZXJ0ZXguZ2V0TmV4dCgpLFxuICAgICAgICAgICAgICAgIHByZXZpb3VzID0gZS52ZXJ0ZXguZ2V0UHJldmlvdXMoKSxcbiAgICAgICAgICAgICAgICBvcHBvc2l0ZUluZGV4ID0gKGluZGV4ICsgMikgJSA0LFxuICAgICAgICAgICAgICAgIG9wcG9zaXRlID0gZS52ZXJ0ZXgubGF0bG5nc1tvcHBvc2l0ZUluZGV4XSxcbiAgICAgICAgICAgICAgICBib3VuZHMgPSBuZXcgTC5MYXRMbmdCb3VuZHMoZS5sYXRsbmcsIG9wcG9zaXRlKTtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBsYXRsbmdzIGJ5IGhhbmQgdG8gcHJlc2VydmUgb3JkZXIuXG4gICAgICAgICAgICBwcmV2aW91cy5sYXRsbmcudXBkYXRlKFtlLmxhdGxuZy5sYXQsIG9wcG9zaXRlLmxuZ10pO1xuICAgICAgICAgICAgbmV4dC5sYXRsbmcudXBkYXRlKFtvcHBvc2l0ZS5sYXQsIGUubGF0bG5nLmxuZ10pO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVCb3VuZHMoYm91bmRzKTtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaFZlcnRleE1hcmtlcnMoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvbkRyYXdpbmdNb3VzZURvd246IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBMLkVkaXRhYmxlLlBhdGhFZGl0b3IucHJvdG90eXBlLm9uRHJhd2luZ01vdXNlRG93bi5jYWxsKHRoaXMsIGUpO1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0KCk7XG4gICAgICAgICAgICB2YXIgbGF0bG5ncyA9IHRoaXMuZ2V0RGVmYXVsdExhdExuZ3MoKTtcbiAgICAgICAgICAgIC8vIEwuUG9seWdvbi5fY29udmVydExhdExuZ3MgcmVtb3ZlcyBsYXN0IGxhdGxuZyBpZiBpdCBlcXVhbHMgZmlyc3QgcG9pbnQsXG4gICAgICAgICAgICAvLyB3aGljaCBpcyB0aGUgY2FzZSBoZXJlIGFzIGFsbCBsYXRsbmdzIGFyZSBbMCwgMF1cbiAgICAgICAgICAgIGlmIChsYXRsbmdzLmxlbmd0aCA9PT0gMykgbGF0bG5ncy5wdXNoKGUubGF0bG5nKTtcbiAgICAgICAgICAgIHZhciBib3VuZHMgPSBuZXcgTC5MYXRMbmdCb3VuZHMoZS5sYXRsbmcsIGUubGF0bG5nKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQm91bmRzKGJvdW5kcyk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUxhdExuZ3MoYm91bmRzKTtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaCgpO1xuICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICAgICAgLy8gU3RvcCBkcmFnZ2luZyBtYXAuXG4gICAgICAgICAgICAvLyBMLkRyYWdnYWJsZSBoYXMgdHdvIHdvcmtmbG93czpcbiAgICAgICAgICAgIC8vIC0gbW91c2Vkb3duID0+IG1vdXNlbW92ZSA9PiBtb3VzZXVwXG4gICAgICAgICAgICAvLyAtIHRvdWNoc3RhcnQgPT4gdG91Y2htb3ZlID0+IHRvdWNoZW5kXG4gICAgICAgICAgICAvLyBQcm9ibGVtOiBMLk1hcC5UYXAgZG9lcyBub3QgYWxsb3cgdXMgdG8gbGlzdGVuIHRvIHRvdWNoc3RhcnQsIHNvIHdlIG9ubHlcbiAgICAgICAgICAgIC8vIGNhbiBkZWFsIHdpdGggbW91c2Vkb3duLCBidXQgdGhlbiB3aGVuIGluIGEgdG91Y2ggZGV2aWNlLCB3ZSBhcmUgZGVhbGluZyB3aXRoXG4gICAgICAgICAgICAvLyBzaW11bGF0ZWQgZXZlbnRzIChhY3R1YWxseSBzaW11bGF0ZWQgYnkgTC5NYXAuVGFwKSwgd2hpY2ggYXJlIG5vIG1vcmUgdGFrZW5cbiAgICAgICAgICAgIC8vIGludG8gYWNjb3VudCBieSBMLkRyYWdnYWJsZS5cbiAgICAgICAgICAgIC8vIFJlZi46IGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQuRWRpdGFibGUvaXNzdWVzLzEwM1xuICAgICAgICAgICAgZS5vcmlnaW5hbEV2ZW50Ll9zaW11bGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMubWFwLmRyYWdnaW5nLl9kcmFnZ2FibGUuX29uVXAoZS5vcmlnaW5hbEV2ZW50KTtcbiAgICAgICAgICAgIC8vIE5vdyB0cmFuc2ZlciBvbmdvaW5nIGRyYWcgYWN0aW9uIHRvIHRoZSBib3R0b20gcmlnaHQgY29ybmVyLlxuICAgICAgICAgICAgLy8gU2hvdWxkIHdlIHJlZmluZSB3aGljaCBjb3JuZXIgd2lsbCBoYW5kbGUgdGhlIGRyYWcgYWNjb3JkaW5nIHRvXG4gICAgICAgICAgICAvLyBkcmFnIGRpcmVjdGlvbj9cbiAgICAgICAgICAgIGxhdGxuZ3NbM10uX192ZXJ0ZXguZHJhZ2dpbmcuX2RyYWdnYWJsZS5fb25Eb3duKGUub3JpZ2luYWxFdmVudCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25EcmF3aW5nTW91c2VVcDogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHRoaXMuY29tbWl0RHJhd2luZyhlKTtcbiAgICAgICAgICAgIGUub3JpZ2luYWxFdmVudC5fc2ltdWxhdGVkID0gZmFsc2U7XG4gICAgICAgICAgICBMLkVkaXRhYmxlLlBhdGhFZGl0b3IucHJvdG90eXBlLm9uRHJhd2luZ01vdXNlVXAuY2FsbCh0aGlzLCBlKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvbkRyYXdpbmdNb3VzZU1vdmU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBlLm9yaWdpbmFsRXZlbnQuX3NpbXVsYXRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgTC5FZGl0YWJsZS5QYXRoRWRpdG9yLnByb3RvdHlwZS5vbkRyYXdpbmdNb3VzZU1vdmUuY2FsbCh0aGlzLCBlKTtcbiAgICAgICAgfSxcblxuXG4gICAgICAgIGdldERlZmF1bHRMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncykge1xuICAgICAgICAgICAgcmV0dXJuIGxhdGxuZ3MgfHwgdGhpcy5mZWF0dXJlLl9sYXRsbmdzWzBdO1xuICAgICAgICB9LFxuXG4gICAgICAgIHVwZGF0ZUJvdW5kczogZnVuY3Rpb24gKGJvdW5kcykge1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlLl9ib3VuZHMgPSBib3VuZHM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgdXBkYXRlTGF0TG5nczogZnVuY3Rpb24gKGJvdW5kcykge1xuICAgICAgICAgICAgdmFyIGxhdGxuZ3MgPSB0aGlzLmdldERlZmF1bHRMYXRMbmdzKCksXG4gICAgICAgICAgICAgICAgbmV3TGF0bG5ncyA9IHRoaXMuZmVhdHVyZS5fYm91bmRzVG9MYXRMbmdzKGJvdW5kcyk7XG4gICAgICAgICAgICAvLyBLZWVwIHJlZmVyZW5jZXMuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhdGxuZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsYXRsbmdzW2ldLnVwZGF0ZShuZXdMYXRsbmdzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICAvLyDwn42CbmFtZXNwYWNlIEVkaXRhYmxlOyDwn42CY2xhc3MgQ2lyY2xlRWRpdG9yOyDwn42CYWthIEwuRWRpdGFibGUuQ2lyY2xlRWRpdG9yXG4gICAgLy8g8J+NgmluaGVyaXRzIFBhdGhFZGl0b3JcbiAgICBMLkVkaXRhYmxlLkNpcmNsZUVkaXRvciA9IEwuRWRpdGFibGUuUGF0aEVkaXRvci5leHRlbmQoe1xuXG4gICAgICAgIE1JTl9WRVJURVg6IDIsXG5cbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgc2tpcE1pZGRsZU1hcmtlcnM6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICBpbml0aWFsaXplOiBmdW5jdGlvbiAobWFwLCBmZWF0dXJlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBMLkVkaXRhYmxlLlBhdGhFZGl0b3IucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCBtYXAsIGZlYXR1cmUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5fcmVzaXplTGF0TG5nID0gdGhpcy5jb21wdXRlUmVzaXplTGF0TG5nKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY29tcHV0ZVJlc2l6ZUxhdExuZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gV2hpbGUgY2lyY2xlIGlzIG5vdCBhZGRlZCB0byB0aGUgbWFwLCBfcmFkaXVzIGlzIG5vdCBzZXQuXG4gICAgICAgICAgICB2YXIgZGVsdGEgPSAodGhpcy5mZWF0dXJlLl9yYWRpdXMgfHwgdGhpcy5mZWF0dXJlLl9tUmFkaXVzKSAqIE1hdGguY29zKE1hdGguUEkgLyA0KSxcbiAgICAgICAgICAgICAgICBwb2ludCA9IHRoaXMubWFwLnByb2plY3QodGhpcy5mZWF0dXJlLl9sYXRsbmcpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFwLnVucHJvamVjdChbcG9pbnQueCArIGRlbHRhLCBwb2ludC55IC0gZGVsdGFdKTtcbiAgICAgICAgfSxcblxuICAgICAgICB1cGRhdGVSZXNpemVMYXRMbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2l6ZUxhdExuZy51cGRhdGUodGhpcy5jb21wdXRlUmVzaXplTGF0TG5nKCkpO1xuICAgICAgICAgICAgdGhpcy5fcmVzaXplTGF0TG5nLl9fdmVydGV4LnVwZGF0ZSgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldExhdExuZ3M6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBbdGhpcy5mZWF0dXJlLl9sYXRsbmcsIHRoaXMuX3Jlc2l6ZUxhdExuZ107XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0RGVmYXVsdExhdExuZ3M6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldExhdExuZ3MoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBvblZlcnRleE1hcmtlckRyYWc6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAoZS52ZXJ0ZXguZ2V0SW5kZXgoKSA9PT0gMSkgdGhpcy5yZXNpemUoZSk7XG4gICAgICAgICAgICBlbHNlIHRoaXMudXBkYXRlUmVzaXplTGF0TG5nKGUpO1xuICAgICAgICAgICAgTC5FZGl0YWJsZS5QYXRoRWRpdG9yLnByb3RvdHlwZS5vblZlcnRleE1hcmtlckRyYWcuY2FsbCh0aGlzLCBlKTtcbiAgICAgICAgfSxcblxuICAgICAgICByZXNpemU6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgcmFkaXVzID0gdGhpcy5mZWF0dXJlLl9sYXRsbmcuZGlzdGFuY2VUbyhlLmxhdGxuZyk7XG4gICAgICAgICAgICB0aGlzLmZlYXR1cmUuc2V0UmFkaXVzKHJhZGl1cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25EcmF3aW5nTW91c2VEb3duOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgTC5FZGl0YWJsZS5QYXRoRWRpdG9yLnByb3RvdHlwZS5vbkRyYXdpbmdNb3VzZURvd24uY2FsbCh0aGlzLCBlKTtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2l6ZUxhdExuZy51cGRhdGUoZS5sYXRsbmcpO1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlLl9sYXRsbmcudXBkYXRlKGUubGF0bG5nKTtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdCgpO1xuICAgICAgICAgICAgLy8gU3RvcCBkcmFnZ2luZyBtYXAuXG4gICAgICAgICAgICBlLm9yaWdpbmFsRXZlbnQuX3NpbXVsYXRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5tYXAuZHJhZ2dpbmcuX2RyYWdnYWJsZS5fb25VcChlLm9yaWdpbmFsRXZlbnQpO1xuICAgICAgICAgICAgLy8gTm93IHRyYW5zZmVyIG9uZ29pbmcgZHJhZyBhY3Rpb24gdG8gdGhlIHJhZGl1cyBoYW5kbGVyLlxuICAgICAgICAgICAgdGhpcy5fcmVzaXplTGF0TG5nLl9fdmVydGV4LmRyYWdnaW5nLl9kcmFnZ2FibGUuX29uRG93bihlLm9yaWdpbmFsRXZlbnQpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uRHJhd2luZ01vdXNlVXA6IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB0aGlzLmNvbW1pdERyYXdpbmcoZSk7XG4gICAgICAgICAgICBlLm9yaWdpbmFsRXZlbnQuX3NpbXVsYXRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgTC5FZGl0YWJsZS5QYXRoRWRpdG9yLnByb3RvdHlwZS5vbkRyYXdpbmdNb3VzZVVwLmNhbGwodGhpcywgZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25EcmF3aW5nTW91c2VNb3ZlOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZS5vcmlnaW5hbEV2ZW50Ll9zaW11bGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIEwuRWRpdGFibGUuUGF0aEVkaXRvci5wcm90b3R5cGUub25EcmF3aW5nTW91c2VNb3ZlLmNhbGwodGhpcywgZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgb25EcmFnOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgTC5FZGl0YWJsZS5QYXRoRWRpdG9yLnByb3RvdHlwZS5vbkRyYWcuY2FsbCh0aGlzLCBlKTtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZS5kcmFnZ2luZy51cGRhdGVMYXRMbmcodGhpcy5fcmVzaXplTGF0TG5nKTtcbiAgICAgICAgfVxuXG4gICAgfSk7XG5cbiAgICAvLyDwn42CbmFtZXNwYWNlIEVkaXRhYmxlOyDwn42CY2xhc3MgRWRpdGFibGVNaXhpblxuICAgIC8vIGBFZGl0YWJsZU1peGluYCBpcyBpbmNsdWRlZCB0byBgTC5Qb2x5bGluZWAsIGBMLlBvbHlnb25gLCBgTC5SZWN0YW5nbGVgLCBgTC5DaXJjbGVgXG4gICAgLy/CoGFuZCBgTC5NYXJrZXJgLiBJdCBhZGRzIHNvbWUgbWV0aG9kcyB0byB0aGVtLlxuICAgIC8vICpXaGVuIGVkaXRpbmcgaXMgZW5hYmxlZCwgdGhlIGVkaXRvciBpcyBhY2Nlc3NpYmxlIG9uIHRoZSBpbnN0YW5jZSB3aXRoIHRoZVxuICAgIC8vIGBlZGl0b3JgIHByb3BlcnR5LipcbiAgICB2YXIgRWRpdGFibGVNaXhpbiA9IHtcblxuICAgICAgICBjcmVhdGVFZGl0b3I6IGZ1bmN0aW9uIChtYXApIHtcbiAgICAgICAgICAgIG1hcCA9IG1hcCB8fCB0aGlzLl9tYXA7XG4gICAgICAgICAgICB2YXIgdG9vbHMgPSAodGhpcy5vcHRpb25zLmVkaXRPcHRpb25zIHx8IHt9KS5lZGl0VG9vbHMgfHwgbWFwLmVkaXRUb29scztcbiAgICAgICAgICAgIGlmICghdG9vbHMpIHRocm93IEVycm9yKCdVbmFibGUgdG8gZGV0ZWN0IEVkaXRhYmxlIGluc3RhbmNlLicpO1xuICAgICAgICAgICAgdmFyIEtsYXNzID0gdGhpcy5vcHRpb25zLmVkaXRvckNsYXNzIHx8IHRoaXMuZ2V0RWRpdG9yQ2xhc3ModG9vbHMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBLbGFzcyhtYXAsIHRoaXMsIHRoaXMub3B0aW9ucy5lZGl0T3B0aW9ucyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8g8J+Ngm1ldGhvZCBlbmFibGVFZGl0KG1hcD86IEwuTWFwKTogdGhpcy5lZGl0b3JcbiAgICAgICAgLy8gRW5hYmxlIGVkaXRpbmcsIGJ5IGNyZWF0aW5nIGFuIGVkaXRvciBpZiBub3QgZXhpc3RpbmcsIGFuZCB0aGVuIGNhbGxpbmcgYGVuYWJsZWAgb24gaXQuXG4gICAgICAgIGVuYWJsZUVkaXQ6IGZ1bmN0aW9uIChtYXApIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5lZGl0b3IpIHRoaXMuY3JlYXRlRWRpdG9yKG1hcCk7XG4gICAgICAgICAgICB0aGlzLmVkaXRvci5lbmFibGUoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVkaXRvcjtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyDwn42CbWV0aG9kIGVkaXRFbmFibGVkKCk6IGJvb2xlYW5cbiAgICAgICAgLy8gUmV0dXJuIHRydWUgaWYgY3VycmVudCBpbnN0YW5jZSBoYXMgYW4gZWRpdG9yIGF0dGFjaGVkLCBhbmQgdGhpcyBlZGl0b3IgaXMgZW5hYmxlZC5cbiAgICAgICAgZWRpdEVuYWJsZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVkaXRvciAmJiB0aGlzLmVkaXRvci5lbmFibGVkKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8g8J+Ngm1ldGhvZCBkaXNhYmxlRWRpdCgpXG4gICAgICAgIC8vIERpc2FibGUgZWRpdGluZywgYWxzbyByZW1vdmUgdGhlIGVkaXRvciBwcm9wZXJ0eSByZWZlcmVuY2UuXG4gICAgICAgIGRpc2FibGVFZGl0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5lZGl0b3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVkaXRvci5kaXNhYmxlKCk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuZWRpdG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIPCfjYJtZXRob2QgdG9nZ2xlRWRpdCgpXG4gICAgICAgIC8vIEVuYWJsZSBvciBkaXNhYmxlIGVkaXRpbmcsIGFjY29yZGluZyB0byBjdXJyZW50IHN0YXR1cy5cbiAgICAgICAgdG9nZ2xlRWRpdDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZWRpdEVuYWJsZWQoKSkgdGhpcy5kaXNhYmxlRWRpdCgpO1xuICAgICAgICAgICAgZWxzZSB0aGlzLmVuYWJsZUVkaXQoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfb25FZGl0YWJsZUFkZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZWRpdG9yKSB0aGlzLmVuYWJsZUVkaXQoKTtcbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIHZhciBQb2x5bGluZU1peGluID0ge1xuXG4gICAgICAgIGdldEVkaXRvckNsYXNzOiBmdW5jdGlvbiAodG9vbHMpIHtcbiAgICAgICAgICAgIHJldHVybiAodG9vbHMgJiYgdG9vbHMub3B0aW9ucy5wb2x5bGluZUVkaXRvckNsYXNzKSA/IHRvb2xzLm9wdGlvbnMucG9seWxpbmVFZGl0b3JDbGFzcyA6IEwuRWRpdGFibGUuUG9seWxpbmVFZGl0b3I7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2hhcGVBdDogZnVuY3Rpb24gKGxhdGxuZywgbGF0bG5ncykge1xuICAgICAgICAgICAgLy8gV2UgY2FuIGhhdmUgdGhvc2UgY2FzZXM6XG4gICAgICAgICAgICAvLyAtIGxhdGxuZ3MgYXJlIGp1c3QgYSBmbGF0IGFycmF5IG9mIGxhdGxuZ3MsIHVzZSB0aGlzXG4gICAgICAgICAgICAvLyAtIGxhdGxuZ3MgaXMgYW4gYXJyYXkgb2YgYXJyYXlzIG9mIGxhdGxuZ3MsIGxvb3Agb3ZlclxuICAgICAgICAgICAgdmFyIHNoYXBlID0gbnVsbDtcbiAgICAgICAgICAgIGxhdGxuZ3MgPSBsYXRsbmdzIHx8IHRoaXMuX2xhdGxuZ3M7XG4gICAgICAgICAgICBpZiAoIWxhdGxuZ3MubGVuZ3RoKSByZXR1cm4gc2hhcGU7XG4gICAgICAgICAgICBlbHNlIGlmIChpc0ZsYXQobGF0bG5ncykgJiYgdGhpcy5pc0luTGF0TG5ncyhsYXRsbmcsIGxhdGxuZ3MpKSBzaGFwZSA9IGxhdGxuZ3M7XG4gICAgICAgICAgICBlbHNlIGZvciAodmFyIGkgPSAwOyBpIDwgbGF0bG5ncy5sZW5ndGg7IGkrKykgaWYgKHRoaXMuaXNJbkxhdExuZ3MobGF0bG5nLCBsYXRsbmdzW2ldKSkgcmV0dXJuIGxhdGxuZ3NbaV07XG4gICAgICAgICAgICByZXR1cm4gc2hhcGU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNJbkxhdExuZ3M6IGZ1bmN0aW9uIChsLCBsYXRsbmdzKSB7XG4gICAgICAgICAgICBpZiAoIWxhdGxuZ3MpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHZhciBpLCBrLCBsZW4sIHBhcnQgPSBbXSwgcCxcbiAgICAgICAgICAgICAgICB3ID0gdGhpcy5fY2xpY2tUb2xlcmFuY2UoKTtcbiAgICAgICAgICAgIHRoaXMuX3Byb2plY3RMYXRsbmdzKGxhdGxuZ3MsIHBhcnQsIHRoaXMuX3B4Qm91bmRzKTtcbiAgICAgICAgICAgIHBhcnQgPSBwYXJ0WzBdO1xuICAgICAgICAgICAgcCA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQobCk7XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5fcHhCb3VuZHMuY29udGFpbnMocCkpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICAgICAgICBmb3IgKGkgPSAxLCBsZW4gPSBwYXJ0Lmxlbmd0aCwgayA9IDA7IGkgPCBsZW47IGsgPSBpKyspIHtcblxuICAgICAgICAgICAgICAgIGlmIChMLkxpbmVVdGlsLnBvaW50VG9TZWdtZW50RGlzdGFuY2UocCwgcGFydFtrXSwgcGFydFtpXSkgPD0gdykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICB2YXIgUG9seWdvbk1peGluID0ge1xuXG4gICAgICAgIGdldEVkaXRvckNsYXNzOiBmdW5jdGlvbiAodG9vbHMpIHtcbiAgICAgICAgICAgIHJldHVybiAodG9vbHMgJiYgdG9vbHMub3B0aW9ucy5wb2x5Z29uRWRpdG9yQ2xhc3MpID8gdG9vbHMub3B0aW9ucy5wb2x5Z29uRWRpdG9yQ2xhc3MgOiBMLkVkaXRhYmxlLlBvbHlnb25FZGl0b3I7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2hhcGVBdDogZnVuY3Rpb24gKGxhdGxuZywgbGF0bG5ncykge1xuICAgICAgICAgICAgLy8gV2UgY2FuIGhhdmUgdGhvc2UgY2FzZXM6XG4gICAgICAgICAgICAvLyAtIGxhdGxuZ3MgYXJlIGp1c3QgYSBmbGF0IGFycmF5IG9mIGxhdGxuZ3MsIHVzZSB0aGlzXG4gICAgICAgICAgICAvLyAtIGxhdGxuZ3MgaXMgYW4gYXJyYXkgb2YgYXJyYXlzIG9mIGxhdGxuZ3MsIHRoaXMgaXMgYSBzaW1wbGUgcG9seWdvbiAobWF5YmUgd2l0aCBob2xlcyksIHVzZSB0aGUgZmlyc3RcbiAgICAgICAgICAgIC8vIC0gbGF0bG5ncyBpcyBhbiBhcnJheSBvZiBhcnJheXMgb2YgYXJyYXlzLCB0aGlzIGlzIGEgbXVsdGksIGxvb3Agb3ZlclxuICAgICAgICAgICAgdmFyIHNoYXBlID0gbnVsbDtcbiAgICAgICAgICAgIGxhdGxuZ3MgPSBsYXRsbmdzIHx8IHRoaXMuX2xhdGxuZ3M7XG4gICAgICAgICAgICBpZiAoIWxhdGxuZ3MubGVuZ3RoKSByZXR1cm4gc2hhcGU7XG4gICAgICAgICAgICBlbHNlIGlmIChpc0ZsYXQobGF0bG5ncykgJiYgdGhpcy5pc0luTGF0TG5ncyhsYXRsbmcsIGxhdGxuZ3MpKSBzaGFwZSA9IGxhdGxuZ3M7XG4gICAgICAgICAgICBlbHNlIGlmIChpc0ZsYXQobGF0bG5nc1swXSkgJiYgdGhpcy5pc0luTGF0TG5ncyhsYXRsbmcsIGxhdGxuZ3NbMF0pKSBzaGFwZSA9IGxhdGxuZ3M7XG4gICAgICAgICAgICBlbHNlIGZvciAodmFyIGkgPSAwOyBpIDwgbGF0bG5ncy5sZW5ndGg7IGkrKykgaWYgKHRoaXMuaXNJbkxhdExuZ3MobGF0bG5nLCBsYXRsbmdzW2ldWzBdKSkgcmV0dXJuIGxhdGxuZ3NbaV07XG4gICAgICAgICAgICByZXR1cm4gc2hhcGU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNJbkxhdExuZ3M6IGZ1bmN0aW9uIChsLCBsYXRsbmdzKSB7XG4gICAgICAgICAgICB2YXIgaW5zaWRlID0gZmFsc2UsIGwxLCBsMiwgaiwgaywgbGVuMjtcblxuICAgICAgICAgICAgZm9yIChqID0gMCwgbGVuMiA9IGxhdGxuZ3MubGVuZ3RoLCBrID0gbGVuMiAtIDE7IGogPCBsZW4yOyBrID0gaisrKSB7XG4gICAgICAgICAgICAgICAgbDEgPSBsYXRsbmdzW2pdO1xuICAgICAgICAgICAgICAgIGwyID0gbGF0bG5nc1trXTtcblxuICAgICAgICAgICAgICAgIGlmICgoKGwxLmxhdCA+IGwubGF0KSAhPT0gKGwyLmxhdCA+IGwubGF0KSkgJiZcbiAgICAgICAgICAgICAgICAgICAgKGwubG5nIDwgKGwyLmxuZyAtIGwxLmxuZykgKiAobC5sYXQgLSBsMS5sYXQpIC8gKGwyLmxhdCAtIGwxLmxhdCkgKyBsMS5sbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGluc2lkZSA9ICFpbnNpZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gaW5zaWRlO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBhcmVudFNoYXBlOiBmdW5jdGlvbiAoc2hhcGUsIGxhdGxuZ3MpIHtcbiAgICAgICAgICAgIGxhdGxuZ3MgPSBsYXRsbmdzIHx8IHRoaXMuX2xhdGxuZ3M7XG4gICAgICAgICAgICBpZiAoIWxhdGxuZ3MpIHJldHVybjtcbiAgICAgICAgICAgIHZhciBpZHggPSBMLlV0aWwuaW5kZXhPZihsYXRsbmdzLCBzaGFwZSk7XG4gICAgICAgICAgICBpZiAoaWR4ICE9PSAtMSkgcmV0dXJuIGxhdGxuZ3M7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhdGxuZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZHggPSBMLlV0aWwuaW5kZXhPZihsYXRsbmdzW2ldLCBzaGFwZSk7XG4gICAgICAgICAgICAgICAgaWYgKGlkeCAhPT0gLTEpIHJldHVybiBsYXRsbmdzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9O1xuXG5cbiAgICB2YXIgTWFya2VyTWl4aW4gPSB7XG5cbiAgICAgICAgZ2V0RWRpdG9yQ2xhc3M6IGZ1bmN0aW9uICh0b29scykge1xuICAgICAgICAgICAgcmV0dXJuICh0b29scyAmJiB0b29scy5vcHRpb25zLm1hcmtlckVkaXRvckNsYXNzKSA/IHRvb2xzLm9wdGlvbnMubWFya2VyRWRpdG9yQ2xhc3MgOiBMLkVkaXRhYmxlLk1hcmtlckVkaXRvcjtcbiAgICAgICAgfVxuXG4gICAgfTtcblxuICAgIHZhciBSZWN0YW5nbGVNaXhpbiA9IHtcblxuICAgICAgICBnZXRFZGl0b3JDbGFzczogZnVuY3Rpb24gKHRvb2xzKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRvb2xzICYmIHRvb2xzLm9wdGlvbnMucmVjdGFuZ2xlRWRpdG9yQ2xhc3MpID8gdG9vbHMub3B0aW9ucy5yZWN0YW5nbGVFZGl0b3JDbGFzcyA6IEwuRWRpdGFibGUuUmVjdGFuZ2xlRWRpdG9yO1xuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgdmFyIENpcmNsZU1peGluID0ge1xuXG4gICAgICAgIGdldEVkaXRvckNsYXNzOiBmdW5jdGlvbiAodG9vbHMpIHtcbiAgICAgICAgICAgIHJldHVybiAodG9vbHMgJiYgdG9vbHMub3B0aW9ucy5jaXJjbGVFZGl0b3JDbGFzcykgPyB0b29scy5vcHRpb25zLmNpcmNsZUVkaXRvckNsYXNzIDogTC5FZGl0YWJsZS5DaXJjbGVFZGl0b3I7XG4gICAgICAgIH1cblxuICAgIH07XG5cbiAgICB2YXIga2VlcEVkaXRhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBNYWtlIHN1cmUgeW91IGNhbiByZW1vdmUvcmVhZGQgYW4gZWRpdGFibGUgbGF5ZXIuXG4gICAgICAgIHRoaXMub24oJ2FkZCcsIHRoaXMuX29uRWRpdGFibGVBZGQpO1xuICAgIH07XG5cbiAgICB2YXIgaXNGbGF0ID0gTC5MaW5lVXRpbC5pc0ZsYXQgfHwgTC5MaW5lVXRpbC5fZmxhdCB8fCBMLlBvbHlsaW5lLl9mbGF0OyAgLy8gPD0+IDEuMSBjb21wYXQuXG5cblxuICAgIGlmIChMLlBvbHlsaW5lKSB7XG4gICAgICAgIEwuUG9seWxpbmUuaW5jbHVkZShFZGl0YWJsZU1peGluKTtcbiAgICAgICAgTC5Qb2x5bGluZS5pbmNsdWRlKFBvbHlsaW5lTWl4aW4pO1xuICAgICAgICBMLlBvbHlsaW5lLmFkZEluaXRIb29rKGtlZXBFZGl0YWJsZSk7XG4gICAgfVxuICAgIGlmIChMLlBvbHlnb24pIHtcbiAgICAgICAgTC5Qb2x5Z29uLmluY2x1ZGUoRWRpdGFibGVNaXhpbik7XG4gICAgICAgIEwuUG9seWdvbi5pbmNsdWRlKFBvbHlnb25NaXhpbik7XG4gICAgfVxuICAgIGlmIChMLk1hcmtlcikge1xuICAgICAgICBMLk1hcmtlci5pbmNsdWRlKEVkaXRhYmxlTWl4aW4pO1xuICAgICAgICBMLk1hcmtlci5pbmNsdWRlKE1hcmtlck1peGluKTtcbiAgICAgICAgTC5NYXJrZXIuYWRkSW5pdEhvb2soa2VlcEVkaXRhYmxlKTtcbiAgICB9XG4gICAgaWYgKEwuUmVjdGFuZ2xlKSB7XG4gICAgICAgIEwuUmVjdGFuZ2xlLmluY2x1ZGUoRWRpdGFibGVNaXhpbik7XG4gICAgICAgIEwuUmVjdGFuZ2xlLmluY2x1ZGUoUmVjdGFuZ2xlTWl4aW4pO1xuICAgIH1cbiAgICBpZiAoTC5DaXJjbGUpIHtcbiAgICAgICAgTC5DaXJjbGUuaW5jbHVkZShFZGl0YWJsZU1peGluKTtcbiAgICAgICAgTC5DaXJjbGUuaW5jbHVkZShDaXJjbGVNaXhpbik7XG4gICAgfVxuXG4gICAgTC5MYXRMbmcucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChsYXRsbmcpIHtcbiAgICAgICAgbGF0bG5nID0gTC5sYXRMbmcobGF0bG5nKTtcbiAgICAgICAgdGhpcy5sYXQgPSBsYXRsbmcubGF0O1xuICAgICAgICB0aGlzLmxuZyA9IGxhdGxuZy5sbmc7XG4gICAgfVxufVxuaW5pdCh3aW5kb3cuTClcblxuIl19\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(0);\n\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// Vue2LeafletEditablePlugin.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap fc5a58050f4a70b48c6e","function init(L){\n    // 🍂miniclass CancelableEvent (Event objects)\n    // 🍂method cancel()\n    // Cancel any subsequent action.\n\n    // 🍂miniclass VertexEvent (Event objects)\n    // 🍂property vertex: VertexMarker\n    // The vertex that fires the event.\n\n    // 🍂miniclass ShapeEvent (Event objects)\n    // 🍂property shape: Array\n    // The shape (LatLngs array) subject of the action.\n\n    // 🍂miniclass CancelableVertexEvent (Event objects)\n    // 🍂inherits VertexEvent\n    // 🍂inherits CancelableEvent\n\n    // 🍂miniclass CancelableShapeEvent (Event objects)\n    // 🍂inherits ShapeEvent\n    // 🍂inherits CancelableEvent\n\n    // 🍂miniclass LayerEvent (Event objects)\n    // 🍂property layer: object\n    // The Layer (Marker, Polyline…) subject of the action.\n\n    // 🍂namespace Editable; 🍂class Editable; 🍂aka L.Editable\n    // Main edition handler. By default, it is attached to the map\n    // as `map.editTools` property.\n    // Leaflet.Editable is made to be fully extendable. You have three ways to customize\n    // the behaviour: using options, listening to events, or extending.\n    L.Editable = L.Evented.extend({\n\n        statics: {\n            FORWARD: 1,\n            BACKWARD: -1\n        },\n\n        options: {\n\n            // You can pass them when creating a map using the `editOptions` key.\n            // 🍂option zIndex: int = 1000\n            // The default zIndex of the editing tools.\n            zIndex: 1000,\n\n            // 🍂option polygonClass: class = L.Polygon\n            // Class to be used when creating a new Polygon.\n            polygonClass: L.Polygon,\n\n            // 🍂option polylineClass: class = L.Polyline\n            // Class to be used when creating a new Polyline.\n            polylineClass: L.Polyline,\n\n            // 🍂option markerClass: class = L.Marker\n            // Class to be used when creating a new Marker.\n            markerClass: L.Marker,\n\n            // 🍂option rectangleClass: class = L.Rectangle\n            // Class to be used when creating a new Rectangle.\n            rectangleClass: L.Rectangle,\n\n            // 🍂option circleClass: class = L.Circle\n            // Class to be used when creating a new Circle.\n            circleClass: L.Circle,\n\n            // 🍂option drawingCSSClass: string = 'leaflet-editable-drawing'\n            // CSS class to be added to the map container while drawing.\n            drawingCSSClass: 'leaflet-editable-drawing',\n\n            // 🍂option drawingCursor: const = 'crosshair'\n            // Cursor mode set to the map while drawing.\n            drawingCursor: 'crosshair',\n\n            // 🍂option editLayer: Layer = new L.LayerGroup()\n            // Layer used to store edit tools (vertex, line guide…).\n            editLayer: undefined,\n\n            // 🍂option featuresLayer: Layer = new L.LayerGroup()\n            // Default layer used to store drawn features (Marker, Polyline…).\n            featuresLayer: undefined,\n\n            // 🍂option polylineEditorClass: class = PolylineEditor\n            // Class to be used as Polyline editor.\n            polylineEditorClass: undefined,\n\n            // 🍂option polygonEditorClass: class = PolygonEditor\n            // Class to be used as Polygon editor.\n            polygonEditorClass: undefined,\n\n            // 🍂option markerEditorClass: class = MarkerEditor\n            // Class to be used as Marker editor.\n            markerEditorClass: undefined,\n\n            // 🍂option rectangleEditorClass: class = RectangleEditor\n            // Class to be used as Rectangle editor.\n            rectangleEditorClass: undefined,\n\n            // 🍂option circleEditorClass: class = CircleEditor\n            // Class to be used as Circle editor.\n            circleEditorClass: undefined,\n\n            // 🍂option lineGuideOptions: hash = {}\n            // Options to be passed to the line guides.\n            lineGuideOptions: {},\n\n            // 🍂option skipMiddleMarkers: boolean = false\n            // Set this to true if you don't want middle markers.\n            skipMiddleMarkers: false\n\n        },\n\n        initialize: function (map, options) {\n            L.setOptions(this, options);\n            this._lastZIndex = this.options.zIndex;\n            this.map = map;\n            this.editLayer = this.createEditLayer();\n            this.featuresLayer = this.createFeaturesLayer();\n            this.forwardLineGuide = this.createLineGuide();\n            this.backwardLineGuide = this.createLineGuide();\n        },\n\n        fireAndForward: function (type, e) {\n            e = e || {};\n            e.editTools = this;\n            this.fire(type, e);\n            this.map.fire(type, e);\n        },\n\n        createLineGuide: function () {\n            var options = L.extend({dashArray: '5,10', weight: 1, interactive: false}, this.options.lineGuideOptions);\n            return L.polyline([], options);\n        },\n\n        createVertexIcon: function (options) {\n            return L.Browser.mobile && L.Browser.touch ? new L.Editable.TouchVertexIcon(options) : new L.Editable.VertexIcon(options);\n        },\n\n        createEditLayer: function () {\n            return this.options.editLayer || new L.LayerGroup().addTo(this.map);\n        },\n\n        createFeaturesLayer: function () {\n            return this.options.featuresLayer || new L.LayerGroup().addTo(this.map);\n        },\n\n        moveForwardLineGuide: function (latlng) {\n            if (this.forwardLineGuide._latlngs.length) {\n                this.forwardLineGuide._latlngs[1] = latlng;\n                this.forwardLineGuide._bounds.extend(latlng);\n                this.forwardLineGuide.redraw();\n            }\n        },\n\n        moveBackwardLineGuide: function (latlng) {\n            if (this.backwardLineGuide._latlngs.length) {\n                this.backwardLineGuide._latlngs[1] = latlng;\n                this.backwardLineGuide._bounds.extend(latlng);\n                this.backwardLineGuide.redraw();\n            }\n        },\n\n        anchorForwardLineGuide: function (latlng) {\n            this.forwardLineGuide._latlngs[0] = latlng;\n            this.forwardLineGuide._bounds.extend(latlng);\n            this.forwardLineGuide.redraw();\n        },\n\n        anchorBackwardLineGuide: function (latlng) {\n            this.backwardLineGuide._latlngs[0] = latlng;\n            this.backwardLineGuide._bounds.extend(latlng);\n            this.backwardLineGuide.redraw();\n        },\n\n        attachForwardLineGuide: function () {\n            this.editLayer.addLayer(this.forwardLineGuide);\n        },\n\n        attachBackwardLineGuide: function () {\n            this.editLayer.addLayer(this.backwardLineGuide);\n        },\n\n        detachForwardLineGuide: function () {\n            this.forwardLineGuide.setLatLngs([]);\n            this.editLayer.removeLayer(this.forwardLineGuide);\n        },\n\n        detachBackwardLineGuide: function () {\n            this.backwardLineGuide.setLatLngs([]);\n            this.editLayer.removeLayer(this.backwardLineGuide);\n        },\n\n        blockEvents: function () {\n            // Hack: force map not to listen to other layers events while drawing.\n            if (!this._oldTargets) {\n                this._oldTargets = this.map._targets;\n                this.map._targets = {};\n            }\n        },\n\n        unblockEvents: function () {\n            if (this._oldTargets) {\n                // Reset, but keep targets created while drawing.\n                this.map._targets = L.extend(this.map._targets, this._oldTargets);\n                delete this._oldTargets;\n            }\n        },\n\n        registerForDrawing: function (editor) {\n            if (this._drawingEditor) this.unregisterForDrawing(this._drawingEditor);\n            this.blockEvents();\n            editor.reset();  // Make sure editor tools still receive events.\n            this._drawingEditor = editor;\n            this.map.on('mousemove touchmove', editor.onDrawingMouseMove, editor);\n            this.map.on('mousedown', this.onMousedown, this);\n            this.map.on('mouseup', this.onMouseup, this);\n            L.DomUtil.addClass(this.map._container, this.options.drawingCSSClass);\n            this.defaultMapCursor = this.map._container.style.cursor;\n            this.map._container.style.cursor = this.options.drawingCursor;\n        },\n\n        unregisterForDrawing: function (editor) {\n            this.unblockEvents();\n            L.DomUtil.removeClass(this.map._container, this.options.drawingCSSClass);\n            this.map._container.style.cursor = this.defaultMapCursor;\n            editor = editor || this._drawingEditor;\n            if (!editor) return;\n            this.map.off('mousemove touchmove', editor.onDrawingMouseMove, editor);\n            this.map.off('mousedown', this.onMousedown, this);\n            this.map.off('mouseup', this.onMouseup, this);\n            if (editor !== this._drawingEditor) return;\n            delete this._drawingEditor;\n            if (editor._drawing) editor.cancelDrawing();\n        },\n\n        onMousedown: function (e) {\n            if (e.originalEvent.which != 1) return;\n            this._mouseDown = e;\n            this._drawingEditor.onDrawingMouseDown(e);\n        },\n\n        onMouseup: function (e) {\n            if (this._mouseDown) {\n                var editor = this._drawingEditor,\n                    mouseDown = this._mouseDown;\n                this._mouseDown = null;\n                editor.onDrawingMouseUp(e);\n                if (this._drawingEditor !== editor) return;  // onDrawingMouseUp may call unregisterFromDrawing.\n                var origin = L.point(mouseDown.originalEvent.clientX, mouseDown.originalEvent.clientY);\n                var distance = L.point(e.originalEvent.clientX, e.originalEvent.clientY).distanceTo(origin);\n                if (Math.abs(distance) < 9 * (window.devicePixelRatio || 1)) this._drawingEditor.onDrawingClick(e);\n            }\n        },\n\n        // 🍂section Public methods\n        // You will generally access them by the `map.editTools`\n        // instance:\n        //\n        // `map.editTools.startPolyline();`\n\n        // 🍂method drawing(): boolean\n        // Return true if any drawing action is ongoing.\n        drawing: function () {\n            return this._drawingEditor && this._drawingEditor.drawing();\n        },\n\n        // 🍂method stopDrawing()\n        // When you need to stop any ongoing drawing, without needing to know which editor is active.\n        stopDrawing: function () {\n            this.unregisterForDrawing();\n        },\n\n        // 🍂method commitDrawing()\n        // When you need to commit any ongoing drawing, without needing to know which editor is active.\n        commitDrawing: function (e) {\n            if (!this._drawingEditor) return;\n            this._drawingEditor.commitDrawing(e);\n        },\n\n        connectCreatedToMap: function (layer) {\n            return this.featuresLayer.addLayer(layer);\n        },\n\n        // 🍂method startPolyline(latlng: L.LatLng, options: hash): L.Polyline\n        // Start drawing a Polyline. If `latlng` is given, a first point will be added. In any case, continuing on user click.\n        // If `options` is given, it will be passed to the Polyline class constructor.\n        startPolyline: function (latlng, options) {\n            var line = this.createPolyline([], options);\n            line.enableEdit(this.map).newShape(latlng);\n            return line;\n        },\n\n        // 🍂method startPolygon(latlng: L.LatLng, options: hash): L.Polygon\n        // Start drawing a Polygon. If `latlng` is given, a first point will be added. In any case, continuing on user click.\n        // If `options` is given, it will be passed to the Polygon class constructor.\n        startPolygon: function (latlng, options) {\n            var polygon = this.createPolygon([], options);\n            polygon.enableEdit(this.map).newShape(latlng);\n            return polygon;\n        },\n\n        // 🍂method startMarker(latlng: L.LatLng, options: hash): L.Marker\n        // Start adding a Marker. If `latlng` is given, the Marker will be shown first at this point.\n        // In any case, it will follow the user mouse, and will have a final `latlng` on next click (or touch).\n        // If `options` is given, it will be passed to the Marker class constructor.\n        startMarker: function (latlng, options) {\n            latlng = latlng || this.map.getCenter().clone();\n            var marker = this.createMarker(latlng, options);\n            marker.enableEdit(this.map).startDrawing();\n            return marker;\n        },\n\n        // 🍂method startRectangle(latlng: L.LatLng, options: hash): L.Rectangle\n        // Start drawing a Rectangle. If `latlng` is given, the Rectangle anchor will be added. In any case, continuing on user drag.\n        // If `options` is given, it will be passed to the Rectangle class constructor.\n        startRectangle: function(latlng, options) {\n            var corner = latlng || L.latLng([0, 0]);\n            var bounds = new L.LatLngBounds(corner, corner);\n            var rectangle = this.createRectangle(bounds, options);\n            rectangle.enableEdit(this.map).startDrawing();\n            return rectangle;\n        },\n\n        // 🍂method startCircle(latlng: L.LatLng, options: hash): L.Circle\n        // Start drawing a Circle. If `latlng` is given, the Circle anchor will be added. In any case, continuing on user drag.\n        // If `options` is given, it will be passed to the Circle class constructor.\n        startCircle: function (latlng, options) {\n            latlng = latlng || this.map.getCenter().clone();\n            var circle = this.createCircle(latlng, options);\n            circle.enableEdit(this.map).startDrawing();\n            return circle;\n        },\n\n        startHole: function (editor, latlng) {\n            editor.newHole(latlng);\n        },\n\n        createLayer: function (klass, latlngs, options) {\n            options = L.Util.extend({editOptions: {editTools: this}}, options);\n            var layer = new klass(latlngs, options);\n            // 🍂namespace Editable\n            // 🍂event editable:created: LayerEvent\n            // Fired when a new feature (Marker, Polyline…) is created.\n            this.fireAndForward('editable:created', {layer: layer});\n            return layer;\n        },\n\n        createPolyline: function (latlngs, options) {\n            return this.createLayer(options && options.polylineClass || this.options.polylineClass, latlngs, options);\n        },\n\n        createPolygon: function (latlngs, options) {\n            return this.createLayer(options && options.polygonClass || this.options.polygonClass, latlngs, options);\n        },\n\n        createMarker: function (latlng, options) {\n            return this.createLayer(options && options.markerClass || this.options.markerClass, latlng, options);\n        },\n\n        createRectangle: function (bounds, options) {\n            return this.createLayer(options && options.rectangleClass || this.options.rectangleClass, bounds, options);\n        },\n\n        createCircle: function (latlng, options) {\n            return this.createLayer(options && options.circleClass || this.options.circleClass, latlng, options);\n        }\n\n    });\n\n    L.extend(L.Editable, {\n\n        makeCancellable: function (e) {\n            e.cancel = function () {\n                e._cancelled = true;\n            };\n        }\n\n    });\n\n    // 🍂namespace Map; 🍂class Map\n    // Leaflet.Editable add options and events to the `L.Map` object.\n    // See `Editable` events for the list of events fired on the Map.\n    // 🍂example\n    //\n    // ```js\n    // var map = L.map('map', {\n    //  editable: true,\n    //  editOptions: {\n    //    …\n    // }\n    // });\n    // ```\n    // 🍂section Editable Map Options\n    L.Map.mergeOptions({\n\n        // 🍂namespace Map\n        // 🍂section Map Options\n        // 🍂option editToolsClass: class = L.Editable\n        // Class to be used as vertex, for path editing.\n        editToolsClass: L.Editable,\n\n        // 🍂option editable: boolean = false\n        // Whether to create a L.Editable instance at map init.\n        editable: false,\n\n        // 🍂option editOptions: hash = {}\n        // Options to pass to L.Editable when instantiating.\n        editOptions: {}\n\n    });\n\n    L.Map.addInitHook(function () {\n\n        this.whenReady(function () {\n            if (this.options.editable) {\n                this.editTools = new this.options.editToolsClass(this, this.options.editOptions);\n            }\n        });\n\n    });\n\n    L.Editable.VertexIcon = L.DivIcon.extend({\n\n        options: {\n            iconSize: new L.Point(8, 8)\n        }\n\n    });\n\n    L.Editable.TouchVertexIcon = L.Editable.VertexIcon.extend({\n\n        options: {\n            iconSize: new L.Point(20, 20)\n        }\n\n    });\n\n\n    // 🍂namespace Editable; 🍂class VertexMarker; Handler for dragging path vertices.\n    L.Editable.VertexMarker = L.Marker.extend({\n\n        options: {\n            draggable: true,\n            className: 'leaflet-div-icon leaflet-vertex-icon'\n        },\n\n\n        // 🍂section Public methods\n        // The marker used to handle path vertex. You will usually interact with a `VertexMarker`\n        // instance when listening for events like `editable:vertex:ctrlclick`.\n\n        initialize: function (latlng, latlngs, editor, options) {\n            // We don't use this._latlng, because on drag Leaflet replace it while\n            // we want to keep reference.\n            this.latlng = latlng;\n            this.latlngs = latlngs;\n            this.editor = editor;\n            L.Marker.prototype.initialize.call(this, latlng, options);\n            this.options.icon = this.editor.tools.createVertexIcon({className: this.options.className});\n            this.latlng.__vertex = this;\n            this.editor.editLayer.addLayer(this);\n            this.setZIndexOffset(editor.tools._lastZIndex + 1);\n        },\n\n        onAdd: function (map) {\n            L.Marker.prototype.onAdd.call(this, map);\n            this.on('drag', this.onDrag);\n            this.on('dragstart', this.onDragStart);\n            this.on('dragend', this.onDragEnd);\n            this.on('mouseup', this.onMouseup);\n            this.on('click', this.onClick);\n            this.on('contextmenu', this.onContextMenu);\n            this.on('mousedown touchstart', this.onMouseDown);\n            this.on('mouseover', this.onMouseOver);\n            this.on('mouseout', this.onMouseOut);\n            this.addMiddleMarkers();\n        },\n\n        onRemove: function (map) {\n            if (this.middleMarker) this.middleMarker.delete();\n            delete this.latlng.__vertex;\n            this.off('drag', this.onDrag);\n            this.off('dragstart', this.onDragStart);\n            this.off('dragend', this.onDragEnd);\n            this.off('mouseup', this.onMouseup);\n            this.off('click', this.onClick);\n            this.off('contextmenu', this.onContextMenu);\n            this.off('mousedown touchstart', this.onMouseDown);\n            this.off('mouseover', this.onMouseOver);\n            this.off('mouseout', this.onMouseOut);\n            L.Marker.prototype.onRemove.call(this, map);\n        },\n\n        onDrag: function (e) {\n            e.vertex = this;\n            this.editor.onVertexMarkerDrag(e);\n            var iconPos = L.DomUtil.getPosition(this._icon),\n                latlng = this._map.layerPointToLatLng(iconPos);\n            this.latlng.update(latlng);\n            this._latlng = this.latlng;  // Push back to Leaflet our reference.\n            this.editor.refresh();\n            if (this.middleMarker) this.middleMarker.updateLatLng();\n            var next = this.getNext();\n            if (next && next.middleMarker) next.middleMarker.updateLatLng();\n        },\n\n        onDragStart: function (e) {\n            e.vertex = this;\n            this.editor.onVertexMarkerDragStart(e);\n        },\n\n        onDragEnd: function (e) {\n            e.vertex = this;\n            this.editor.onVertexMarkerDragEnd(e);\n        },\n\n        onClick: function (e) {\n            e.vertex = this;\n            this.editor.onVertexMarkerClick(e);\n        },\n\n        onMouseup: function (e) {\n            L.DomEvent.stop(e);\n            e.vertex = this;\n            this.editor.map.fire('mouseup', e);\n        },\n\n        onContextMenu: function (e) {\n            e.vertex = this;\n            this.editor.onVertexMarkerContextMenu(e);\n        },\n\n        onMouseDown: function (e) {\n            e.vertex = this;\n            this.editor.onVertexMarkerMouseDown(e);\n        },\n\n        onMouseOver: function (e) {\n            e.vertex = this;\n            this.editor.onVertexMarkerMouseOver(e);\n        },\n\n        onMouseOut: function (e) {\n            e.vertex = this;\n            this.editor.onVertexMarkerMouseOut(e);\n        },\n\n        // 🍂method delete()\n        // Delete a vertex and the related LatLng.\n        delete: function () {\n            var next = this.getNext();  // Compute before changing latlng\n            this.latlngs.splice(this.getIndex(), 1);\n            this.editor.editLayer.removeLayer(this);\n            this.editor.onVertexDeleted({latlng: this.latlng, vertex: this});\n            if (!this.latlngs.length) this.editor.deleteShape(this.latlngs);\n            if (next) next.resetMiddleMarker();\n            this.editor.refresh();\n        },\n\n        // 🍂method getIndex(): int\n        // Get the index of the current vertex among others of the same LatLngs group.\n        getIndex: function () {\n            return this.latlngs.indexOf(this.latlng);\n        },\n\n        // 🍂method getLastIndex(): int\n        // Get last vertex index of the LatLngs group of the current vertex.\n        getLastIndex: function () {\n            return this.latlngs.length - 1;\n        },\n\n        // 🍂method getPrevious(): VertexMarker\n        // Get the previous VertexMarker in the same LatLngs group.\n        getPrevious: function () {\n            if (this.latlngs.length < 2) return;\n            var index = this.getIndex(),\n                previousIndex = index - 1;\n            if (index === 0 && this.editor.CLOSED) previousIndex = this.getLastIndex();\n            var previous = this.latlngs[previousIndex];\n            if (previous) return previous.__vertex;\n        },\n\n        // 🍂method getNext(): VertexMarker\n        // Get the next VertexMarker in the same LatLngs group.\n        getNext: function () {\n            if (this.latlngs.length < 2) return;\n            var index = this.getIndex(),\n                nextIndex = index + 1;\n            if (index === this.getLastIndex() && this.editor.CLOSED) nextIndex = 0;\n            var next = this.latlngs[nextIndex];\n            if (next) return next.__vertex;\n        },\n\n        addMiddleMarker: function (previous) {\n            if (!this.editor.hasMiddleMarkers()) return;\n            previous = previous || this.getPrevious();\n            if (previous && !this.middleMarker) this.middleMarker = this.editor.addMiddleMarker(previous, this, this.latlngs, this.editor);\n        },\n\n        addMiddleMarkers: function () {\n            if (!this.editor.hasMiddleMarkers()) return;\n            var previous = this.getPrevious();\n            if (previous) this.addMiddleMarker(previous);\n            var next = this.getNext();\n            if (next) next.resetMiddleMarker();\n        },\n\n        resetMiddleMarker: function () {\n            if (this.middleMarker) this.middleMarker.delete();\n            this.addMiddleMarker();\n        },\n\n        // 🍂method split()\n        // Split the vertex LatLngs group at its index, if possible.\n        split: function () {\n            if (!this.editor.splitShape) return;  // Only for PolylineEditor\n            this.editor.splitShape(this.latlngs, this.getIndex());\n        },\n\n        // 🍂method continue()\n        // Continue the vertex LatLngs from this vertex. Only active for first and last vertices of a Polyline.\n        continue: function () {\n            if (!this.editor.continueBackward) return;  // Only for PolylineEditor\n            var index = this.getIndex();\n            if (index === 0) this.editor.continueBackward(this.latlngs);\n            else if (index === this.getLastIndex()) this.editor.continueForward(this.latlngs);\n        }\n\n    });\n\n    L.Editable.mergeOptions({\n\n        // 🍂namespace Editable\n        // 🍂option vertexMarkerClass: class = VertexMarker\n        // Class to be used as vertex, for path editing.\n        vertexMarkerClass: L.Editable.VertexMarker\n\n    });\n\n    L.Editable.MiddleMarker = L.Marker.extend({\n\n        options: {\n            opacity: 0.5,\n            className: 'leaflet-div-icon leaflet-middle-icon',\n            draggable: true\n        },\n\n        initialize: function (left, right, latlngs, editor, options) {\n            this.left = left;\n            this.right = right;\n            this.editor = editor;\n            this.latlngs = latlngs;\n            L.Marker.prototype.initialize.call(this, this.computeLatLng(), options);\n            this._opacity = this.options.opacity;\n            this.options.icon = this.editor.tools.createVertexIcon({className: this.options.className});\n            this.editor.editLayer.addLayer(this);\n            this.setVisibility();\n        },\n\n        setVisibility: function () {\n            var leftPoint = this._map.latLngToContainerPoint(this.left.latlng),\n                rightPoint = this._map.latLngToContainerPoint(this.right.latlng),\n                size = L.point(this.options.icon.options.iconSize);\n            if (leftPoint.distanceTo(rightPoint) < size.x * 3) this.hide();\n            else this.show();\n        },\n\n        show: function () {\n            this.setOpacity(this._opacity);\n        },\n\n        hide: function () {\n            this.setOpacity(0);\n        },\n\n        updateLatLng: function () {\n            this.setLatLng(this.computeLatLng());\n            this.setVisibility();\n        },\n\n        computeLatLng: function () {\n            var leftPoint = this.editor.map.latLngToContainerPoint(this.left.latlng),\n                rightPoint = this.editor.map.latLngToContainerPoint(this.right.latlng),\n                y = (leftPoint.y + rightPoint.y) / 2,\n                x = (leftPoint.x + rightPoint.x) / 2;\n            return this.editor.map.containerPointToLatLng([x, y]);\n        },\n\n        onAdd: function (map) {\n            L.Marker.prototype.onAdd.call(this, map);\n            L.DomEvent.on(this._icon, 'mousedown touchstart', this.onMouseDown, this);\n            map.on('zoomend', this.setVisibility, this);\n        },\n\n        onRemove: function (map) {\n            delete this.right.middleMarker;\n            L.DomEvent.off(this._icon, 'mousedown touchstart', this.onMouseDown, this);\n            map.off('zoomend', this.setVisibility, this);\n            L.Marker.prototype.onRemove.call(this, map);\n        },\n\n        onMouseDown: function (e) {\n            var iconPos = L.DomUtil.getPosition(this._icon),\n                latlng = this.editor.map.layerPointToLatLng(iconPos);\n            e = {\n                originalEvent: e,\n                latlng: latlng\n            };\n            if (this.options.opacity === 0) return;\n            L.Editable.makeCancellable(e);\n            this.editor.onMiddleMarkerMouseDown(e);\n            if (e._cancelled) return;\n            this.latlngs.splice(this.index(), 0, e.latlng);\n            this.editor.refresh();\n            var icon = this._icon;\n            var marker = this.editor.addVertexMarker(e.latlng, this.latlngs);\n            this.editor.onNewVertex(marker);\n            /* Hack to workaround browser not firing touchend when element is no more on DOM */\n            var parent = marker._icon.parentNode;\n            parent.removeChild(marker._icon);\n            marker._icon = icon;\n            parent.appendChild(marker._icon);\n            marker._initIcon();\n            marker._initInteraction();\n            marker.setOpacity(1);\n            /* End hack */\n            // Transfer ongoing dragging to real marker\n            L.Draggable._dragging = false;\n            marker.dragging._draggable._onDown(e.originalEvent);\n            this.delete();\n        },\n\n        delete: function () {\n            this.editor.editLayer.removeLayer(this);\n        },\n\n        index: function () {\n            return this.latlngs.indexOf(this.right.latlng);\n        }\n\n    });\n\n    L.Editable.mergeOptions({\n\n        // 🍂namespace Editable\n        // 🍂option middleMarkerClass: class = VertexMarker\n        // Class to be used as middle vertex, pulled by the user to create a new point in the middle of a path.\n        middleMarkerClass: L.Editable.MiddleMarker\n\n    });\n\n    // 🍂namespace Editable; 🍂class BaseEditor; 🍂aka L.Editable.BaseEditor\n    // When editing a feature (Marker, Polyline…), an editor is attached to it. This\n    // editor basically knows how to handle the edition.\n    L.Editable.BaseEditor = L.Handler.extend({\n\n        initialize: function (map, feature, options) {\n            L.setOptions(this, options);\n            this.map = map;\n            this.feature = feature;\n            this.feature.editor = this;\n            this.editLayer = new L.LayerGroup();\n            this.tools = this.options.editTools || map.editTools;\n        },\n\n        // 🍂method enable(): this\n        // Set up the drawing tools for the feature to be editable.\n        addHooks: function () {\n            if (this.isConnected()) this.onFeatureAdd();\n            else this.feature.once('add', this.onFeatureAdd, this);\n            this.onEnable();\n            this.feature.on(this._getEvents(), this);\n        },\n\n        // 🍂method disable(): this\n        // Remove the drawing tools for the feature.\n        removeHooks: function () {\n            this.feature.off(this._getEvents(), this);\n            if (this.feature.dragging) this.feature.dragging.disable();\n            this.editLayer.clearLayers();\n            this.tools.editLayer.removeLayer(this.editLayer);\n            this.onDisable();\n            if (this._drawing) this.cancelDrawing();\n        },\n\n        // 🍂method drawing(): boolean\n        // Return true if any drawing action is ongoing with this editor.\n        drawing: function () {\n            return !!this._drawing;\n        },\n\n        reset: function () {},\n\n        onFeatureAdd: function () {\n            this.tools.editLayer.addLayer(this.editLayer);\n            if (this.feature.dragging) this.feature.dragging.enable();\n        },\n\n        hasMiddleMarkers: function () {\n            return !this.options.skipMiddleMarkers && !this.tools.options.skipMiddleMarkers;\n        },\n\n        fireAndForward: function (type, e) {\n            e = e || {};\n            e.layer = this.feature;\n            this.feature.fire(type, e);\n            this.tools.fireAndForward(type, e);\n        },\n\n        onEnable: function () {\n            // 🍂namespace Editable\n            // 🍂event editable:enable: Event\n            // Fired when an existing feature is ready to be edited.\n            this.fireAndForward('editable:enable');\n        },\n\n        onDisable: function () {\n            // 🍂namespace Editable\n            // 🍂event editable:disable: Event\n            // Fired when an existing feature is not ready anymore to be edited.\n            this.fireAndForward('editable:disable');\n        },\n\n        onEditing: function () {\n            // 🍂namespace Editable\n            // 🍂event editable:editing: Event\n            // Fired as soon as any change is made to the feature geometry.\n            this.fireAndForward('editable:editing');\n        },\n\n        onStartDrawing: function () {\n            // 🍂namespace Editable\n            // 🍂section Drawing events\n            // 🍂event editable:drawing:start: Event\n            // Fired when a feature is to be drawn.\n            this.fireAndForward('editable:drawing:start');\n        },\n\n        onEndDrawing: function () {\n            // 🍂namespace Editable\n            // 🍂section Drawing events\n            // 🍂event editable:drawing:end: Event\n            // Fired when a feature is not drawn anymore.\n            this.fireAndForward('editable:drawing:end');\n        },\n\n        onCancelDrawing: function () {\n            // 🍂namespace Editable\n            // 🍂section Drawing events\n            // 🍂event editable:drawing:cancel: Event\n            // Fired when user cancel drawing while a feature is being drawn.\n            this.fireAndForward('editable:drawing:cancel');\n        },\n\n        onCommitDrawing: function (e) {\n            // 🍂namespace Editable\n            // 🍂section Drawing events\n            // 🍂event editable:drawing:commit: Event\n            // Fired when user finish drawing a feature.\n            this.fireAndForward('editable:drawing:commit', e);\n        },\n\n        onDrawingMouseDown: function (e) {\n            // 🍂namespace Editable\n            // 🍂section Drawing events\n            // 🍂event editable:drawing:mousedown: Event\n            // Fired when user `mousedown` while drawing.\n            this.fireAndForward('editable:drawing:mousedown', e);\n        },\n\n        onDrawingMouseUp: function (e) {\n            // 🍂namespace Editable\n            // 🍂section Drawing events\n            // 🍂event editable:drawing:mouseup: Event\n            // Fired when user `mouseup` while drawing.\n            this.fireAndForward('editable:drawing:mouseup', e);\n        },\n\n        startDrawing: function () {\n            if (!this._drawing) this._drawing = L.Editable.FORWARD;\n            this.tools.registerForDrawing(this);\n            this.onStartDrawing();\n        },\n\n        commitDrawing: function (e) {\n            this.onCommitDrawing(e);\n            this.endDrawing();\n        },\n\n        cancelDrawing: function () {\n            // If called during a vertex drag, the vertex will be removed before\n            // the mouseup fires on it. This is a workaround. Maybe better fix is\n            // To have L.Draggable reset it's status on disable (Leaflet side).\n            L.Draggable._dragging = false;\n            this.onCancelDrawing();\n            this.endDrawing();\n        },\n\n        endDrawing: function () {\n            this._drawing = false;\n            this.tools.unregisterForDrawing(this);\n            this.onEndDrawing();\n        },\n\n        onDrawingClick: function (e) {\n            if (!this.drawing()) return;\n            L.Editable.makeCancellable(e);\n            // 🍂namespace Editable\n            // 🍂section Drawing events\n            // 🍂event editable:drawing:click: CancelableEvent\n            // Fired when user `click` while drawing, before any internal action is being processed.\n            this.fireAndForward('editable:drawing:click', e);\n            if (e._cancelled) return;\n            if (!this.isConnected()) this.connect(e);\n            this.processDrawingClick(e);\n        },\n\n        isConnected: function () {\n            return this.map.hasLayer(this.feature);\n        },\n\n        connect: function () {\n            this.tools.connectCreatedToMap(this.feature);\n            this.tools.editLayer.addLayer(this.editLayer);\n        },\n\n        onMove: function (e) {\n            // 🍂namespace Editable\n            // 🍂section Drawing events\n            // 🍂event editable:drawing:move: Event\n            // Fired when `move` mouse while drawing, while dragging a marker, and while dragging a vertex.\n            this.fireAndForward('editable:drawing:move', e);\n        },\n\n        onDrawingMouseMove: function (e) {\n            this.onMove(e);\n        },\n\n        _getEvents: function () {\n            return {\n                dragstart: this.onDragStart,\n                drag: this.onDrag,\n                dragend: this.onDragEnd,\n                remove: this.disable\n            };\n        },\n\n        onDragStart: function (e) {\n            this.onEditing();\n            // 🍂namespace Editable\n            // 🍂event editable:dragstart: Event\n            // Fired before a path feature is dragged.\n            this.fireAndForward('editable:dragstart', e);\n        },\n\n        onDrag: function (e) {\n            this.onMove(e);\n            // 🍂namespace Editable\n            // 🍂event editable:drag: Event\n            // Fired when a path feature is being dragged.\n            this.fireAndForward('editable:drag', e);\n        },\n\n        onDragEnd: function (e) {\n            // 🍂namespace Editable\n            // 🍂event editable:dragend: Event\n            // Fired after a path feature has been dragged.\n            this.fireAndForward('editable:dragend', e);\n        }\n\n    });\n\n    // 🍂namespace Editable; 🍂class MarkerEditor; 🍂aka L.Editable.MarkerEditor\n    // 🍂inherits BaseEditor\n    // Editor for Marker.\n    L.Editable.MarkerEditor = L.Editable.BaseEditor.extend({\n\n        onDrawingMouseMove: function (e) {\n            L.Editable.BaseEditor.prototype.onDrawingMouseMove.call(this, e);\n            if (this._drawing) this.feature.setLatLng(e.latlng);\n        },\n\n        processDrawingClick: function (e) {\n            // 🍂namespace Editable\n            // 🍂section Drawing events\n            // 🍂event editable:drawing:clicked: Event\n            // Fired when user `click` while drawing, after all internal actions.\n            this.fireAndForward('editable:drawing:clicked', e);\n            this.commitDrawing(e);\n        },\n\n        connect: function (e) {\n            // On touch, the latlng has not been updated because there is\n            // no mousemove.\n            if (e) this.feature._latlng = e.latlng;\n            L.Editable.BaseEditor.prototype.connect.call(this, e);\n        }\n\n    });\n\n    // 🍂namespace Editable; 🍂class PathEditor; 🍂aka L.Editable.PathEditor\n    // 🍂inherits BaseEditor\n    // Base class for all path editors.\n    L.Editable.PathEditor = L.Editable.BaseEditor.extend({\n\n        CLOSED: false,\n        MIN_VERTEX: 2,\n\n        addHooks: function () {\n            L.Editable.BaseEditor.prototype.addHooks.call(this);\n            if (this.feature) this.initVertexMarkers();\n            return this;\n        },\n\n        initVertexMarkers: function (latlngs) {\n            if (!this.enabled()) return;\n            latlngs = latlngs || this.getLatLngs();\n            if (isFlat(latlngs)) this.addVertexMarkers(latlngs);\n            else for (var i = 0; i < latlngs.length; i++) this.initVertexMarkers(latlngs[i]);\n        },\n\n        getLatLngs: function () {\n            return this.feature.getLatLngs();\n        },\n\n        // 🍂method reset()\n        // Rebuild edit elements (Vertex, MiddleMarker, etc.).\n        reset: function () {\n            this.editLayer.clearLayers();\n            this.initVertexMarkers();\n        },\n\n        addVertexMarker: function (latlng, latlngs) {\n            return new this.tools.options.vertexMarkerClass(latlng, latlngs, this);\n        },\n\n        onNewVertex: function (vertex) {\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:new: VertexEvent\n            // Fired when a new vertex is created.\n            this.fireAndForward('editable:vertex:new', {latlng: vertex.latlng, vertex: vertex});\n        },\n\n        addVertexMarkers: function (latlngs) {\n            for (var i = 0; i < latlngs.length; i++) {\n                this.addVertexMarker(latlngs[i], latlngs);\n            }\n        },\n\n        refreshVertexMarkers: function (latlngs) {\n            latlngs = latlngs || this.getDefaultLatLngs();\n            for (var i = 0; i < latlngs.length; i++) {\n                latlngs[i].__vertex.update();\n            }\n        },\n\n        addMiddleMarker: function (left, right, latlngs) {\n            return new this.tools.options.middleMarkerClass(left, right, latlngs, this);\n        },\n\n        onVertexMarkerClick: function (e) {\n            L.Editable.makeCancellable(e);\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:click: CancelableVertexEvent\n            // Fired when a `click` is issued on a vertex, before any internal action is being processed.\n            this.fireAndForward('editable:vertex:click', e);\n            if (e._cancelled) return;\n            if (this.tools.drawing() && this.tools._drawingEditor !== this) return;\n            var index = e.vertex.getIndex(), commit;\n            if (e.originalEvent.ctrlKey) {\n                this.onVertexMarkerCtrlClick(e);\n            } else if (e.originalEvent.altKey) {\n                this.onVertexMarkerAltClick(e);\n            } else if (e.originalEvent.shiftKey) {\n                this.onVertexMarkerShiftClick(e);\n            } else if (e.originalEvent.metaKey) {\n                this.onVertexMarkerMetaKeyClick(e);\n            } else if (index === e.vertex.getLastIndex() && this._drawing === L.Editable.FORWARD) {\n                if (index >= this.MIN_VERTEX - 1) commit = true;\n            } else if (index === 0 && this._drawing === L.Editable.BACKWARD && this._drawnLatLngs.length >= this.MIN_VERTEX) {\n                commit = true;\n            } else if (index === 0 && this._drawing === L.Editable.FORWARD && this._drawnLatLngs.length >= this.MIN_VERTEX && this.CLOSED) {\n                commit = true;  // Allow to close on first point also for polygons\n            } else {\n                this.onVertexRawMarkerClick(e);\n            }\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:clicked: VertexEvent\n            // Fired when a `click` is issued on a vertex, after all internal actions.\n            this.fireAndForward('editable:vertex:clicked', e);\n            if (commit) this.commitDrawing(e);\n        },\n\n        onVertexRawMarkerClick: function (e) {\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:rawclick: CancelableVertexEvent\n            // Fired when a `click` is issued on a vertex without any special key and without being in drawing mode.\n            this.fireAndForward('editable:vertex:rawclick', e);\n            if (e._cancelled) return;\n            if (!this.vertexCanBeDeleted(e.vertex)) return;\n            e.vertex.delete();\n        },\n\n        vertexCanBeDeleted: function (vertex) {\n            return vertex.latlngs.length > this.MIN_VERTEX;\n        },\n\n        onVertexDeleted: function (e) {\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:deleted: VertexEvent\n            // Fired after a vertex has been deleted by user.\n            this.fireAndForward('editable:vertex:deleted', e);\n        },\n\n        onVertexMarkerCtrlClick: function (e) {\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:ctrlclick: VertexEvent\n            // Fired when a `click` with `ctrlKey` is issued on a vertex.\n            this.fireAndForward('editable:vertex:ctrlclick', e);\n        },\n\n        onVertexMarkerShiftClick: function (e) {\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:shiftclick: VertexEvent\n            // Fired when a `click` with `shiftKey` is issued on a vertex.\n            this.fireAndForward('editable:vertex:shiftclick', e);\n        },\n\n        onVertexMarkerMetaKeyClick: function (e) {\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:metakeyclick: VertexEvent\n            // Fired when a `click` with `metaKey` is issued on a vertex.\n            this.fireAndForward('editable:vertex:metakeyclick', e);\n        },\n\n        onVertexMarkerAltClick: function (e) {\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:altclick: VertexEvent\n            // Fired when a `click` with `altKey` is issued on a vertex.\n            this.fireAndForward('editable:vertex:altclick', e);\n        },\n\n        onVertexMarkerContextMenu: function (e) {\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:contextmenu: VertexEvent\n            // Fired when a `contextmenu` is issued on a vertex.\n            this.fireAndForward('editable:vertex:contextmenu', e);\n        },\n\n        onVertexMarkerMouseDown: function (e) {\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:mousedown: VertexEvent\n            // Fired when user `mousedown` a vertex.\n            this.fireAndForward('editable:vertex:mousedown', e);\n        },\n\n        onVertexMarkerMouseOver: function (e) {\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:mouseover: VertexEvent\n            // Fired when a user's mouse enters the vertex\n            this.fireAndForward('editable:vertex:mouseover', e);\n        },\n\n        onVertexMarkerMouseOut: function (e) {\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:mouseout: VertexEvent\n            // Fired when a user's mouse leaves the vertex\n            this.fireAndForward('editable:vertex:mouseout', e);\n        },\n\n        onMiddleMarkerMouseDown: function (e) {\n            // 🍂namespace Editable\n            // 🍂section MiddleMarker events\n            // 🍂event editable:middlemarker:mousedown: VertexEvent\n            // Fired when user `mousedown` a middle marker.\n            this.fireAndForward('editable:middlemarker:mousedown', e);\n        },\n\n        onVertexMarkerDrag: function (e) {\n            this.onMove(e);\n            if (this.feature._bounds) this.extendBounds(e);\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:drag: VertexEvent\n            // Fired when a vertex is dragged by user.\n            this.fireAndForward('editable:vertex:drag', e);\n        },\n\n        onVertexMarkerDragStart: function (e) {\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:dragstart: VertexEvent\n            // Fired before a vertex is dragged by user.\n            this.fireAndForward('editable:vertex:dragstart', e);\n        },\n\n        onVertexMarkerDragEnd: function (e) {\n            // 🍂namespace Editable\n            // 🍂section Vertex events\n            // 🍂event editable:vertex:dragend: VertexEvent\n            // Fired after a vertex is dragged by user.\n            this.fireAndForward('editable:vertex:dragend', e);\n        },\n\n        setDrawnLatLngs: function (latlngs) {\n            this._drawnLatLngs = latlngs || this.getDefaultLatLngs();\n        },\n\n        startDrawing: function () {\n            if (!this._drawnLatLngs) this.setDrawnLatLngs();\n            L.Editable.BaseEditor.prototype.startDrawing.call(this);\n        },\n\n        startDrawingForward: function () {\n            this.startDrawing();\n        },\n\n        endDrawing: function () {\n            this.tools.detachForwardLineGuide();\n            this.tools.detachBackwardLineGuide();\n            if (this._drawnLatLngs && this._drawnLatLngs.length < this.MIN_VERTEX) this.deleteShape(this._drawnLatLngs);\n            L.Editable.BaseEditor.prototype.endDrawing.call(this);\n            delete this._drawnLatLngs;\n        },\n\n        addLatLng: function (latlng) {\n            if (this._drawing === L.Editable.FORWARD) this._drawnLatLngs.push(latlng);\n            else this._drawnLatLngs.unshift(latlng);\n            this.feature._bounds.extend(latlng);\n            var vertex = this.addVertexMarker(latlng, this._drawnLatLngs);\n            this.onNewVertex(vertex);\n            this.refresh();\n        },\n\n        newPointForward: function (latlng) {\n            this.addLatLng(latlng);\n            this.tools.attachForwardLineGuide();\n            this.tools.anchorForwardLineGuide(latlng);\n        },\n\n        newPointBackward: function (latlng) {\n            this.addLatLng(latlng);\n            this.tools.anchorBackwardLineGuide(latlng);\n        },\n\n        // 🍂namespace PathEditor\n        // 🍂method push()\n        // Programmatically add a point while drawing.\n        push: function (latlng) {\n            if (!latlng) return console.error('L.Editable.PathEditor.push expect a valid latlng as parameter');\n            if (this._drawing === L.Editable.FORWARD) this.newPointForward(latlng);\n            else this.newPointBackward(latlng);\n        },\n\n        removeLatLng: function (latlng) {\n            latlng.__vertex.delete();\n            this.refresh();\n        },\n\n        // 🍂method pop(): L.LatLng or null\n        // Programmatically remove last point (if any) while drawing.\n        pop: function () {\n            if (this._drawnLatLngs.length <= 1) return;\n            var latlng;\n            if (this._drawing === L.Editable.FORWARD) latlng = this._drawnLatLngs[this._drawnLatLngs.length - 1];\n            else latlng = this._drawnLatLngs[0];\n            this.removeLatLng(latlng);\n            if (this._drawing === L.Editable.FORWARD) this.tools.anchorForwardLineGuide(this._drawnLatLngs[this._drawnLatLngs.length - 1]);\n            else this.tools.anchorForwardLineGuide(this._drawnLatLngs[0]);\n            return latlng;\n        },\n\n        processDrawingClick: function (e) {\n            if (e.vertex && e.vertex.editor === this) return;\n            if (this._drawing === L.Editable.FORWARD) this.newPointForward(e.latlng);\n            else this.newPointBackward(e.latlng);\n            this.fireAndForward('editable:drawing:clicked', e);\n        },\n\n        onDrawingMouseMove: function (e) {\n            L.Editable.BaseEditor.prototype.onDrawingMouseMove.call(this, e);\n            if (this._drawing) {\n                this.tools.moveForwardLineGuide(e.latlng);\n                this.tools.moveBackwardLineGuide(e.latlng);\n            }\n        },\n\n        refresh: function () {\n            this.feature.redraw();\n            this.onEditing();\n        },\n\n        // 🍂namespace PathEditor\n        // 🍂method newShape(latlng?: L.LatLng)\n        // Add a new shape (Polyline, Polygon) in a multi, and setup up drawing tools to draw it;\n        // if optional `latlng` is given, start a path at this point.\n        newShape: function (latlng) {\n            var shape = this.addNewEmptyShape();\n            if (!shape) return;\n            this.setDrawnLatLngs(shape[0] || shape);  // Polygon or polyline\n            this.startDrawingForward();\n            // 🍂namespace Editable\n            // 🍂section Shape events\n            // 🍂event editable:shape:new: ShapeEvent\n            // Fired when a new shape is created in a multi (Polygon or Polyline).\n            this.fireAndForward('editable:shape:new', {shape: shape});\n            if (latlng) this.newPointForward(latlng);\n        },\n\n        deleteShape: function (shape, latlngs) {\n            var e = {shape: shape};\n            L.Editable.makeCancellable(e);\n            // 🍂namespace Editable\n            // 🍂section Shape events\n            // 🍂event editable:shape:delete: CancelableShapeEvent\n            // Fired before a new shape is deleted in a multi (Polygon or Polyline).\n            this.fireAndForward('editable:shape:delete', e);\n            if (e._cancelled) return;\n            shape = this._deleteShape(shape, latlngs);\n            if (this.ensureNotFlat) this.ensureNotFlat();  // Polygon.\n            this.feature.setLatLngs(this.getLatLngs());  // Force bounds reset.\n            this.refresh();\n            this.reset();\n            // 🍂namespace Editable\n            // 🍂section Shape events\n            // 🍂event editable:shape:deleted: ShapeEvent\n            // Fired after a new shape is deleted in a multi (Polygon or Polyline).\n            this.fireAndForward('editable:shape:deleted', {shape: shape});\n            return shape;\n        },\n\n        _deleteShape: function (shape, latlngs) {\n            latlngs = latlngs || this.getLatLngs();\n            if (!latlngs.length) return;\n            var self = this,\n                inplaceDelete = function (latlngs, shape) {\n                    // Called when deleting a flat latlngs\n                    shape = latlngs.splice(0, Number.MAX_VALUE);\n                    return shape;\n                },\n                spliceDelete = function (latlngs, shape) {\n                    // Called when removing a latlngs inside an array\n                    latlngs.splice(latlngs.indexOf(shape), 1);\n                    if (!latlngs.length) self._deleteShape(latlngs);\n                    return shape;\n                };\n            if (latlngs === shape) return inplaceDelete(latlngs, shape);\n            for (var i = 0; i < latlngs.length; i++) {\n                if (latlngs[i] === shape) return spliceDelete(latlngs, shape);\n                else if (latlngs[i].indexOf(shape) !== -1) return spliceDelete(latlngs[i], shape);\n            }\n        },\n\n        // 🍂namespace PathEditor\n        // 🍂method deleteShapeAt(latlng: L.LatLng): Array\n        // Remove a path shape at the given `latlng`.\n        deleteShapeAt: function (latlng) {\n            var shape = this.feature.shapeAt(latlng);\n            if (shape) return this.deleteShape(shape);\n        },\n\n        // 🍂method appendShape(shape: Array)\n        // Append a new shape to the Polygon or Polyline.\n        appendShape: function (shape) {\n            this.insertShape(shape);\n        },\n\n        // 🍂method prependShape(shape: Array)\n        // Prepend a new shape to the Polygon or Polyline.\n        prependShape: function (shape) {\n            this.insertShape(shape, 0);\n        },\n\n        // 🍂method insertShape(shape: Array, index: int)\n        // Insert a new shape to the Polygon or Polyline at given index (default is to append).\n        insertShape: function (shape, index) {\n            this.ensureMulti();\n            shape = this.formatShape(shape);\n            if (typeof index === 'undefined') index = this.feature._latlngs.length;\n            this.feature._latlngs.splice(index, 0, shape);\n            this.feature.redraw();\n            if (this._enabled) this.reset();\n        },\n\n        extendBounds: function (e) {\n            this.feature._bounds.extend(e.vertex.latlng);\n        },\n\n        onDragStart: function (e) {\n            this.editLayer.clearLayers();\n            L.Editable.BaseEditor.prototype.onDragStart.call(this, e);\n        },\n\n        onDragEnd: function (e) {\n            this.initVertexMarkers();\n            L.Editable.BaseEditor.prototype.onDragEnd.call(this, e);\n        }\n\n    });\n\n    // 🍂namespace Editable; 🍂class PolylineEditor; 🍂aka L.Editable.PolylineEditor\n    // 🍂inherits PathEditor\n    L.Editable.PolylineEditor = L.Editable.PathEditor.extend({\n\n        startDrawingBackward: function () {\n            this._drawing = L.Editable.BACKWARD;\n            this.startDrawing();\n        },\n\n        // 🍂method continueBackward(latlngs?: Array)\n        // Set up drawing tools to continue the line backward.\n        continueBackward: function (latlngs) {\n            if (this.drawing()) return;\n            latlngs = latlngs || this.getDefaultLatLngs();\n            this.setDrawnLatLngs(latlngs);\n            if (latlngs.length > 0) {\n                this.tools.attachBackwardLineGuide();\n                this.tools.anchorBackwardLineGuide(latlngs[0]);\n            }\n            this.startDrawingBackward();\n        },\n\n        // 🍂method continueForward(latlngs?: Array)\n        // Set up drawing tools to continue the line forward.\n        continueForward: function (latlngs) {\n            if (this.drawing()) return;\n            latlngs = latlngs || this.getDefaultLatLngs();\n            this.setDrawnLatLngs(latlngs);\n            if (latlngs.length > 0) {\n                this.tools.attachForwardLineGuide();\n                this.tools.anchorForwardLineGuide(latlngs[latlngs.length - 1]);\n            }\n            this.startDrawingForward();\n        },\n\n        getDefaultLatLngs: function (latlngs) {\n            latlngs = latlngs || this.feature._latlngs;\n            if (!latlngs.length || latlngs[0] instanceof L.LatLng) return latlngs;\n            else return this.getDefaultLatLngs(latlngs[0]);\n        },\n\n        ensureMulti: function () {\n            if (this.feature._latlngs.length && isFlat(this.feature._latlngs)) {\n                this.feature._latlngs = [this.feature._latlngs];\n            }\n        },\n\n        addNewEmptyShape: function () {\n            if (this.feature._latlngs.length) {\n                var shape = [];\n                this.appendShape(shape);\n                return shape;\n            } else {\n                return this.feature._latlngs;\n            }\n        },\n\n        formatShape: function (shape) {\n            if (isFlat(shape)) return shape;\n            else if (shape[0]) return this.formatShape(shape[0]);\n        },\n\n        // 🍂method splitShape(latlngs?: Array, index: int)\n        // Split the given `latlngs` shape at index `index` and integrate new shape in instance `latlngs`.\n        splitShape: function (shape, index) {\n            if (!index || index >= shape.length - 1) return;\n            this.ensureMulti();\n            var shapeIndex = this.feature._latlngs.indexOf(shape);\n            if (shapeIndex === -1) return;\n            var first = shape.slice(0, index + 1),\n                second = shape.slice(index);\n            // We deal with reference, we don't want twice the same latlng around.\n            second[0] = L.latLng(second[0].lat, second[0].lng, second[0].alt);\n            this.feature._latlngs.splice(shapeIndex, 1, first, second);\n            this.refresh();\n            this.reset();\n        }\n\n    });\n\n    // 🍂namespace Editable; 🍂class PolygonEditor; 🍂aka L.Editable.PolygonEditor\n    // 🍂inherits PathEditor\n    L.Editable.PolygonEditor = L.Editable.PathEditor.extend({\n\n        CLOSED: true,\n        MIN_VERTEX: 3,\n\n        newPointForward: function (latlng) {\n            L.Editable.PathEditor.prototype.newPointForward.call(this, latlng);\n            if (!this.tools.backwardLineGuide._latlngs.length) this.tools.anchorBackwardLineGuide(latlng);\n            if (this._drawnLatLngs.length === 2) this.tools.attachBackwardLineGuide();\n        },\n\n        addNewEmptyHole: function (latlng) {\n            this.ensureNotFlat();\n            var latlngs = this.feature.shapeAt(latlng);\n            if (!latlngs) return;\n            var holes = [];\n            latlngs.push(holes);\n            return holes;\n        },\n\n        // 🍂method newHole(latlng?: L.LatLng, index: int)\n        // Set up drawing tools for creating a new hole on the Polygon. If the `latlng` param is given, a first point is created.\n        newHole: function (latlng) {\n            var holes = this.addNewEmptyHole(latlng);\n            if (!holes) return;\n            this.setDrawnLatLngs(holes);\n            this.startDrawingForward();\n            if (latlng) this.newPointForward(latlng);\n        },\n\n        addNewEmptyShape: function () {\n            if (this.feature._latlngs.length && this.feature._latlngs[0].length) {\n                var shape = [];\n                this.appendShape(shape);\n                return shape;\n            } else {\n                return this.feature._latlngs;\n            }\n        },\n\n        ensureMulti: function () {\n            if (this.feature._latlngs.length && isFlat(this.feature._latlngs[0])) {\n                this.feature._latlngs = [this.feature._latlngs];\n            }\n        },\n\n        ensureNotFlat: function () {\n            if (!this.feature._latlngs.length || isFlat(this.feature._latlngs)) this.feature._latlngs = [this.feature._latlngs];\n        },\n\n        vertexCanBeDeleted: function (vertex) {\n            var parent = this.feature.parentShape(vertex.latlngs),\n                idx = L.Util.indexOf(parent, vertex.latlngs);\n            if (idx > 0) return true;  // Holes can be totally deleted without removing the layer itself.\n            return L.Editable.PathEditor.prototype.vertexCanBeDeleted.call(this, vertex);\n        },\n\n        getDefaultLatLngs: function () {\n            if (!this.feature._latlngs.length) this.feature._latlngs.push([]);\n            return this.feature._latlngs[0];\n        },\n\n        formatShape: function (shape) {\n            // [[1, 2], [3, 4]] => must be nested\n            // [] => must be nested\n            // [[]] => is already nested\n            if (isFlat(shape) && (!shape[0] || shape[0].length !== 0)) return [shape];\n            else return shape;\n        }\n\n    });\n\n    // 🍂namespace Editable; 🍂class RectangleEditor; 🍂aka L.Editable.RectangleEditor\n    // 🍂inherits PathEditor\n    L.Editable.RectangleEditor = L.Editable.PathEditor.extend({\n\n        CLOSED: true,\n        MIN_VERTEX: 4,\n\n        options: {\n            skipMiddleMarkers: true\n        },\n\n        extendBounds: function (e) {\n            var index = e.vertex.getIndex(),\n                next = e.vertex.getNext(),\n                previous = e.vertex.getPrevious(),\n                oppositeIndex = (index + 2) % 4,\n                opposite = e.vertex.latlngs[oppositeIndex],\n                bounds = new L.LatLngBounds(e.latlng, opposite);\n            // Update latlngs by hand to preserve order.\n            previous.latlng.update([e.latlng.lat, opposite.lng]);\n            next.latlng.update([opposite.lat, e.latlng.lng]);\n            this.updateBounds(bounds);\n            this.refreshVertexMarkers();\n        },\n\n        onDrawingMouseDown: function (e) {\n            L.Editable.PathEditor.prototype.onDrawingMouseDown.call(this, e);\n            this.connect();\n            var latlngs = this.getDefaultLatLngs();\n            // L.Polygon._convertLatLngs removes last latlng if it equals first point,\n            // which is the case here as all latlngs are [0, 0]\n            if (latlngs.length === 3) latlngs.push(e.latlng);\n            var bounds = new L.LatLngBounds(e.latlng, e.latlng);\n            this.updateBounds(bounds);\n            this.updateLatLngs(bounds);\n            this.refresh();\n            this.reset();\n            // Stop dragging map.\n            // L.Draggable has two workflows:\n            // - mousedown => mousemove => mouseup\n            // - touchstart => touchmove => touchend\n            // Problem: L.Map.Tap does not allow us to listen to touchstart, so we only\n            // can deal with mousedown, but then when in a touch device, we are dealing with\n            // simulated events (actually simulated by L.Map.Tap), which are no more taken\n            // into account by L.Draggable.\n            // Ref.: https://github.com/Leaflet/Leaflet.Editable/issues/103\n            e.originalEvent._simulated = false;\n            this.map.dragging._draggable._onUp(e.originalEvent);\n            // Now transfer ongoing drag action to the bottom right corner.\n            // Should we refine which corner will handle the drag according to\n            // drag direction?\n            latlngs[3].__vertex.dragging._draggable._onDown(e.originalEvent);\n        },\n\n        onDrawingMouseUp: function (e) {\n            this.commitDrawing(e);\n            e.originalEvent._simulated = false;\n            L.Editable.PathEditor.prototype.onDrawingMouseUp.call(this, e);\n        },\n\n        onDrawingMouseMove: function (e) {\n            e.originalEvent._simulated = false;\n            L.Editable.PathEditor.prototype.onDrawingMouseMove.call(this, e);\n        },\n\n\n        getDefaultLatLngs: function (latlngs) {\n            return latlngs || this.feature._latlngs[0];\n        },\n\n        updateBounds: function (bounds) {\n            this.feature._bounds = bounds;\n        },\n\n        updateLatLngs: function (bounds) {\n            var latlngs = this.getDefaultLatLngs(),\n                newLatlngs = this.feature._boundsToLatLngs(bounds);\n            // Keep references.\n            for (var i = 0; i < latlngs.length; i++) {\n                latlngs[i].update(newLatlngs[i]);\n            }\n        }\n\n    });\n\n    // 🍂namespace Editable; 🍂class CircleEditor; 🍂aka L.Editable.CircleEditor\n    // 🍂inherits PathEditor\n    L.Editable.CircleEditor = L.Editable.PathEditor.extend({\n\n        MIN_VERTEX: 2,\n\n        options: {\n            skipMiddleMarkers: true\n        },\n\n        initialize: function (map, feature, options) {\n            L.Editable.PathEditor.prototype.initialize.call(this, map, feature, options);\n            this._resizeLatLng = this.computeResizeLatLng();\n        },\n\n        computeResizeLatLng: function () {\n            // While circle is not added to the map, _radius is not set.\n            var delta = (this.feature._radius || this.feature._mRadius) * Math.cos(Math.PI / 4),\n                point = this.map.project(this.feature._latlng);\n            return this.map.unproject([point.x + delta, point.y - delta]);\n        },\n\n        updateResizeLatLng: function () {\n            this._resizeLatLng.update(this.computeResizeLatLng());\n            this._resizeLatLng.__vertex.update();\n        },\n\n        getLatLngs: function () {\n            return [this.feature._latlng, this._resizeLatLng];\n        },\n\n        getDefaultLatLngs: function () {\n            return this.getLatLngs();\n        },\n\n        onVertexMarkerDrag: function (e) {\n            if (e.vertex.getIndex() === 1) this.resize(e);\n            else this.updateResizeLatLng(e);\n            L.Editable.PathEditor.prototype.onVertexMarkerDrag.call(this, e);\n        },\n\n        resize: function (e) {\n            var radius = this.feature._latlng.distanceTo(e.latlng);\n            this.feature.setRadius(radius);\n        },\n\n        onDrawingMouseDown: function (e) {\n            L.Editable.PathEditor.prototype.onDrawingMouseDown.call(this, e);\n            this._resizeLatLng.update(e.latlng);\n            this.feature._latlng.update(e.latlng);\n            this.connect();\n            // Stop dragging map.\n            e.originalEvent._simulated = false;\n            this.map.dragging._draggable._onUp(e.originalEvent);\n            // Now transfer ongoing drag action to the radius handler.\n            this._resizeLatLng.__vertex.dragging._draggable._onDown(e.originalEvent);\n        },\n\n        onDrawingMouseUp: function (e) {\n            this.commitDrawing(e);\n            e.originalEvent._simulated = false;\n            L.Editable.PathEditor.prototype.onDrawingMouseUp.call(this, e);\n        },\n\n        onDrawingMouseMove: function (e) {\n            e.originalEvent._simulated = false;\n            L.Editable.PathEditor.prototype.onDrawingMouseMove.call(this, e);\n        },\n\n        onDrag: function (e) {\n            L.Editable.PathEditor.prototype.onDrag.call(this, e);\n            this.feature.dragging.updateLatLng(this._resizeLatLng);\n        }\n\n    });\n\n    // 🍂namespace Editable; 🍂class EditableMixin\n    // `EditableMixin` is included to `L.Polyline`, `L.Polygon`, `L.Rectangle`, `L.Circle`\n    // and `L.Marker`. It adds some methods to them.\n    // *When editing is enabled, the editor is accessible on the instance with the\n    // `editor` property.*\n    var EditableMixin = {\n\n        createEditor: function (map) {\n            map = map || this._map;\n            var tools = (this.options.editOptions || {}).editTools || map.editTools;\n            if (!tools) throw Error('Unable to detect Editable instance.');\n            var Klass = this.options.editorClass || this.getEditorClass(tools);\n            return new Klass(map, this, this.options.editOptions);\n        },\n\n        // 🍂method enableEdit(map?: L.Map): this.editor\n        // Enable editing, by creating an editor if not existing, and then calling `enable` on it.\n        enableEdit: function (map) {\n            if (!this.editor) this.createEditor(map);\n            this.editor.enable();\n            return this.editor;\n        },\n\n        // 🍂method editEnabled(): boolean\n        // Return true if current instance has an editor attached, and this editor is enabled.\n        editEnabled: function () {\n            return this.editor && this.editor.enabled();\n        },\n\n        // 🍂method disableEdit()\n        // Disable editing, also remove the editor property reference.\n        disableEdit: function () {\n            if (this.editor) {\n                this.editor.disable();\n                delete this.editor;\n            }\n        },\n\n        // 🍂method toggleEdit()\n        // Enable or disable editing, according to current status.\n        toggleEdit: function () {\n            if (this.editEnabled()) this.disableEdit();\n            else this.enableEdit();\n        },\n\n        _onEditableAdd: function () {\n            if (this.editor) this.enableEdit();\n        }\n\n    };\n\n    var PolylineMixin = {\n\n        getEditorClass: function (tools) {\n            return (tools && tools.options.polylineEditorClass) ? tools.options.polylineEditorClass : L.Editable.PolylineEditor;\n        },\n\n        shapeAt: function (latlng, latlngs) {\n            // We can have those cases:\n            // - latlngs are just a flat array of latlngs, use this\n            // - latlngs is an array of arrays of latlngs, loop over\n            var shape = null;\n            latlngs = latlngs || this._latlngs;\n            if (!latlngs.length) return shape;\n            else if (isFlat(latlngs) && this.isInLatLngs(latlng, latlngs)) shape = latlngs;\n            else for (var i = 0; i < latlngs.length; i++) if (this.isInLatLngs(latlng, latlngs[i])) return latlngs[i];\n            return shape;\n        },\n\n        isInLatLngs: function (l, latlngs) {\n            if (!latlngs) return false;\n            var i, k, len, part = [], p,\n                w = this._clickTolerance();\n            this._projectLatlngs(latlngs, part, this._pxBounds);\n            part = part[0];\n            p = this._map.latLngToLayerPoint(l);\n\n            if (!this._pxBounds.contains(p)) { return false; }\n            for (i = 1, len = part.length, k = 0; i < len; k = i++) {\n\n                if (L.LineUtil.pointToSegmentDistance(p, part[k], part[i]) <= w) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n    };\n\n    var PolygonMixin = {\n\n        getEditorClass: function (tools) {\n            return (tools && tools.options.polygonEditorClass) ? tools.options.polygonEditorClass : L.Editable.PolygonEditor;\n        },\n\n        shapeAt: function (latlng, latlngs) {\n            // We can have those cases:\n            // - latlngs are just a flat array of latlngs, use this\n            // - latlngs is an array of arrays of latlngs, this is a simple polygon (maybe with holes), use the first\n            // - latlngs is an array of arrays of arrays, this is a multi, loop over\n            var shape = null;\n            latlngs = latlngs || this._latlngs;\n            if (!latlngs.length) return shape;\n            else if (isFlat(latlngs) && this.isInLatLngs(latlng, latlngs)) shape = latlngs;\n            else if (isFlat(latlngs[0]) && this.isInLatLngs(latlng, latlngs[0])) shape = latlngs;\n            else for (var i = 0; i < latlngs.length; i++) if (this.isInLatLngs(latlng, latlngs[i][0])) return latlngs[i];\n            return shape;\n        },\n\n        isInLatLngs: function (l, latlngs) {\n            var inside = false, l1, l2, j, k, len2;\n\n            for (j = 0, len2 = latlngs.length, k = len2 - 1; j < len2; k = j++) {\n                l1 = latlngs[j];\n                l2 = latlngs[k];\n\n                if (((l1.lat > l.lat) !== (l2.lat > l.lat)) &&\n                    (l.lng < (l2.lng - l1.lng) * (l.lat - l1.lat) / (l2.lat - l1.lat) + l1.lng)) {\n                    inside = !inside;\n                }\n            }\n\n            return inside;\n        },\n\n        parentShape: function (shape, latlngs) {\n            latlngs = latlngs || this._latlngs;\n            if (!latlngs) return;\n            var idx = L.Util.indexOf(latlngs, shape);\n            if (idx !== -1) return latlngs;\n            for (var i = 0; i < latlngs.length; i++) {\n                idx = L.Util.indexOf(latlngs[i], shape);\n                if (idx !== -1) return latlngs[i];\n            }\n        }\n\n    };\n\n\n    var MarkerMixin = {\n\n        getEditorClass: function (tools) {\n            return (tools && tools.options.markerEditorClass) ? tools.options.markerEditorClass : L.Editable.MarkerEditor;\n        }\n\n    };\n\n    var RectangleMixin = {\n\n        getEditorClass: function (tools) {\n            return (tools && tools.options.rectangleEditorClass) ? tools.options.rectangleEditorClass : L.Editable.RectangleEditor;\n        }\n\n    };\n\n    var CircleMixin = {\n\n        getEditorClass: function (tools) {\n            return (tools && tools.options.circleEditorClass) ? tools.options.circleEditorClass : L.Editable.CircleEditor;\n        }\n\n    };\n\n    var keepEditable = function () {\n        // Make sure you can remove/readd an editable layer.\n        this.on('add', this._onEditableAdd);\n    };\n\n    var isFlat = L.LineUtil.isFlat || L.LineUtil._flat || L.Polyline._flat;  // <=> 1.1 compat.\n\n\n    if (L.Polyline) {\n        L.Polyline.include(EditableMixin);\n        L.Polyline.include(PolylineMixin);\n        L.Polyline.addInitHook(keepEditable);\n    }\n    if (L.Polygon) {\n        L.Polygon.include(EditableMixin);\n        L.Polygon.include(PolygonMixin);\n    }\n    if (L.Marker) {\n        L.Marker.include(EditableMixin);\n        L.Marker.include(MarkerMixin);\n        L.Marker.addInitHook(keepEditable);\n    }\n    if (L.Rectangle) {\n        L.Rectangle.include(EditableMixin);\n        L.Rectangle.include(RectangleMixin);\n    }\n    if (L.Circle) {\n        L.Circle.include(EditableMixin);\n        L.Circle.include(CircleMixin);\n    }\n\n    L.LatLng.prototype.update = function (latlng) {\n        latlng = L.latLng(latlng);\n        this.lat = latlng.lat;\n        this.lng = latlng.lng;\n    }\n}\ninit(window.L)\n\n\n\n\n// WEBPACK FOOTER //\n// ./Vue2LeafletEditablePlugin.js"],"sourceRoot":""}